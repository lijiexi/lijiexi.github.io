<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="快乐就完事了">
<meta name="theme-color" content="#000">
<title>Introduction to C | 笑福林地</title>
<link rel="shortcut icon" href="/favicon.ico?v=1655664938571">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="Introduction to C" />
  <meta name="keywords" content="C" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>笑福林地</span>
            </a>  
          
        </div>
        
          <p class="subtitle">快乐就完事了</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tag/ZmA5lXDkq/" target="_self">
                  <i class="fa fa-globe"></i> 英国课程
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tag/VMzbm0Kbs/" target="_self">
                  <i class="fa fa-globe"></i> Java
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tag/4ne5QpLXM/" target="_self">
                  <i class="fa fa-globe"></i> C
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tag/_wwWwltd7/" target="_self">
                  <i class="fa fa-globe"></i> Redis
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tag/F3Pks3TvS/" target="_self">
                  <i class="fa fa-globe"></i> 问题解决
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tag/KFuNHi-bR/" target="_self">
                  <i class="fa fa-globe"></i> LeetCode
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/post/about" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> 归档
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-globe"></i> 标签
                </a>
              
            </li>
          
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Jiexi</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>:)</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">43</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">6</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  

  



</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#c-language-features">C language features</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#hello-world">Hello World!</a></li>
<li><a href="#complie-and-run">Complie and run</a></li>
<li><a href="#c-keywords-and-identifiers">C keywords and Identifiers</a></li>
<li><a href="#integer-types">Integer Types</a></li>
<li><a href="#datatypes">Datatypes</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://lijiexi.github.io/post/introduction-to-c/"> Introduction to C </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2022-01-29 03:34:49">2022-01-29</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">标签:</span>
       
      <a href="https://lijiexi.github.io/tag/4ne5QpLXM/">
        <span>C</span>
      </a>
       
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >4<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >527<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <h3 id="c-language-features">C language features</h3>
<ul>
<li>
<p>Provides lowlevel access to memory</p>
</li>
<li>
<p>used in system programming</p>
<ul>
<li>Operating systems: such as Linux</li>
<li>Microcontrollers: cars and planes</li>
<li>embedded systems: phones, portable electronics, ..</li>
</ul>
</li>
<li>
<p>used in derivation of C++, Objective C, C#</p>
</li>
<li>
<p>C has enormous influence on other languages: Java, PHP, Python, . . .</p>
</li>
<li>
<p>High-level but close to the hardware</p>
</li>
<li>
<p>Fast: allows low-level programming</p>
</li>
<li>
<p>compiles to native code</p>
</li>
<li>
<p>C lacks: garbage collection, OOP, . . .</p>
</li>
</ul>
<h3 id="installation">Installation</h3>
<ul>
<li>Linux: included with most linux distributions
<ul>
<li>you can check it by entering this into the command line: gcc -v</li>
</ul>
</li>
<li>Mac OS: you need to install <a href="https://developer.apple.com/xcode/">Xcode</a></li>
<li>Windows: download and install <a href="http://www.mingw.org">MinGW</a>, ensure that bin subdirectory is in PATH</li>
</ul>
<h3 id="hello-world">Hello World!</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main(void)
{
  #&quot;\n&quot; is an escape character means &quot;newline&quot;
	printf(&quot;Hello World!\n&quot;);
  #0 indicates the program ends normally
	return 0;
}
</code></pre>
<ul>
<li>C standard library header files include function definitions, variable declarations.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;
</code></pre>
<ul>
<li><em><strong>Other header files are</strong></em> math.h, stdlib.h, string.h, time.h.</li>
<li><strong>the main entry of the of C programs, returns integer (int) and has no parameters (void) followed by a curly bracket</strong></li>
</ul>
<h3 id="complie-and-run">Complie and run</h3>
<ul>
<li><strong>save the code in hello.c (.c is the extension used for c language programs)</strong></li>
<li><strong>compile the program by entering to the command line</strong></li>
</ul>
<p>​	gcc hello.c</p>
<ul>
<li>
<p><strong>this create an executable file a.out on Linux and Mac OS, and a.exe on Windows</strong></p>
</li>
<li>
<p><strong>now you can run it by typing ./a.out (Linux MacOS) or a.exe (Windows)</strong></p>
</li>
<li>
<p><strong>you can change the name of the output file with:</strong></p>
<p>gcc hello.c -o hello</p>
</li>
</ul>
<h3 id="c-keywords-and-identifiers">C keywords and Identifiers</h3>
<p><strong>C keywords</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">auto</th>
<th style="text-align:center">break</th>
<th style="text-align:center">case</th>
<th style="text-align:center">char</th>
<th style="text-align:center">const</th>
<th style="text-align:center">continue</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>default</strong></td>
<td style="text-align:center"><strong>do</strong></td>
<td style="text-align:center"><strong>double</strong></td>
<td style="text-align:center"><strong>else</strong></td>
<td style="text-align:center"><strong>enum</strong></td>
<td style="text-align:center"><strong>extern</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>float</strong></td>
<td style="text-align:center"><strong>for</strong></td>
<td style="text-align:center"><strong>goto</strong></td>
<td style="text-align:center"><strong>if</strong></td>
<td style="text-align:center"><strong>int</strong></td>
<td style="text-align:center"><strong>long</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>register</strong></td>
<td style="text-align:center"><strong>return</strong></td>
<td style="text-align:center"><strong>short</strong></td>
<td style="text-align:center"><strong>signed</strong></td>
<td style="text-align:center"><strong>sizeof</strong></td>
<td style="text-align:center"><strong>static</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>struct</strong></td>
<td style="text-align:center"><strong>switch</strong></td>
<td style="text-align:center"><strong>typedef</strong></td>
<td style="text-align:center"><strong>union</strong></td>
<td style="text-align:center"><strong>unsigned</strong></td>
<td style="text-align:center"><strong>void</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>volatile</strong></td>
<td style="text-align:center"><strong>while</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="integer-types">Integer Types</h3>
<table>
<thead>
<tr>
<th style="text-align:center">datatype</th>
<th style="text-align:center">size</th>
<th style="text-align:center">range</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>char</strong></td>
<td style="text-align:center">1 byte</td>
<td style="text-align:center">-128 to 127 or 0 to 255</td>
</tr>
<tr>
<td style="text-align:center"><strong>unsigned char</strong></td>
<td style="text-align:center">1 byte</td>
<td style="text-align:center">0 to 255</td>
</tr>
<tr>
<td style="text-align:center"><strong>signed char</strong></td>
<td style="text-align:center">1 byte</td>
<td style="text-align:center">-128 to 127</td>
</tr>
<tr>
<td style="text-align:center"><strong>int</strong></td>
<td style="text-align:center">2 or 4 bytes</td>
<td style="text-align:center">-32,768 to 32,767 or -2,147,483,648 to 2,147,483,647</td>
</tr>
<tr>
<td style="text-align:center"><strong>unsigned int</strong></td>
<td style="text-align:center">2 or 4 bytes</td>
<td style="text-align:center">0 to 65,535 or 0 to 4,294,967,295</td>
</tr>
<tr>
<td style="text-align:center"><strong>short</strong></td>
<td style="text-align:center">2 bytes</td>
<td style="text-align:center">-32,768 to 32,767</td>
</tr>
<tr>
<td style="text-align:center"><strong>unsigned short</strong></td>
<td style="text-align:center">2 bytes</td>
<td style="text-align:center">0 to 65,535</td>
</tr>
<tr>
<td style="text-align:center"><strong>long</strong></td>
<td style="text-align:center">4 bytes</td>
<td style="text-align:center">-2,147,483,648 to 2,147,483,647</td>
</tr>
<tr>
<td style="text-align:center"><strong>unsigned long</strong></td>
<td style="text-align:center">4 bytes</td>
<td style="text-align:center">0 to 4,294,967,295</td>
</tr>
</tbody>
</table>
<h3 id="datatypes">Datatypes</h3>
<ul>
<li><strong>Integer Types</strong></li>
<li>in unsigned the most significant bit (MSB) will not be used as sign (+ or -)</li>
<li>The header file limits.h has many useful constants to check the range of different datatypes: SCHAR_MIN, SCHAR_MAX, UCHAR_MAX, INT_MIN, INT_MAX, UINT_MAX, ...</li>
<li><strong>Floating-Point Types</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">datatype</th>
<th style="text-align:center">size</th>
<th style="text-align:center">range</th>
<th style="text-align:center">precision</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">4 bytes</td>
<td style="text-align:center">1.2E-38 to 3.4E+38</td>
<td style="text-align:center">6 decimal places</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">8 bytes</td>
<td style="text-align:center">2.3E-308 to 1.7E+308</td>
<td style="text-align:center">15 decimal places</td>
</tr>
<tr>
<td style="text-align:center">long double</td>
<td style="text-align:center">10 bytes</td>
<td style="text-align:center">3.4E-4932 to 1.1E+4932</td>
<td style="text-align:center">19 decimal places</td>
</tr>
</tbody>
</table>
<ul>
<li>The header file float.h provides constants to check the range of float datatypes : FLT_MIN, FLT_MAX, ...</li>
<li><strong>the sizes and ranges may be different on you computer based on the platform you use (hardware and OS)</strong></li>
</ul>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      Jiexi
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://lijiexi.github.io/post/introduction-to-c/" title="Introduction to C">https://lijiexi.github.io/post/introduction-to-c/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://lijiexi.github.io/tag/4ne5QpLXM/"># C</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Variables, IO, and Operators" href="https://lijiexi.github.io/post/variables-io-and-operators/">Variables, IO, and Operators</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Variables, IO, and Operators" href="https://lijiexi.github.io/post/variables-io-and-operators/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="解决Tomcat启动成功后无法访问页面" href="https://lijiexi.github.io/post/jie-jue-tomcat-qi-dong-cheng-gong-hou-wu-fa-fang-wen-ye-mian/">解决Tomcat启动成功后无法访问页面</a>
        <a class="nav-mobile-next" title="解决Tomcat启动成功后无法访问页面" href="https://lijiexi.github.io/post/jie-jue-tomcat-qi-dong-cheng-gong-hou-wu-fa-fang-wen-ye-mian/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      
    </div>
  </footer>
  
    
        <div class="pisces back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "false";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/react-overview/"" data-c="
          &lt;h2 id=&#34;intro-to-react&#34;&gt;Intro to React&lt;/h2&gt;
&lt;h3 id=&#34;what-is-react&#34;&gt;What is React&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;React is a JavaScript library for building user interfaces created by Facebook.&lt;/li&gt;
&lt;li&gt;React allows us to create reusable UI components.&lt;/li&gt;
&lt;li&gt;A component takes in parameters, &lt;strong&gt;called &lt;em&gt;props&lt;/em&gt; (short for “properties”), and returns a &lt;em&gt;hierarchy of views&lt;/em&gt; to display via the &lt;em&gt;render&lt;/em&gt; method&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;React allows us to write JavaScript and HTML in the same file (JSX)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;understanding-the-virtual-dom&#34;&gt;Understanding the Virtual DOM&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;React uses a &lt;em&gt;virtual DOM&lt;/em&gt; to &lt;em&gt;handle page rendering&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;In SPA where the view is highly interactive, directly manipulate a web page via the HTML DOM can cause performance issues.&lt;/li&gt;
&lt;li&gt;Virtual DOM is an in-memory representation of the real DOM.
&lt;ul&gt;
&lt;li&gt;Unlike the HTML DOM, the virtual DOM is much easier to manipulate.&lt;/li&gt;
&lt;li&gt;Handling numerous operations in milliseconds without affecting page performance.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;React periodically compares the virtual DOM and the HTML DOM.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;what-is-jsx&#34;&gt;What is JSX?&lt;/h3&gt;
&lt;p&gt;• JavaScript and HTML &lt;em&gt;in the same file&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;• &lt;em&gt;JSX stands for JavaScript XML&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;• &lt;em&gt;JSX allows us to write HTML tags within JavaScript functions&lt;/em&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-06-02%2011.04.17.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;common-tasks-in-front-end-development&#34;&gt;Common tasks in front-end development&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-06-02%2011.05.31.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;anatomy-of-a-react-app&#34;&gt;Anatomy of a React app&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;index.js is the file first loaded (is used to generate index.html)&lt;/li&gt;
&lt;li&gt;Index.js willrenderthe component called App&lt;/li&gt;
&lt;li&gt;If you replace App with any other component, those will be rendered&lt;/li&gt;
&lt;li&gt;Uppercase tags are assumed to be React JSX&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;react-components&#34;&gt;React Components&lt;/h2&gt;
&lt;p&gt;A component is combination of&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Template using HTML&lt;/li&gt;
&lt;li&gt;User Interactivity using JS&lt;/li&gt;
&lt;li&gt;Applying Styles using CSS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Components come in two types, Class components and Function components&lt;/p&gt;
&lt;h3 id=&#34;create-a-class-component&#34;&gt;Create a Class Component&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;When creating a React component, the component&#39;s name must start with an upper case letter.&lt;/li&gt;
&lt;li&gt;The component has to include the extends React.Component statement, this statement creates an inheritance to &lt;strong&gt;React.Component, and gives your component access to React.Component&#39;s functions.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;The component also requires a render() method, this method returns HTML.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;create-a-function-component&#34;&gt;Create a Function Component&lt;/h3&gt;
&lt;p&gt;A Function component also returns HTML, and behaves pretty much the same way as a Class component.&lt;/p&gt;
&lt;h3 id=&#34;component-constructor&#34;&gt;Component Constructor&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;You can have a constructor() function in your component, this method will be called when the component gets initiated.&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;The constructor is where you initiate the component&#39;s properties.&lt;/li&gt;
&lt;li&gt;In React, component properties should be kept in an object called state.&lt;/li&gt;
&lt;li&gt;You also include the super() statement, which executes the parent component&#39;s constructor function, and allow your component to have access to all the functions of the parent component (React.Component).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;react-props&#34;&gt;React Props&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Another way of handling component properties is by using props.&lt;/li&gt;
&lt;li&gt;Props are like function arguments, and you send them into the component as attributes.&lt;/li&gt;
&lt;li&gt;To send props into a component, use the same syntax as HTML attributes.&lt;/li&gt;
&lt;li&gt;Props are also allow you pass data from one component to another, as parameters.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;react-class-component-state&#34;&gt;React Class Component State&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;React components has a built-in state object.&lt;/li&gt;
&lt;li&gt;The state object is where you store property values that belongs to the component.&lt;/li&gt;
&lt;li&gt;When the state object changes, the component re-renders.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-06-03%2010.06.00.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;class-based-vs-function-components-in-react&#34;&gt;Class-based vs Function Components in React&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Class components have a state and provide access to lifecycle methods like componentDidMount.&lt;/li&gt;
&lt;li&gt;stateless functional components are pure functions that do not have a state or lifecycle methods. They take in props and return html.&lt;/li&gt;
&lt;li&gt;With the addition of Hooks, Function components are now almost equivalent to Class components.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;hooks&#34;&gt;Hooks&lt;/h2&gt;
&lt;h3 id=&#34;what-are-react-hooks&#34;&gt;What are React Hooks?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;a feature lets you use &lt;em&gt;state&lt;/em&gt; and &lt;em&gt;life-cycle methods without&lt;/em&gt; writing a &lt;em&gt;class component&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;React Hooks allow us to take &lt;em&gt;Stateless Functional Components&lt;/em&gt; and apply &lt;em&gt;state&lt;/em&gt; and &lt;em&gt;lifecycle methods&lt;/em&gt; to them.&lt;/li&gt;
&lt;li&gt;Hooks can only be called inside React function components.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;qa&#34;&gt;Q&amp;amp;A&lt;/h1&gt;
&lt;h2 id=&#34;q1-common-web-framework-and-their-functionalities&#34;&gt;Q1 Common Web Framework and their Functionalities&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;URL routing&lt;/li&gt;
&lt;li&gt;Input form managing and validation&lt;/li&gt;
&lt;li&gt;HTML, XML, JSON, and other product setups with a templating engine&lt;/li&gt;
&lt;li&gt;Database connection configuration and resolute data manipulation through an object-relational mapper (ORM)&lt;/li&gt;
&lt;li&gt;Web security against Cross-site request forgery (CSRF), SQL Injection, Cross-site Scripting (XSS) and other frequent malicious attacks&lt;/li&gt;
&lt;li&gt;Session managment and retrieval&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;q2-front-end-back-end-frameworks-development-languages&#34;&gt;Q2 Front-end &amp;amp; Back-end Frameworks Development &amp;amp; Languages&lt;/h2&gt;
&lt;h3 id=&#34;back-end-server-side-languages&#34;&gt;Back-end (Server-side) Languages&lt;/h3&gt;
&lt;p&gt;Almost any programming language (C#, Java, Objective-C,PHP,Ruby,Python etc.) can be used to build server-side applications.&lt;/p&gt;
&lt;h3 id=&#34;back-end-frameworks&#34;&gt;Back-end Frameworks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ASP.NET(C#)&lt;/li&gt;
&lt;li&gt;Flask, Django(Python)&lt;/li&gt;
&lt;li&gt;Express(JS, Node.JS)&lt;/li&gt;
&lt;li&gt;Laravel(PHP)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;front-end-development-languages&#34;&gt;Front-end Development &amp;amp; Languages&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;HTML — Hypertext Mark-up Language: It is used to design thethe structure of web pages.&lt;/li&gt;
&lt;li&gt;CSS — Cascading Style Sheet: Allows you to apply styles to web pages independent of the HTML that makes up each web page.&lt;/li&gt;
&lt;li&gt;JS — JavaScript: A scripting language used to make the site interactive for the user.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;q3-dynamic-websitesapplications&#34;&gt;Q3 Dynamic Websites/Applications&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;dynamic site&lt;/em&gt; is one that can generate and return content based on the specific request URL and data (rather than always returning the same hard-coded file for a particular URL).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Using the example of a product site, the server would store product &amp;quot;data&amp;quot; in a database rather than individual HTML files.&lt;/li&gt;
&lt;li&gt;When receiving an HTTP GET Request for a product, the server determines the product ID, fetches the data from the database, and then constructs the HTML page for the response by inserting the data into an HTML template.&lt;/li&gt;
&lt;li&gt;Using a database allows the product information to be stored efficiently in an easily extensible, modifiable, and searchable way.&lt;/li&gt;
&lt;li&gt;Using HTML templates makes it very easy to change the HTML structure, because this only needs to be done in one place, in a single template, and not across potentially thousands of static pages.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;q4-single-page-vs-traditional-web-apps&#34;&gt;Q4 Single Page VS Traditional Web Apps&lt;/h2&gt;
&lt;p&gt;web site that interacts with the user by dynamically rewriting the current page rather than loading entire new pages from a server.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;making the application behave more like a desktop application.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SPAs serve a single page of html and use in page controls to operate dynamically.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Traditional web apps need to send many http requests, and get many html pages from the server. However Spas only need to initate the request get one html page, and use ajax to transfer data between front and back.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;q5-html-structural-elements-vs-css-styles&#34;&gt;Q5 HTML structural Elements vs CSS Styles&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The browser has its own default styling for each heading level.&lt;/li&gt;
&lt;li&gt;However, these are easily modified and customized via &lt;strong&gt;CSS&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;q6-different-style-of-using-css-in-conjunction-with-your-htlm-files&#34;&gt;Q6 Different style of using CSS in conjunction with your HTLM files&lt;/h2&gt;
&lt;h2 id=&#34;q7-different-concepts-of-functional-programming-in-javascript-such-immediately-invoked-function-call-back-promise-and-so-on&#34;&gt;Q7 Different concepts of functional programming in JavaScript such &lt;em&gt;Immediately invoked function,&lt;/em&gt; Call-back, Promise, and so on&lt;/h2&gt;
&lt;h3 id=&#34;immediately-invoked-function&#34;&gt;Immediately invoked function&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;An immediately invoked function expression (IIFE) is a design pattern that produces a lexical scope using function scoping.&lt;/li&gt;
&lt;li&gt;IIFE can be used to avoid variable hoisting from within blocks or to prevent us from polluting the global scope.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;call-back&#34;&gt;Call-back&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A callback is a function to be executed after another function has been executed&lt;/li&gt;
&lt;li&gt;Callbacks are the most common way to write and handle asynchronous logic in JavaScript programs&lt;/li&gt;
&lt;li&gt;In JavaScript, functions are objects. Functions can therefore take functions as arguments and can be returned by other functions. Functions that perform this operation are called higher-order functions. Any function that is passed as an argument is called a callback function.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;promise&#34;&gt;Promise&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;It serves the same function as callbacks but has a nicer syntax and makes it easier to handle errors.&lt;/li&gt;
&lt;li&gt;It can be used to write better &lt;em&gt;asynchronous&lt;/em&gt; code.&lt;/li&gt;
&lt;li&gt;a promise represents the result of an *asynchronous operation&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;q8-jsx-syntax-and-its-pro-and-con&#34;&gt;Q8 JSX Syntax and its pro and Con&lt;/h2&gt;
&lt;h3 id=&#34;jsx-syntax&#34;&gt;JSX Syntax&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Using JSX we can pass around HTML structures, or React elements as if they were standard JavaScript values.&lt;/li&gt;
&lt;li&gt;JavaScript and HTML &lt;em&gt;in the same file&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;JSX stands for JavaScript XML&lt;/li&gt;
&lt;li&gt;JSX allows us to write HTML tags within JavaScript functions&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pro&#34;&gt;Pro&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The program structure is easier to visualize&lt;/li&gt;
&lt;li&gt;JSX is more flexible&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;con&#34;&gt;Con&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;jsx is not a template, and it&#39;s hard to understand&lt;/li&gt;
&lt;li&gt;Code of jsx does not look neat&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;q9-stateful-and-stateless-components-different-phases-of-react-class-components-lifecycle&#34;&gt;Q9 Stateful and Stateless Components, different phases of React class component’s lifecycle&lt;/h2&gt;
&lt;h3 id=&#34;stateful-and-stateless-components&#34;&gt;Stateful and Stateless components&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;React components can further be categorized into &lt;em&gt;stateful&lt;/em&gt; and &lt;em&gt;stateless&lt;/em&gt; components.&lt;/li&gt;
&lt;li&gt;A &lt;em&gt;stateless&lt;/em&gt; component’s work is simply to &lt;em&gt;display data&lt;/em&gt; that it &lt;em&gt;receives&lt;/em&gt; from its &lt;em&gt;parent&lt;/em&gt; React component.
&lt;ul&gt;
&lt;li&gt;If it receives any &lt;em&gt;events&lt;/em&gt; or &lt;em&gt;inputs&lt;/em&gt;, it can simply &lt;em&gt;pass&lt;/em&gt; these up to &lt;em&gt;its parent&lt;/em&gt; to &lt;em&gt;handle&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A &lt;em&gt;stateful component&lt;/em&gt;, on the other hand, is &lt;em&gt;responsible&lt;/em&gt; for &lt;em&gt;maintaining&lt;/em&gt; some &lt;em&gt;kind&lt;/em&gt; of &lt;em&gt;application state&lt;/em&gt;
&lt;ul&gt;
&lt;li&gt;This might involve &lt;em&gt;data&lt;/em&gt; being &lt;em&gt;fetched&lt;/em&gt; from an &lt;em&gt;external source&lt;/em&gt;, or &lt;em&gt;keeping track&lt;/em&gt; of whether a &lt;em&gt;user&lt;/em&gt; is &lt;em&gt;logged&lt;/em&gt; in or &lt;em&gt;not&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;A &lt;em&gt;stateful component&lt;/em&gt; can &lt;em&gt;respond&lt;/em&gt; to &lt;em&gt;events&lt;/em&gt; and &lt;em&gt;inputs&lt;/em&gt; to &lt;em&gt;update&lt;/em&gt; its &lt;em&gt;state&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lifecycle-of-components&#34;&gt;Lifecycle of Components&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Each component in React has a lifecycle which you can monitor and manipulate during its three main phases.
&lt;ul&gt;
&lt;li&gt;The three phases are: &lt;strong&gt;Mounting, Updating, and Unmounting&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;react-component-lifecycle-diagram&#34;&gt;React Component Lifecycle Diagram&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-06-03%2010.22.45.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;lifecycle-of-components-mounting&#34;&gt;Lifecycle of Components – Mounting&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Mounting : means putting elements into the DOM.
&lt;ul&gt;
&lt;li&gt;React has four built-in methods that gets called, in this order, when mounting a component:
&lt;ul&gt;
&lt;li&gt;constructor()&lt;/li&gt;
&lt;li&gt;getDerivedStateFromProps()&lt;/li&gt;
&lt;li&gt;render()&lt;/li&gt;
&lt;li&gt;componentDidMount()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The render() method is required and will always be called, the others are optional and will be called if you define them.&lt;/li&gt;
&lt;li&gt;The constructor() method is called before anything else, when the component is initiated, and it is the natural place to set up the initial state and other initial values.&lt;/li&gt;
&lt;li&gt;The getDerivedStateFromProps() method is called right before &lt;em&gt;rendering&lt;/em&gt; the element(s) in the DOM.&lt;/li&gt;
&lt;li&gt;The componentDidMount() method is called after the component is &lt;em&gt;rendered&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lifecycle-of-components-updating&#34;&gt;Lifecycle of Components – Updating&lt;/h3&gt;
&lt;p&gt;A component is updated whenever there is a change in the component&#39;s state or props.&lt;/p&gt;
&lt;h3 id=&#34;lifecycle-of-components-unmounting&#34;&gt;Lifecycle of Components – Unmounting&lt;/h3&gt;
&lt;p&gt;The next phase in the lifecycle is when a component is removed from the DOM, or &lt;em&gt;unmounting&lt;/em&gt; as React likes to call it.&lt;/p&gt;
&lt;h2 id=&#34;q10-class-based-vs-function-components-in-react&#34;&gt;Q10 Class-based vs Function Components in React&lt;/h2&gt;
&lt;h3 id=&#34;class-based-vs-function-components&#34;&gt;Class-based vs Function Components&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Class-based components will implement a render function, which returns some JSX (React’s extension of Regular JavaScript, used to create React elements),&lt;/li&gt;
&lt;li&gt;Whereas function components will return JSX directly.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;q11-limitations-of-the-class-style-components&#34;&gt;Q11 Limitations of the Class-style Components&lt;/h2&gt;
&lt;h3 id=&#34;limitations-of-the-class-style-components&#34;&gt;Limitations of the Class-style Components&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;did not provide good code reuse and component structure capabilities.&lt;/li&gt;
&lt;li&gt;harder to share logic between class components without using design patterns and reder props and higher-order components.&lt;/li&gt;
&lt;li&gt;class components are harder to understand, more complex, and require more &lt;em&gt;time&lt;/em&gt; and &lt;em&gt;effort&lt;/em&gt; to &lt;em&gt;maintain&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;need for a simpler implementation:Hooks&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;q12-what-are-react-hooks-understanding-of-different-kinds-of-hooks&#34;&gt;Q12 What are React Hooks?, Understanding of different kinds of Hooks&lt;/h2&gt;
&lt;h3 id=&#34;what-are-react-hooks-2&#34;&gt;What are React Hooks?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;a feature lets you use &lt;em&gt;state&lt;/em&gt; and &lt;em&gt;life-cycle methods without&lt;/em&gt; writing a &lt;em&gt;class component&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;React Hooks allow us to take &lt;em&gt;Stateless Functional Components&lt;/em&gt; and apply &lt;em&gt;state&lt;/em&gt; and &lt;em&gt;lifecycle methods&lt;/em&gt; to them.&lt;/li&gt;
&lt;li&gt;Hooks can only be called inside React function components.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;七大-hooks-都有哪些&#34;&gt;七大 Hooks 都有哪些&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;useState&lt;/code&gt; 状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;useEffect&lt;/code&gt; 钩子，还有它的兄弟 &lt;code&gt;useLayoutEffect&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;useContext&lt;/code&gt; 上下文&lt;/li&gt;
&lt;li&gt;&lt;code&gt;useReducer&lt;/code&gt; 代替 Redux&lt;/li&gt;
&lt;li&gt;&lt;code&gt;useMemo&lt;/code&gt; 缓存，还有它的小弟 &lt;code&gt;useCallback&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;useRef&lt;/code&gt; 引用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;自定义 Hook&lt;/code&gt; 混合&lt;/li&gt;
&lt;/ol&gt;
">React Overview</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/bytedance/"" data-c="
          &lt;h5 id=&#34;lru缓存请你设计并实现一个满足lru-最近最少使用-缓存约束的数据结构&#34;&gt;LRU缓存请你设计并实现一个满足LRU (最近最少使用) 缓存约束的数据结构。&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class LRUCache {
    class Node{
        int key;
        int value;
        Node pre;
        Node next;
        public Node(){}
        public Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
    private int size = 0;
  //key是node的key,value是Node对象。方便get快速获取值。
    private HashMap&amp;lt;Integer,Node&amp;gt; cache = new HashMap&amp;lt;&amp;gt;();
    private int capacity = 0;
    private Node head,tail;//双链表使队尾是可淘汰元素。
    public LRUCache(int capacity) {
        this.capacity = capacity;
        head = new Node();
        tail = new Node();
        head.next = tail;
        tail.pre = head;
    }
    
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        }
        moveToHead(node);
        return node.value;
    }
    private void moveToHead(Node node) {
        removeNode(node);
        addToHead(node);
    }
    private void removeNode(Node node) {
        node.pre.next = node.next;
        node.next.pre = node.pre;
    }
    private void addToHead (Node node) {
        node.pre = head;
        node.next = head.next;
        head.next.pre = node;
        head.next = node;
    }
    public void put(int key, int value) {
        Node node = cache.get(key);
        if (node == null) {
            Node newNode = new Node(key,value);
            cache.put(key,newNode);
            addToHead(newNode);
            size++;
            if (size &amp;gt; capacity) {
                Node tail = removeTail();
                cache.remove(tail.key);
            }
        } else {
            node.value = value;
            moveToHead(node);
        }
    }
    private Node removeTail() {
        Node res = tail.pre;
        removeNode(res);
        return res;//返回要在cache中删除掉node
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：对于 put 和 get 都是O(1)。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(capacity)，因为哈希表和双向链表最多存储capacity+1个元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;无重复字符的最长子串&#34;&gt;无重复字符的最长子串&lt;/h4&gt;
&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int lengthOfLongestSubstring(String s) {
        HashMap&amp;lt;Character,Integer&amp;gt; record = new HashMap&amp;lt;&amp;gt;();
        int left = 0;
        int right = 0;
        int res = 0;
        for (; right &amp;lt; s.length(); right++) {
            char ch = s.charAt(right);
            if (record.containsKey(ch)) {
                left = Math.max(record.get(ch)+1,left);
            }
            record.put(ch,right);
            res = Math.max(res,right-left+1);
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(N)，其中N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(∣Σ∣)，其中Σ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;k个一组翻转链表反转&#34;&gt;K个一组翻转链表反转&lt;/h4&gt;
&lt;p&gt;给你链表的头节点 &lt;code&gt;head&lt;/code&gt; ，每 &lt;code&gt;k&lt;/code&gt; 个节点一组进行翻转，请你返回修改后的链表。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        while (head != null) {
            ListNode tail = pre;
            // 剩余部分长度小于k直接返回
            for (int i = 0; i &amp;lt; k;i++) {
                tail = tail.next;
                if (tail == null) {
                    return dummy.next;
                }
            }
            ListNode next = tail.next;
            ListNode[] reverse = myReverse(head,tail);
            head = reverse[0];// 把子链表重新接回原链表
            tail = reverse[1];
            pre.next = head;//head上一个节点
            tail.next = next;//tail后一个节点
            pre = tail;
            head = tail.next;
        }
        return dummy.next;
    }
    private ListNode[] myReverse (ListNode head, ListNode tail) {
        ListNode pre = tail.next;
        ListNode cur = head;
        while (pre != tail) {
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return new ListNode[]{tail,head};
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)，其中 n 为链表的长度。head 指针会在 O(n/k)个节点上停留，每次停留需要进行一次 O(k) 的翻转操作。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)，只需要建立常数个变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;反转链表&#34;&gt;反转链表&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;迭代&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度: O(n)，其中 n 是链表的长度。需要遍历链表一次。&lt;/li&gt;
&lt;li&gt;空间复杂度: O(1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;递归&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
     	  //从最后一个节点一直反转到第一个节点
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n 层。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;二叉树的锯齿形层序遍历&#34;&gt;二叉树的锯齿形层序遍历&lt;/h4&gt;
&lt;p&gt;即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode root) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if (root == null) 
            return res;
        Deque&amp;lt;Integer&amp;gt; path;
        Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
        queue.offer(root);
        boolean flag = true;
        while (!queue.isEmpty()) {
            path = new LinkedList&amp;lt;&amp;gt;();
            int n = queue.size();
            for (int i = 0; i &amp;lt; n; i++) {
                TreeNode node = queue.poll();
            if (flag) {//左到右
                path.offerLast(node.val);
            } else {//右到左
                path.offerFirst(node.val);   
            }
            if (node.left != null)
                queue.offer(node.left);
            if (node.right != null)
                queue.offer(node.right); 
        }
            flag = !flag;
            res.add(new LinkedList(path));
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(N)，其中 N 为二叉树的节点数。每个节点会且仅会被遍历一次。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(N)。我们需要维护存储节点的队列和存储节点值的双端队列，空间复杂度为 O(N)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数组中的第k个最大元素-快排-quicksort-kth&#34;&gt;数组中的第K个最大元素  快排 quicksort kth&lt;/h4&gt;
&lt;p&gt;给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int findKthLargest(int[] nums, int k) {
        quickSort(nums,0,nums.length-1);
        return nums[nums.length-k];
    }
    private void quickSort(int[] nums,int left,int right){
        if(left&amp;lt;right){
            swap(nums,(int)(left+Math.random()*(right-left+1)),right);
            int[] res = partition(nums,left,right);
            quickSort(nums,left,res[0]-1);
            quickSort(nums,res[1]+1,right);
        }
    }
    private void swap(int[] nums,int left,int right){
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
    private int[] partition(int[] nums,int left,int right){
        int less = left-1; //小于区域
        int more = right;  //大于区域
        while(left&amp;lt;more){
            if(nums[left]&amp;lt;nums[right]){
                swap(nums,++less,left++);
            }else if(nums[left]&amp;gt;nums[right]){
                swap(nums,--more,left);
            }else{
                left++;
            }
        }
        swap(nums,more,right);
        return new int[]{less+1,more};//返回相等区域
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度:O(N)&lt;/li&gt;
&lt;li&gt;空间复杂度:O(log⁡n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;快排复杂度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间：O(nlogn),最坏的时间复杂度为 O(n2)&lt;/li&gt;
&lt;li&gt;空间：O(n), 空间复杂度与递归的层数有关，每层递归会生成一些临时变量，所以空间复杂度为 O(logn) ~ O(n)，平均空间复杂度为 O(logn)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;堆排序-heapsort&#34;&gt;堆排序 Heapsort&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public void heapSort(int[] nums){
        if(nums==null||nums.length&amp;lt;2){
            return;
        }
        for(int i=0;i&amp;lt;nums.length;i++){
            heapInsert(nums,i);
        }
        int heapSize = nums.length;
        swap(nums,0,--heapSize);
        while(heapSize&amp;gt;0){
            heapify(nums,0,heapSize);
            swap(nums,0,--heapSize);
        }
    }
    //某个数处在index，往上继续移动
    private void heapInsert(int[] nums,int index){
        while(nums[(index-1)/2]&amp;lt;nums[index]){
            swap(nums,(index-1)/2,index);
            index = (index-1)/2;
        }
    }
    private void swap(int[] nums,int left,int right){
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
  	//和左、右节点比较，小于则往下换
    private void heapify(int[] nums,int index,int heapSize){
        int left = index*2+1;//从上往下移动,左孩子下标
        while(left&amp;lt;heapSize){
            int largest=left+1&amp;lt;heapSize&amp;amp;&amp;amp;nums[left+1]&amp;gt;nums[left]?left+1:left;
            largest=nums[largest]&amp;gt;nums[index]?largest:index;
            if(largest==index){
                break;
            }
            swap(nums,largest,index);
            index = largest;
            left=index*2+1;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间：O(nlogn),初始化建堆为O(n),重建堆为O(nlogn).&lt;/li&gt;
&lt;li&gt;空间：O(1)，只用了常数级的临时变量.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;三数之和&#34;&gt;三数之和&lt;/h4&gt;
&lt;p&gt;给你一个包含 &lt;code&gt;n&lt;/code&gt; 个整数的数组 &lt;code&gt;nums&lt;/code&gt;，判断 &lt;code&gt;nums&lt;/code&gt; 中是否存在三个元素 *a，b，c ，*使得 &lt;em&gt;a + b + c =&lt;/em&gt; 0&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; threeSum(int[] nums) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        Arrays.sort(nums);
        for (int i = 0; i &amp;lt; nums.length; i++) {
            if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i-1])
            continue;
            int left = i + 1;
            int right = nums.length - 1;
            while (left &amp;lt; right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum &amp;lt; 0) {
                    left++;
                } else if (sum &amp;gt; 0) {
                    right--;
                } else {
                res.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    while (left &amp;lt; right &amp;amp;&amp;amp; nums[left] == nums[left+1])
                    left++;
                    while (left&amp;lt;right &amp;amp;&amp;amp; nums[right]==nums[right-1])
                    right--;
                    left++;
                    right--;
                }
            }
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n2)，数组排序 O(NlogN)，遍历数组 O(n)，双指针遍历 O(n)，总体 O(Nlog N)+O(n)∗O(n)，O(n2)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;搜索旋转排序数组&#34;&gt;搜索旋转排序数组&lt;/h4&gt;
&lt;p&gt;有一个长度为 n 的按严格升序排列的整数数组 nums ，在实行 search 函数之前，在某个下标 k 上进行旋转，使数组变为[nums[k],nums[k+1],.....,nums[nums.length-1],nums[0],nums[1],.......,nums[k-1]]。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length-1;
        if (nums.length==0)
            return -1;
        while (left &amp;lt;= right) {
            int mid = left+(right-left)/2;
            if (nums[mid] == target)
                return mid;
            if (nums[left] &amp;lt;= nums[mid]) {//[left,mid]是有序
                if (nums[left]&amp;lt;=target &amp;amp;&amp;amp; target&amp;lt;nums[mid]) {
                    right = mid -1;
                } else {
                    left = mid +1;
                }
            } else {//[mid,right]是有序
                if (nums[mid]&amp;lt;target &amp;amp;&amp;amp; target&amp;lt;=nums[right]) {
                    left = mid +1;
                } else {
                    right = mid -1;
                }
            }
        }
        return -1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。&lt;br&gt;
此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度： O(logn)，其中 n 为nums 数组的大小。整个算法时间复杂度即为二分查找的时间复杂度 O(logn)。&lt;/li&gt;
&lt;li&gt;空间复杂度： O(1) 。我们只需要常数级别的空间存放变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;买卖股票的最佳时机&#34;&gt;买卖股票的最佳时机&lt;/h4&gt;
&lt;p&gt;给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择某一天买入这只股票,并选择在未来的某一个不同的日子卖出该股票。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int maxProfit(int[] prices) {
        int low = Integer.MAX_VALUE;
        int res = 0;
        for (int i = 0; i &amp;lt; prices.length; i++) {
            low = Math.min(low,prices[i]);
            res = Math.max(res,prices[i]-low);
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)，只需要遍历一次。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)，只使用了常数个变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;合并k个升序链表&#34;&gt;合并K个升序链表&lt;/h4&gt;
&lt;p&gt;给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;维护当前每个链表没有被合并的元素的最前面一个，k 个链表就最多有 k 个满足这样条件的元素，每次在这些元素里面选取 val 属性最小的元素合并到答案中&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    class Status implements Comparable&amp;lt;Status&amp;gt;{
    int val;
    ListNode node;
    public Status(){}
    public Status(int val, ListNode node) {
        this.val = val;
        this.node = node;
    }
    public int compareTo(Status status) {
        return this.val-status.val;
    }
}
PriorityQueue&amp;lt;Status&amp;gt; queue = new PriorityQueue&amp;lt;&amp;gt;();
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode dummy = new ListNode(0);
        ListNode tail = dummy;
        for (ListNode node:lists) {
            //把每个链表的头节点放入优先队列
            if (node != null)
            queue.offer(new Status(node.val,node));
        }
        while (!queue.isEmpty()) {
            Status status = queue.poll();
            tail.next = status.node;
            tail = tail.next;
            if (status.node.next != null)
            queue.offer(new Status(status.node.next.val,status.node.next));
        }
        return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：考虑优先队列中的元素不超过 k 个，那么插入和删除的时间代价为 O(logk)，这里最多有 kn 个点，对于每个点都被插入删除各一次，故总的时间代价即渐进时间复杂度为 O(kn×logk)。&lt;/li&gt;
&lt;li&gt;空间复杂度：这里用了优先队列，优先队列中的元素不超过 k 个，故渐进空间复杂度为 O(k)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;合并两个排序的链表&#34;&gt;合并两个排序的链表&lt;/h4&gt;
&lt;p&gt;将两个升序链表合并为一个新的 &lt;strong&gt;升序&lt;/strong&gt; 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode prehead = new ListNode(-1);
        ListNode prev = prehead;
        while (l1 != null &amp;amp;&amp;amp; l2 != null) {
            if (l1.val &amp;lt;= l2.val) {
                prev.next = l1;
                l1 = l1.next;
            } else {
                prev.next = l2;
                l2 = l2.next;
            }
            prev = prev.next;
        }

        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
        prev.next = l1 == null ? l2 : l1;

        return prehead.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n+m)，其中n和m分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。我们只需要常数的空间存放若干变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;接雨水&#34;&gt;接雨水&lt;/h4&gt;
&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; 个非负整数表示每个宽度为 &lt;code&gt;1&lt;/code&gt; 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int trap(int[] height) {
        int left = 0;//从左往右处理的当前下标
        int right = height.length - 1;//从右往左处理的当前下标
        int left_max = 0;//左边的最大值，从左往右遍历找到的
        int right_max = 0;//右边的最大值，从右往左遍历找到的
        int res = 0;
        while (left &amp;lt;= right) {
            if (left_max &amp;lt; right_max) {
                res += Math.max(0,left_max-height[left]);
                left_max = Math.max(left_max,height[left]);
                left++;
            } else {
                res += Math.max(0,right_max-height[right]);
                right_max = Math.max(right_max,height[right]);
                right--;
            }
        }
        return res;
    }
}
//在某个位置i处，它能存的水，取决于它左右两边的最大值中较小的一个。
//从左往右处理到left下标时，左边的最大值left_max对它而言是可信的，但right_max对它而言是不可信的。
//从右往左处理到right下标时，右边的最大值right_max对它而言是可信的，但left_max对它而言是不可信的。
//对于位置left而言，它左边最大值一定是left_max，右边最大值“大于等于”right_max，这时候，如果left_max&amp;lt;right_max成立，那么它就知道自己能存多少水了。无论右边将来会不会出现更大的right_max，都不影响这个结果。 所以当left_max&amp;lt;right_max时，我们就希望去处理left下标，反之，我们希望去处理right下标。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;时间复杂度：O(n)。单次遍历的时间O(n)。&lt;br&gt;
空间复杂度：O(1) 的额外空间。left,right,leftmax,rightmax 只需要常数的空间。&lt;/p&gt;
&lt;h4 id=&#34;二叉树的最近公共祖先&#34;&gt;二叉树的最近公共祖先&lt;/h4&gt;
&lt;p&gt;给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {

    private TreeNode ans = null;

    private boolean dfs(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return false;
        boolean lson = dfs(root.left, p, q);
      	//判断该节点左孩子是否包含p或者q
        boolean rson = dfs(root.right, p, q);
        if ((lson &amp;amp;&amp;amp; rson) || ((root.val == p.val || root.val == q.val) &amp;amp;&amp;amp; (lson || rson))) {
          //root左子树和右子树均包含p节点或q节点
          //root恰好是p节点或q节点且它的左子树或右子树有一个包含了另一个节点
            ans = root;
        } 
        return lson || rson || (root.val == p.val || root.val == q.val);
    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        dfs(root, p, q);
        return this.ans;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(N)，其中N 是二叉树的节点数。二叉树的所有节点有且只会被访问一次，因此时间复杂度为 O(N)。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(N) ，其中N 是二叉树的节点数。递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 NN，因此空间复杂度为 O(N)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;相交链表&#34;&gt;相交链表&lt;/h4&gt;
&lt;p&gt;给你两个单链表的头节点 &lt;code&gt;headA&lt;/code&gt; 和 &lt;code&gt;headB&lt;/code&gt; ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 &lt;code&gt;null&lt;/code&gt; 。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA;
        ListNode curB = headB;
        int lA = 0;
        int lB = 0;
        while (curA != null) {
            curA = curA.next;
            lA++;
        }
        while (curB != null) {
            curB = curB.next;
            lB++;
        }
        curA = headA;
        curB = headB;
        if (lA &amp;gt; lB) {
            int gap = lA -lB;
            while (gap-- &amp;gt; 0) {
                curA = curA.next;
            }
        } else {
            int gap = lB - lA;
            while (gap-- &amp;gt; 0) {
                curB = curB.next;
            }
        }
        while (curA != null &amp;amp;&amp;amp; curB != null) {
            if(curA == curB)
            return curA;
            curA = curA.next;
            curB = curB.next;
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(m+n)，其中 m 和n是分别是链表 headA 和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;螺旋矩阵&#34;&gt;螺旋矩阵&lt;/h4&gt;
&lt;p&gt;给你一个 &lt;code&gt;m&lt;/code&gt; 行 &lt;code&gt;n&lt;/code&gt; 列的矩阵 &lt;code&gt;matrix&lt;/code&gt; ，请按照 &lt;strong&gt;顺时针螺旋顺序&lt;/strong&gt; ，返回矩阵中的所有元素。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {//转圈遍历。左右下上
    public List&amp;lt;Integer&amp;gt; spiralOrder(int[][] matrix) {
       List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
       int left = 0;
       int right = matrix[0].length-1;
       int top = 0;
       int bottom = matrix.length-1;
       //一共要打印的个数
       int total = matrix.length * matrix[0].length;
       while (total &amp;gt;= 1) {
           for (int i = left;i &amp;lt;= right &amp;amp;&amp;amp; total&amp;gt;=1; i++) {
           //从左往右，遍历完一行相当于top少一行，所以top++
               res.add(matrix[top][i]);
               total--;
           }
           top++;
           for (int i = top; i &amp;lt;= bottom &amp;amp;&amp;amp; total&amp;gt;=1; i++) {
               res.add(matrix[i][right]);
               total--;
           }
           right--;
           for (int i = right; i &amp;gt;= left &amp;amp;&amp;amp; total &amp;gt;=1;i--) {
               res.add(matrix[bottom][i]);
               total--;
           }
           bottom--;
           for (int i = bottom; i &amp;gt;= top &amp;amp;&amp;amp; total&amp;gt;=1;i--) {
               res.add(matrix[i][left]);
               total--;
           }
           left++;
       }
       return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(mn)，其中m和n分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。除了输出数组以外，空间复杂度是常数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;重排链表&#34;&gt;重排链表&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public void reorderList(ListNode head) {
        if (head == null) {
            return;
        }
        //1.找到中点
        ListNode mid = findMid(head);
        ListNode L1 = head;
        ListNode L2 = mid.next;
        mid.next = null;//断开两个链表
        //2.反转中点后的链表
        L2 = reverse(L2);
        //3.合并反转后的链表和中点前的链表
        merge(L1,L2);
    }
    private ListNode findMid (ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast.next != null &amp;amp;&amp;amp; fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
    private ListNode reverse (ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
    private void merge (ListNode L1, ListNode L2) {
        ListNode L1Temp = null;
        ListNode L2Temp = null;
        while (L1 != null &amp;amp;&amp;amp; L2 != null) {
            L1Temp = L1.next;
            L2Temp = L2.next;
            L1.next = L2;
            L2.next = L1Temp;
            L1 = L1Temp;
            L2 = L2Temp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(N)，其中 N 是链表中的节点数。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;二叉树的右视图&#34;&gt;二叉树的右视图&lt;/h4&gt;
&lt;p&gt;给定一个二叉树的 &lt;strong&gt;根节点&lt;/strong&gt; &lt;code&gt;root&lt;/code&gt;，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public List&amp;lt;Integer&amp;gt; rightSideView(TreeNode root) {
        List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if (root == null)
            return res;
        Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int n = queue.size();
            while (n-- &amp;gt; 0) {
                TreeNode node = queue.poll();
              //层次遍历，右试图是每层的最后一位
                if (n == 0) {
                  //为0则是每一层最后一个节点
                    res.add(node.val);
                }
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度 : O(n)。 每个节点最多进队列一次，出队列一次，因此广度优先搜索的复杂度为线性。&lt;/li&gt;
&lt;li&gt;空间复杂度 : O(n)。每个节点最多进队列一次，所以队列长度最大不不超过 n，所以这里的空间代价为O(n)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;岛屿数量&#34;&gt;岛屿数量&lt;/h4&gt;
&lt;p&gt;给你一个由 &lt;code&gt;&#39;1&#39;&lt;/code&gt;（陆地）和 &lt;code&gt;&#39;0&#39;&lt;/code&gt;（水）组成的的二维网格，请你计算网格中岛屿的数量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int numIslands(char[][] grid) {
        int res = 0;//岛屿沉没
        for (int i = 0; i &amp;lt; grid.length; i++) {
            for (int j = 0; j &amp;lt;grid[0].length;j++) {
                if (grid[i][j] == &#39;1&#39;) {
                    dfs(grid,i,j);
                    res++;
                } 
            }
        }
        return res;
    }
    private void dfs (char[][] grid,int i,int j) {
        if (i &amp;gt;= grid.length ||i &amp;lt; 0||j &amp;lt;0||j &amp;gt;=grid[0].length) {
            return;
        }
        if (grid[i][j] == &#39;0&#39;) {
            return;
        }
        grid[i][j] = &#39;0&#39;;
        dfs(grid,i+1,j);
        dfs(grid,i-1,j);
        dfs(grid,i,j+1);
        dfs(grid,i,j-1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(MN)，其中M和N分别为行数和列数。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(MN)，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 MN。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;
        for(int i = 0; i &amp;lt; grid.length; i++) {
            for(int j = 0; j &amp;lt; grid[0].length; j++) {
                if(grid[i][j] == &#39;1&#39;){
                  //若是则置零（删除岛屿节点），并将此节点上下左右节点加入队列
                    bfs(grid, i, j);
                    count++;
                }
            }
        }
        return count;
    }
    private void bfs(char[][] grid, int i, int j){
        Queue&amp;lt;int[]&amp;gt; list = new LinkedList&amp;lt;&amp;gt;();
        list.add(new int[] { i, j });
        while(!list.isEmpty()){
            int[] cur = list.remove();
            i = cur[0]; j = cur[1];
            if(0 &amp;lt;= i &amp;amp;&amp;amp; i &amp;lt; grid.length &amp;amp;&amp;amp; 0 &amp;lt;= j &amp;amp;&amp;amp; j &amp;lt; grid[0].length &amp;amp;&amp;amp; grid[i][j] == &#39;1&#39;) {
                grid[i][j] = &#39;0&#39;;
                list.add(new int[] { i + 1, j });
                list.add(new int[] { i - 1, j });
                list.add(new int[] { i, j + 1 });
                list.add(new int[] { i, j - 1 });
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;时间复杂度：O(MN)，其中M 和N 分别为行数和列数。&lt;/p&gt;
&lt;p&gt;空间复杂度：O(min(M,N))，在最坏情况下，整个网格均为陆地，队列的大小可以达到 min(M,N)。&lt;/p&gt;
&lt;h4 id=&#34;下一个排列&#34;&gt;下一个排列&lt;/h4&gt;
&lt;p&gt;例如，&lt;code&gt;arr = [1,2,3]&lt;/code&gt; 的下一个排列是 &lt;code&gt;[1,3,2]&lt;/code&gt; 。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
      //找到一个不是降序的较小数
        while (i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[i + 1]) {
            i--;
        }
      //在[i+1,n)中从后往前找到第一个大于较小数的较大数
        if (i &amp;gt;= 0) {
            int j = nums.length - 1;
            while (j &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[j]) {
                j--;
            }
            swap(nums, i, j);
        }
      //将区间[i+1,n)变为升序，找到一个尽可能小的排列
        reverse(nums, i + 1);
    }

    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    public void reverse(int[] nums, int start) {
        int left = start, right = nums.length - 1;
        while (left &amp;lt; right) {
            swap(nums, left, right);
            left++;
            right--;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(N)，其中N为给定序列的长度。我们至多只需要扫描两次序列，以及进行一次反转操作。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)，只需要常数的空间存放若干变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;最长递增子序列-最长上升子序列&#34;&gt;最长递增子序列 最长上升子序列&lt;/h4&gt;
&lt;p&gt;给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
      //dp[i] 为考虑前i个元素，以第i个数字结尾的最长上升子序列的长度
      //dp[i]=max(dp[j])+1,其中0≤j&amp;lt;i且num[j]&amp;lt;num[i]
        dp[0] = 1;
        int res = 1;
        for (int i = 1; i &amp;lt; nums.length;i++) {
            dp[i] = 1;
            for (int j = 0; j &amp;lt; i;j++) {
                if (nums[j] &amp;lt; nums[i]) {
                    dp[i] = Math.max(dp[j] + 1,dp[i]);
                }
            }
            res = Math.max(res,dp[i]);
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n2 )，其中 n 为数组nums 的长度。动态规划的状态数为n，计算状态dp[i] 时，需要 O(n) 的时间遍历 dp[0…i−1] 的所有状态.&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)，需要额外使用长度为 n的 dp数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;贪心二分查找-返回序列&#34;&gt;贪心+二分查找 返回序列&lt;/h5&gt;
&lt;p&gt;要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int lengthOfLIS(int[] nums) {
      //len 记录目前最长上升子序列的长度
        int len = 1, n = nums.length;
        if (n == 0) {
            return 0;
        }
      //长度为i的最长上升子序列的末尾元素的最小值，d[i]单调递增
        int[] d = new int[n + 1];
      //d[1]=nums[0],长度为1的
        d[len] = nums[0];
        for (int i = 1; i &amp;lt; n; ++i) {
            if (nums[i] &amp;gt; d[len]) {
                d[++len] = nums[i];
            } else {
//在d[1…len]中找满足d[i−1]&amp;lt;nums[j]&amp;lt;d[i]的下标i，并更新d[i]=nums[j]。
                int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0
                while (l &amp;lt;= r) {
                    int mid = (l + r) &amp;gt;&amp;gt; 1;
                    if (d[mid] &amp;lt; nums[i]) {
                        pos = mid;
                        l = mid + 1;
                    } else {
                        r = mid - 1;
                    }
                }
                d[pos + 1] = nums[i];
            }
        }
        return len;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//变形，返回序列
class Solution {
    public int[] lengthOfLIS(int[] nums) {
      //len 记录目前最长上升子序列的长度
        int len = 1, n = nums.length;
        if (n == 0) {
            return new int[0];
        }
      //长度为i的最长上升子序列的末尾元素的最小值，d[i]单调递增
        int[] d = new int[n + 1];
        int[] w=new int[n];//辅助数组，存储答案对应的数组索引
      	w[0] = len;
      //d[1]=nums[0],长度为1的
        d[len] = nums[0];
        for (int i = 1; i &amp;lt; n; ++i) {
            if (nums[i] &amp;gt; d[len]) {
                d[++len] = nums[i];
              	w[i]=len;
            } else {
//在d[1…len]中找满足d[i−1]&amp;lt;nums[j]&amp;lt;d[i]的下标i，并更新d[i]=nums[j]。
                int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0
                while (l &amp;lt;= r) {
                    int mid = (l + r) &amp;gt;&amp;gt; 1;
                    if (d[mid] &amp;lt; nums[i]) {
                        pos = mid;
                        l = mid + 1;
                    } else {
                        r = mid - 1;
                    }
                }
                d[pos + 1] = nums[i];
              	w[i]=pos+1;
            }
        }
        int[] res=new int[len];
        for(int i=n-1,j=len;j&amp;gt;0;--i){
            if(w[i]==j){
                res[--j]=nums[i];
            }
        }
      return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn)。数组nums 的长度为n，依次用数组中的元素去更新d 数组，而更新d 数组时需要进行O(logn) 的二分搜索&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)，需要额外使用长度为n的d数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;缺失的第一个正数&#34;&gt;缺失的第一个正数&lt;/h4&gt;
&lt;p&gt;给你一个未排序的整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出其中没有出现的最小的正整数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        int res = 0;
        //把所有负数设为n+1，和[1,n]区分开
        for (int i = 0; i &amp;lt; n; i++) {
            if (nums[i] &amp;lt;= 0) {
                nums[i] = n + 1;
            }
        }
      //将存在的整数i用复数打标记
        for (int i = 0; i &amp;lt; n; i++) {
            int cur = Math.abs(nums[i]);
            if (cur &amp;lt;= n) {
                nums[cur-1] = -Math.abs(nums[cur-1]);
            }
        }
      //找到第一个没被负数标记的索引，i+1则是最小正整数
        for (int i = 0; i &amp;lt; n; i++) {
            if (nums[i] &amp;gt; 0)
                return i + 1;
        }
        return n+1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(N)，其中 N是数组的长度。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;懂车帝&#34;&gt;懂车帝&lt;/h2&gt;
&lt;h4 id=&#34;三数之和-2&#34;&gt;三数之和&lt;/h4&gt;
&lt;p&gt;给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; threeSum(int[] nums) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        Arrays.sort(nums);
        for (int i = 0; i &amp;lt; nums.length-1;i++) {
            if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i]==nums[i-1]) {
                continue;
            }
            int left = i+1;
            int right = nums.length-1;
            while (left &amp;lt; right) {
                int sum = nums[i]+nums[left]+nums[right];
                if (sum &amp;gt; 0) {
                    right--;
                } else if (sum &amp;lt; 0) {
                    left++;
                } else {
                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    while (left &amp;lt; right&amp;amp;&amp;amp;nums[left]==nums[left+1])
                        left++;
                    while (left&amp;lt;right&amp;amp;&amp;amp;nums[right]==nums[right-1])
                        right--;
                    left++;
                    right--;
                }
            }
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(N2 )，其中 N是数组 nums 的长度。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为O(N)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;合并区间&#34;&gt;合并区间&lt;/h4&gt;
&lt;p&gt;以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length==0) {
            return new int[0][2];
        }
        //将列表中的区间按照左端点升序排序
        Arrays.sort(intervals,new Comparator&amp;lt;int[]&amp;gt;(){
            public int compare(int[] interval1,int[] interval2){
                return interval1[0]-interval2[0];
            }
        });
        List&amp;lt;int[]&amp;gt; record = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0;i&amp;lt;intervals.length;i++) {
            int L = intervals[i][0];
            int R = intervals[i][1];
            //如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾
            if(record.size()==0||record.get(record.size()-1)[1]&amp;lt;L){
                record.add(new int[]{L,R});
            } else {
                //否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。
                record.get(record.size()-1)[1] = Math.max(record.get(record.size()-1)[1],R);
            }
        }
        return record.toArray(new int[record.size()][]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn)，其中n为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的 O(nlogn)。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(logn)，其中 nn 为区间的数量。这里计算的是存储答案之外，使用的额外空间。O(logn) 即为排序所需要的空间复杂度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;括号生成&#34;&gt;括号生成&lt;/h4&gt;
&lt;p&gt;数字 &lt;code&gt;n&lt;/code&gt; 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 &lt;strong&gt;有效的&lt;/strong&gt; 括号组合。回溯法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public List&amp;lt;String&amp;gt; generateParenthesis(int n) {
        List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        StringBuilder sb = new StringBuilder();
        backTracking(res,sb,n,0,0);
        return res;
    }
    private void backTracking(List&amp;lt;String&amp;gt; res,StringBuilder sb,int n,int open,int close) {
        if(sb.length()==2*n) {
            res.add(sb.toString());
            return;
        }
      //如果左括号数量不大于 nn，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。
        if(open&amp;lt;n){
            sb.append(&#39;(&#39;);
            backTracking(res,sb,n,open+1,close);
            sb.deleteCharAt(sb.length()-1);
        }
        if(open&amp;gt;close) {
            sb.append(&#39;)&#39;);
            backTracking(res,sb,n,open,close+1);
            sb.deleteCharAt(sb.length()-1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：在回溯过程中，每个答案需要 O(n) 的时间复制到答案数组中。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)，除了答案数组之外，我们所需要的空间取决于递归栈的深度，每一层递归函数需要 O(1)的空间，最多递归 2n 层，因此空间复杂度为 O(n)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;最大子数组和&#34;&gt;最大子数组和&lt;/h4&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0;
        int max = nums[0];
        for (int n:nums) {
            pre = Math.max(pre+n,n);
            max = Math.max(max,pre);
        }
        return max;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)，其中 n为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。我们只需要常数空间存放若干变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;按权重随机选择&#34;&gt;按权重随机选择&lt;/h4&gt;
&lt;p&gt;给你一个 下标从 0 开始 的正整数数组 w ，其中 w[i] 代表第 i 个下标的权重。&lt;/p&gt;
&lt;p&gt;请你实现一个函数 pickIndex ，它可以 随机地 从范围 [0, w.length - 1] 内（含 0 和 w.length - 1）选出并返回一个下标。选取下标 i 的 概率 为 w[i] / sum(w) 。&lt;/p&gt;
&lt;p&gt;设数组 w的权重之和为total。将 [1,total] 范围内的所有整数分成 n个部分（其中 n 是数组 w的长度），第 i 个部分恰好包含w[i] 个整数，并且这n 个部分两两的交集为空.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    int[] pre;
    int total;
    public Solution(int[] w) {
        pre = new int[w.length];
        pre[0] = w[0];
        for (int i = 1; i &amp;lt; w.length; ++i) {
              //每个区间的左边界是在它之前出现的所有元素的和加上 11，右边界是到它为止的所有元素的和。
            pre[i] = pre[i - 1] + w[i];
        }
        total = Arrays.stream(w).sum();
    }
    
    public int pickIndex() {
        int x = (int) (Math.random() * total) + 1;
        return binarySearch(x);
    }
//由于pre[i] 是单调递增的，使用二分查找在O(logn) 的时间内快速找到i，即找出最小的满足 x≤pre[i]的下标i。
    private int binarySearch(int x) {
        int low = 0, high = pre.length - 1;
        while (low &amp;lt; high) {
            int mid = (high - low) / 2 + low;
            if (pre[mid] &amp;lt; x) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：初始化的时间复杂度为 O(n)，每次选择的时间复杂度为 O(logn)，其中 n 是数组 w的长度。&lt;/li&gt;
&lt;li&gt;空间复杂度:O(n)，即为前缀和数组pre 需要使用的空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;最小栈-min函数栈&#34;&gt;最小栈  min函数栈&lt;/h4&gt;
&lt;p&gt;设计一个支持 &lt;code&gt;push&lt;/code&gt; ，&lt;code&gt;pop&lt;/code&gt; ，&lt;code&gt;top&lt;/code&gt; 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class MinStack {
    Stack&amp;lt;Integer&amp;gt; stack;
    Stack&amp;lt;Integer&amp;gt; minStack;
  //使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。
    public MinStack() {
        stack = new Stack&amp;lt;&amp;gt;();
        minStack = new Stack&amp;lt;&amp;gt;();
        minStack.push(Integer.MAX_VALUE);
    }
    public void push(int val) { 
            minStack.push(Math.min(minStack.peek(),val));
      //当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；
            stack.push(val);   
    }
    public void pop() {
        minStack.pop();
        stack.pop();
    }
    public int top() {
        return stack.peek();
    }
    public int getMin() {
        return minStack.peek();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是 O(1)，我们定义的每个操作最多调用栈操作两次。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)，其中n为总操作数。最坏情况下，我们会连续插入n 个元素，此时两个栈占用的空间为 O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;环形链表&#34;&gt;环形链表&lt;/h4&gt;
&lt;p&gt;给你一个链表的头节点 &lt;code&gt;head&lt;/code&gt; ，判断链表中是否有环。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        if(head== null)
            return false;
        while (fast.next!=null&amp;amp;&amp;amp;fast.next.next!=null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow)
                return true;
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(N)，其中 N是链表中的节点数。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。我们只使用了两个指针的额外空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;随机数索引&#34;&gt;随机数索引&lt;/h4&gt;
&lt;p&gt;给你一个可能含有 &lt;strong&gt;重复元素&lt;/strong&gt; 的整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你随机输出给定的目标数字 &lt;code&gt;target&lt;/code&gt; 的索引。你可以假设给定的数字一定存在于数组中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    int[] nums;
    Random random;

    public Solution(int[] nums) {
        this.nums = nums;
        random = new Random();
    }
//遍历nums，第i次遇到值为target的元素时，随机选择区间[0,i)内的一个整数，如果其等于 0，则将返回值置为该元素的下标，否则返回值不变。
    public int pick(int target) {
        int ans = 0;
        for (int i = 0, cnt = 0; i &amp;lt; nums.length; ++i) {
            if (nums[i] == target) {
                ++cnt; // 第 cnt 次遇到 target
                if (random.nextInt(cnt) == 0) {
                    ans = i;
                }
            }
        }
        return ans;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时间复杂度：初始化为O(1)，pick 为O(n)，其中n是nums 的长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间复杂度：O(1)。我们只需要常数的空间保存若干变量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;寻找两个正序数组的中位数&#34;&gt;寻找两个正序数组的中位数&lt;/h4&gt;
&lt;p&gt;给定两个大小分别为 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 的正序（从小到大）数组 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt;。请你找出并返回这两个正序数组的 &lt;strong&gt;中位数&lt;/strong&gt; 。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int length1 = nums1.length, length2 = nums2.length;
        int totalLength = length1 + length2;
        if (totalLength % 2 == 1) {
            int midIndex = totalLength / 2;
            double median = getKthElement(nums1, nums2, midIndex + 1);
            return median;
        } else {
            int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2;
            double median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
            return median;
        }
    }

    public int getKthElement(int[] nums1, int[] nums2, int k) {
        /* 主要思路：要找到第 k (k&amp;gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较
         * 这里的 &amp;quot;/&amp;quot; 表示整除
         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &amp;lt;= k-2 个
         * 这样 pivot 本身最大也只能是第 k-1 小的元素
         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &amp;quot;删除&amp;quot;，剩下的作为新的 nums1 数组
         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &amp;quot;删除&amp;quot;，剩下的作为新的 nums2 数组
         * 由于我们 &amp;quot;删除&amp;quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
         */

        int length1 = nums1.length, length2 = nums2.length;
        int index1 = 0, index2 = 0;
        int kthElement = 0;

        while (true) {
            // 边界情况
            if (index1 == length1) {
                return nums2[index2 + k - 1];
       //一个数组为空，说明该数组中的所有元素都被排除，返回另一个数组中第 k小的元素。
            }
            if (index2 == length2) {
                return nums1[index1 + k - 1];
            }
            if (k == 1) {
                return Math.min(nums1[index1], nums2[index2]);
            }
            
            // 正常情况
            int half = k / 2;
            int newIndex1 = Math.min(index1 + half, length1) - 1;
            int newIndex2 = Math.min(index2 + half, length2) - 1;
            int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
            if (pivot1 &amp;lt;= pivot2) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            } else {
                k -= (newIndex2 - index2 + 1);
                index2 = newIndex2 + 1;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(log(m+n))，其中 m和n分别是数组 nums 1  和 nums2的长度。初始时有 k=(m+n)/2 或k=(m+n)/2+1，每一轮循环可以将查找范围减少一半，因此时间复杂度是O(log(m+n))。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;和为-k-的子数组&#34;&gt;和为 K 的子数组&lt;/h4&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你统计并返回 &lt;em&gt;该数组中和为 &lt;code&gt;k&lt;/code&gt; 的子数组的个数&lt;/em&gt; 。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int subarraySum(int[] nums, int k) {
  	    //和为键，出现次数为对应的值
        HashMap&amp;lt;Integer,Integer&amp;gt; record = new HashMap&amp;lt;&amp;gt;();
        int count = 0;
        int pre = 0;
        record.put(0,1);//pre==k时，不会被漏算
        for (int i=0;i&amp;lt;nums.length;i++) {
            pre += nums[i];
            if (record.containsKey(pre-k)) 
            //pre[j−1]==pre[i]−k
                count += record.get(pre-k);
            }
            record.put(pre,record.getOrDefault(pre,0)+1);
        }
        return count;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)，其中n为数组的长度。我们遍历数组的时间复杂度为 O(n)，中间利用哈希表查询删除的复杂度均为 O(1)，因此总时间复杂度为 O(n)。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)，其中n 为数组的长度。哈希表在最坏情况下可能有 n个不同的键值，因此需要O(n) 的空间复杂度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;翻转二叉树&#34;&gt;翻转二叉树&lt;/h4&gt;
&lt;p&gt;给你一棵二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，翻转这棵二叉树，并返回其根节点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {//递归
    public TreeNode invertTree(TreeNode root) {
        if(root == null) {
            return root;
        }
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(N)，其中N为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(N)。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即 O(logN)。而在最坏情况下，树形成链状，空间复杂度为 O(N)。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public TreeNode invertTree(TreeNode root) {
        Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
        if(root == null)
            return root;
        queue.offer(root);
        while (!queue.isEmpty()) {
            int n = queue.size();
            while(n-- &amp;gt; 0) {
                TreeNode node = queue.poll();
                TreeNode temp = node.left;
                node.left = node.right;
                node.right = temp;
                if(node.left!=null) 
                    queue.offer(node.left);
                if(node.right!=null)
                    queue.offer(node.right);
            }
        }
        return root;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：同样每个节点都需要入队列/出队列一次，所以是 O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：最坏的情况下会包含所有的叶子节点，完全二叉树叶子节点是 n/2个，所以时间复杂度是 O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;四数之和&#34;&gt;四数之和&lt;/h4&gt;
&lt;p&gt;给你一个由 &lt;code&gt;n&lt;/code&gt; 个整数组成的数组 &lt;code&gt;nums&lt;/code&gt; ，和一个目标值 &lt;code&gt;target&lt;/code&gt; 。请你找出并返回满足条件且&lt;strong&gt;不重复&lt;/strong&gt;的四元组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; fourSum(int[] nums, int target) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        Arrays.sort(nums);
        for (int i = 0; i &amp;lt; nums.length - 2;i++) {
            if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i-1])
            continue;
            for (int j = i +1; j &amp;lt; nums.length-1; j++) {
                if (j &amp;gt; i + 1 &amp;amp;&amp;amp; nums[j] == nums[j-1])
                continue;
                int left = j + 1; 
                int right = nums.length - 1;
                while (left &amp;lt; right) {
                    int sum = nums[i] + nums[j] +nums[left] + nums[right];
                    if (sum &amp;gt; target) {
                        right--;
                    } else if (sum &amp;lt; target) {
                        left++;
                    } else {
                        res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));
                        while (left &amp;lt; right &amp;amp;&amp;amp; nums[left]==nums[left+1]) {
                            left++;
                        }
                        while (left &amp;lt; right &amp;amp;&amp;amp; nums[right] == nums[right-1]) {
                            right--;
                        }
                        left++;
                        right--;
                    }
                }
            }
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n3)，其中n是数组的长度。排序的时间复杂度是O(nlogn)，枚举四元组的时间复杂度是 O(n3)，因此总时间复杂度为O(n3+nlogn)=O(n3 )。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(logn)，其中n是数组的长度。空间复杂度主要取决于排序额外使用的空间。此外排序修改了输入数组nums，实际情况中不一定允许，因此也可以看成使用了一个额外的数组存储了数组nums 的副本并排序，空间复杂度为O(n)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;删除链表的倒数第-n-个结点&#34;&gt;删除链表的倒数第 N 个结点&lt;/h4&gt;
&lt;p&gt;给你一个链表，删除链表的倒数第 &lt;code&gt;n&lt;/code&gt; 个结点，并且返回链表的头结点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0,head);
        ListNode slow = dummy;
        ListNode fast = dummy;
        while(n-- &amp;gt; 0) {
            fast = fast.next;
        }
        while(fast.next!=null) {
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(L)，其中 L 是链表的长度。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;牛客&#34;&gt;牛客&lt;/h2&gt;
&lt;h4 id=&#34;两数之和&#34;&gt;两数之和&lt;/h4&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出 &lt;strong&gt;和为目标值&lt;/strong&gt; &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; 的那 &lt;strong&gt;两个&lt;/strong&gt; 整数，并返回它们的数组下标。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&amp;lt;Integer, Integer&amp;gt; hashtable = new HashMap&amp;lt;Integer, Integer&amp;gt;();
        for (int i = 0; i &amp;lt; nums.length; ++i) {
            if (hashtable.containsKey(target - nums[i])) {
                return new int[]{hashtable.get(target - nums[i]), i};
            }
            hashtable.put(nums[i], i);
        }
        return new int[0];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度: O(N)，其中N是数组中的元素数量。对于每一个元素 x，我们可以O(1) 地寻找 target - x。&lt;/li&gt;
&lt;li&gt;空间复杂度:O(N)，其中N是数组中的元素数量。主要为哈希表的开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;用栈实现队列&#34;&gt;用栈实现队列&lt;/h4&gt;
&lt;p&gt;存储n个元素的空间复杂度为O(n) ，插入与删除的时间复杂度都是 O(1)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class MyQueue {
    Stack&amp;lt;Integer&amp;gt; s1;
    Stack&amp;lt;Integer&amp;gt; s2;
    public MyQueue() {
        s1 = new Stack&amp;lt;&amp;gt;();
        s2 = new Stack&amp;lt;&amp;gt;();
    }
    
    public void push(int x) {
      //时间O(1),空间O(n)
        s1.push(x);
    }
    
    public int pop() {
      //时间O(1),空间O(n)
        if (!s2.isEmpty()) {
            return s2.pop();
        } else {
            while (!s1.isEmpty()) {
                s2.push(s1.pop());
            }
            return s2.pop();
        }
    }
    
    public int peek() {
        if (!s2.isEmpty()) {
            return s2.peek();
        } else {
            while (!s1.isEmpty()) {
                s2.push(s1.pop());
            }
            return s2.peek();
        }
    }
    
    public boolean empty() {
        return s1.isEmpty() &amp;amp;&amp;amp; s2.isEmpty();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;青蛙跳台阶&#34;&gt;青蛙跳台阶&lt;/h4&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 &lt;code&gt;n&lt;/code&gt; 级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int numWays(int n) {
        int a = 1, b = 1, sum;
        for(int i = 0; i &amp;lt; n; i++){
          //随着n增大, f(n)会超Int32甚至Int64 的取值范围，导致最终的返回值错误,此操作与最终返回前取余等价。
            sum = (a + b) % 1000000007;
            a = b;
            b = sum;
        }
        return a;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度O(N) ： 计算 f(n)需循环n次，每轮循环内计算操作使用 O(1) 。&lt;/li&gt;
&lt;li&gt;空间复杂度 O(1)： 几个标志变量使用常数大小的额外空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;最长无重复子数组&#34;&gt;最长无重复子数组&lt;/h4&gt;
&lt;p&gt;给定一个长度为n的数组arr，返回arr的最长无重复元素子数组的长度，无重复指的是所有数字都不相同。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public int maxLength (int[] arr) {
        Set&amp;lt;Integer&amp;gt; record = new HashSet&amp;lt;&amp;gt;();
      // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        int right = -1, res = 0;
        for (int left = 0; left &amp;lt; arr.length;left++) {
            if(left!=0) {
              // 左指针向右移动一格，移除一个字符
                record.remove(arr[left-1]);
            }
            while(right+1&amp;lt;arr.length&amp;amp;&amp;amp; !record.contains(arr[right+1])) {
              // 不断地移动右指针
                record.add(arr[right+1]);
                right++;
            }
            res = Math.max(res,right-left+1);
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(N)，其中N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(∣Σ∣)，其中Σ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;合并两个有序的数组&#34;&gt;合并两个有序的数组&lt;/h4&gt;
&lt;p&gt;给出一个有序的整数数组 A 和有序的整数数组 B ，请将数组 B 合并到数组 A 中，变成一个有序的升序数组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public void merge(int A[], int m, int B[], int n) {
        int p1 = m - 1;
        int p2 = n - 1;
        int tail = m + n -1;
        while (p1 &amp;gt;= 0||p2&amp;gt;=0) {
            int cur = 0;
            if (p1==-1) {
                cur = B[p2--];
            } else if (p2 ==-1) {
                cur=A[p1--];
            } else if (A[p1]&amp;gt;=B[p2]) {
                cur=A[p1--];
            } else if(A[p1]&amp;lt;=B[p2]){
                cur= B[p2--];
            }
            A[tail--] = cur;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(m+n)。指针移动单调递减，最多移动m+n次，因此时间复杂度O(m+n)。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)直接对数组nums 1原地修改，不需要额外空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;链表中环的入口结点&#34;&gt;链表中环的入口结点&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public ListNode EntryNodeOfLoop(ListNode pHead) {
        if (pHead == null)
            return null;
        ListNode slow = pHead;
        ListNode fast = pHead;
        while (fast!=null&amp;amp;&amp;amp;fast.next!=null) {
            slow = slow.next;
            fast = fast.next.next;
            if (fast == slow) {
                ListNode temp = pHead;
              //slow 与fast 相遇时，使指针指向链表头部；它和slow 每次向后移动一个位置。最终，它们会在入环点相遇。
                while (temp != fast) {
                    fast = fast.next;
                    temp = temp.next;
                }
                return temp;
            }
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(N)，其中N为链表中节点的数目。在最初判断快慢指针是否相遇时，slow 指针走过的距离不会超过链表的总长度；随后寻找入环点时，走过的距离也不会超过链表的总长度。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。只使用了slow,fast,ptr 三个指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;有效括号序列&#34;&gt;有效括号序列&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public boolean isValid (String s) {
        if(s.length()%2==1)
            return false;
        HashMap&amp;lt;Character,Character&amp;gt; record = new HashMap&amp;lt;&amp;gt;();
        record.put(&#39;)&#39;,&#39;(&#39;);
        record.put(&#39;]&#39;,&#39;[&#39;);
        record.put(&#39;}&#39;,&#39;{&#39;);
        Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        for (int i =0;i&amp;lt;s.length();i++) {
            char ch = s.charAt(i);
            if(record.containsKey(ch)) {
                if(stack.isEmpty()||stack.pop()!=record.get(ch)) {
                    return false;
                }
            } else {
                stack.push(ch);
            }
        }
        return stack.isEmpty();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)，其中n是字符串s的长度。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n+∣Σ∣)，Σ 表示字符集，本题中字符串只包含 6种括号，∣Σ∣=6。栈中的字符数量为O(n)，而哈希表使用的空间为O(∣Σ∣)，相加即可得到总空间复杂度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;大数加法&#34;&gt;大数加法&lt;/h4&gt;
&lt;p&gt;以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public String solve (String s, String t) {
        int i = s.length()-1;//i和y指向string末尾
        int j = t.length()-1;
        int add = 0;//维护当前是否有进位
        StringBuilder sb = new StringBuilder();
        while (i &amp;gt;= 0||j&amp;gt;=0||add!=0) {
            int x=i&amp;gt;=0?s.charAt(i)-&#39;0&#39;:0;
            int y=j&amp;gt;=0?t.charAt(j)-&#39;0&#39;:0;
            int sum = x+y+add;
            add =sum/10;
            sb.append(sum%10);
            i--;
            j--;
        }
        sb.reverse();
        return sb.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(max(len1 ,len2))，其中 len1=num1.length，len2=num2.length。竖式加法的次数取决于较大数的位数。&lt;/li&gt;
&lt;li&gt;空间复杂度：使用到了 StringBuffer，故 Java 解法的空间复杂度为O(n)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;最长公共子串&#34;&gt;最长公共子串&lt;/h4&gt;
&lt;p&gt;给定两个字符串str1和str2,输出两个字符串的最长公共子串，题目保证str1和str2的最长公共子串存在且唯一。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public String LCS(String str1, String str2) {
    int maxLenth = 0;//记录最长公共子串的长度
    //记录最长公共子串最后一个元素在字符串str1中的位置
    int maxLastIndex = 0;
    int[][] dp = new int[str1.length() + 1][str2.length() + 1];
    for (int i = 0; i &amp;lt; str1.length(); i++) {
        for (int j = 0; j &amp;lt; str2.length(); j++) {
            //递推公式，两个字符相等的情况
            if (str1.charAt(i) == str2.charAt(j)) {
                dp[i + 1][j + 1] = dp[i][j] + 1;
                //如果遇到了更长的子串，要更新，记录最长子串的长度，
                //以及最长子串最后一个元素的位置
                if (dp[i + 1][j + 1] &amp;gt; maxLenth) {
                    maxLenth = dp[i + 1][j+1];
                    maxLastIndex = i;
                }
            } else {
                //递推公式，两个字符不相等,不能构成公共子串
                dp[i + 1][j+1] = 0;
            }
        }
    }
    //最字符串进行截取，substring(a,b)中a和b分别表示截取的开始和结束位置
    return str1.substring(maxLastIndex - maxLenth + 1, maxLastIndex + 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O（mn），m和n分别表示两个字符串的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O（mn）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;链表相加&#34;&gt;链表相加&lt;/h4&gt;
&lt;p&gt;假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。给定两个这种链表，请生成代表两个整数相加值的结果链表&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public ListNode addInList (ListNode head1, ListNode head2) {
      //把所有数字压入栈中，再依次取出相加
        Stack&amp;lt;Integer&amp;gt; s1 = new Stack&amp;lt;&amp;gt;();
        Stack&amp;lt;Integer&amp;gt; s2 = new Stack&amp;lt;&amp;gt;();
        while (head1!=null) {
            s1.push(head1.val);
            head1=head1.next;
        }
        while(head2!=null){
            s2.push(head2.val);
            head2=head2.next;
        }
        int add = 0;
        ListNode res = null;
        while(!s1.isEmpty()||!s2.isEmpty()||add!=0){
            int x=s1.isEmpty()?0:s1.pop();
            int y=s2.isEmpty()?0:s2.pop();
            int sum=x+y+add;
            add = sum/10;
            ListNode node = new ListNode(sum%10);
            node.next=res;
            res = node;
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(max(m,n))，其中m和n分别为两个链表的长度。我们需要遍历两个链表的全部位置，而处理每个位置只需要O(1) 的时间。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(m+n)，其中m和n分别为两个链表的长度。空间复杂度主要取决于我们把链表内容放入栈中所用的空间&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;反转字符串&#34;&gt;反转字符串&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public String solve (String str) {
        char[] s = str.toCharArray();
        int left = 0;
        int right = s.length-1;
        while (left&amp;lt;right) {
            s[left] ^= s[right];
            s[right] ^= s[left];
            s[left] ^= s[right];
            left++;
            right--;
        }
        return new String(s);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;空间复杂度 O(n)&lt;/li&gt;
&lt;li&gt;时间复杂度 O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;斐波那契数列&#34;&gt;斐波那契数列&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int fib(int n) {
        if (n &amp;lt; 2) {
            return n;
        }
        int p = 0, q = 0, r = 1;
        for (int i = 2; i &amp;lt;= n; ++i) {
          //滚动数组思想
            p = q; 
            q = r; 
            r = p + q;
        }
        return r;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;最长回文子串&#34;&gt;最长回文子串&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() &amp;lt; 1) {
            return &amp;quot;&amp;quot;;
        }
      // 初始化最大回文子串的起点和终点
        int start = 0, end = 0;
       // 遍历每个位置，当做中心位
        for (int i = 0; i &amp;lt; s.length(); i++) {
          //从子串长度为1或2的边界情况向两端扩展
            int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i + 1);
            int len = Math.max(len1, len2);
           // 计算对应最大回文子串的起点和终点
            if (len &amp;gt; end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }

    public int expandAroundCenter(String s, int left, int right) {
        while (left &amp;gt;= 0 &amp;amp;&amp;amp; right &amp;lt; s.length() &amp;amp;&amp;amp; s.charAt(left) == s.charAt(right)) {
          //两边字母不同停止，之后的子串都不是回文的
            --left;
            ++right;
        }
        return right - left - 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度:O(n2)，其中n是字符串的长度。长度为1和2的回文中心分别有n和n−1个，每个回文中心最多会向外扩展 O(n)次。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;从前序与中序遍历序列构造二叉树-重建二叉树&#34;&gt;从前序与中序遍历序列构造二叉树 重建二叉树&lt;/h4&gt;
&lt;p&gt;给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
  //键表示一个元素（节点的值），值表示其在中序遍历中的出现位置
    private Map&amp;lt;Integer, Integer&amp;gt; indexMap;
    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        if (preorder_left &amp;gt; preorder_right) {
            return null;
        }
        // 前序遍历中的第一个节点就是根节点
        int preorder_root = preorder_left;
        // 在中序遍历中定位根节点
        int inorder_root = indexMap.get(preorder[preorder_root]);
        // 先把根节点建立出来
        TreeNode root = new TreeNode(preorder[preorder_root]);
        // 得到左子树中的节点数目
        int size_left_subtree = inorder_root - inorder_left;
        // 递归地构造左子树，并连接到根节点
        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
        root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        // 递归地构造右子树，并连接到根节点
        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;
        // 构造哈希映射，帮助我们快速定位根节点
        indexMap = new HashMap&amp;lt;Integer, Integer&amp;gt;();
        for (int i = 0; i &amp;lt; n; i++) {
            indexMap.put(inorder[i], i);
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)，其中n是树中的节点个数。&lt;/li&gt;
&lt;li&gt;空间复杂度:O(n)，除去返回的答案需要的 O(n)空间之外，还需要使用O(n) 的空间存储哈希映射，以及O(h)（其中h是树的高度）的空间表示递归时栈空间。这里h&amp;lt;n，所以总空间复杂度为O(n)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;求平方跟-sqrt&#34;&gt;求平方跟 sqrt&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public int sqrt (int x) {
        int left = 0;
        int right = x;
        int res = -1;
        while (left &amp;lt;= right) {
            int mid = left+(right-left)/2;
            if ((long)mid*mid &amp;lt;= x) {
                res = mid;
                left = mid +1;
            } else {
                right = mid -1;
            }
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(logx)，即为二分查找需要的次数。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;字符串的排序&#34;&gt;字符串的排序&lt;/h4&gt;
&lt;p&gt;输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    ArrayList&amp;lt;String&amp;gt; res;
    boolean[] used;
    public ArrayList&amp;lt;String&amp;gt; Permutation(String str) {
       int n = str.length();
        res = new ArrayList&amp;lt;&amp;gt;();
        used = new boolean[n];
        char[] arr = str.toCharArray();
        Arrays.sort(arr);
        StringBuilder sb = new StringBuilder();
        backTrack(arr,sb);
        return res;
    }
    private void backTrack(char[] arr,StringBuilder sb){
        if (sb.length()==arr.length){
            res.add(sb.toString());
            return;
        }
        for(int i=0;i&amp;lt;arr.length;i++) {
          // used[i - 1] == true，说明同⼀树⽀arr[i - 1]使⽤过
          // used[i - 1] == false，说明同⼀树层arr[i - 1]使⽤过
          // 如果同⼀树层arr[i - 1]使⽤过则直接跳过
            if(i&amp;gt;0&amp;amp;&amp;amp;arr[i-1]==arr[i]&amp;amp;&amp;amp;used[i-1]==false) {
                continue;
            }
            if(used[i]==false){//如果同⼀树⽀arr[i]没使⽤过开始处理
                used[i]=true;//标记同⼀树⽀arr[i]使⽤过，防止同一树支重复使用
                sb.append(arr[i]);
                backTrack(arr,sb);
                sb.deleteCharAt(sb.length()-1);
                used[i] = false;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n×n!)，其中n为给定字符串的长度。这些字符的全部排列有O(n!) 个，每个排列平均需要O(n)的时间来生成。&lt;/li&gt;
&lt;li&gt;空间复杂度:O(n)。需要O(n)的栈空间进行回溯，注意返回值不计入空间复杂度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;二叉树的最大深度&#34;&gt;二叉树的最大深度&lt;/h4&gt;
&lt;p&gt;求给定二叉树的最大深度，深度是指树的根节点到任一叶子节点路径上节点的数量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        } else {
            int leftHeight = maxDepth(root.left);
            int rightHeight = maxDepth(root.right);
            return Math.max(leftHeight, rightHeight) + 1;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)，其中n为树节点的个数。每个节点在递归中只被遍历一次。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(height)，其中height 表示树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于树的高度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;单链表的排序&#34;&gt;单链表的排序&lt;/h4&gt;
&lt;p&gt;给定一个节点数为n的无序单链表，对其按升序排序。 归并&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public ListNode sortInList (ListNode head) {
        if(head == null) {
            return head;
        }
        int len = 0;//链表长度
        ListNode node = head;
        while (node != null) {
            len++;
            node = node.next;
        }
        ListNode dummy = new ListNode(0);
        dummy.next = head;
      //subLength 表示每次需要排序的子链表的长度
        for(int subLength=1;subLength&amp;lt;len;subLength&amp;lt;&amp;lt;=1) {
            ListNode pre = dummy, cur = dummy.next;
            while (cur != null) {
   //每次将链表拆分成若干个长度为subLength 的子链表，按照每两个子链表一组进行合并
                ListNode head1 = cur;
                for(int i=1;i&amp;lt;subLength&amp;amp;&amp;amp;cur.next!=null;i++) {
                    cur = cur.next;
                }
                ListNode head2 = cur.next;
                cur.next = null;
                cur = head2;
                for(int i=1;i&amp;lt;subLength&amp;amp;&amp;amp;cur!=null&amp;amp;&amp;amp;cur.next!=null;i++){
                    cur = cur.next;
                }
                ListNode next = null;
                if (cur!=null){
                    next = cur.next;
                    cur.next = null;
                }
                ListNode merged = merge(head1,head2);
                pre.next = merged;
                while(pre.next != null) {
                    pre = pre.next;
                }
                cur = next;
            }
        }
        return dummy.next;
    }
    private ListNode merge(ListNode head1,ListNode head2){
        ListNode dummy = new ListNode(0);
        ListNode temp = dummy,temp1 = head1, temp2 = head2;
        while(temp1 != null &amp;amp;&amp;amp; temp2 != null){
            if (temp1.val &amp;lt;= temp2.val){
                temp.next = temp1;
                temp1 = temp1.next;
            } else {
                temp.next = temp2;
                temp2 = temp2.next;
            }
            temp = temp.next;
        }
        if(temp1 !=null){
            temp.next = temp1;
        } else if(temp2 != null) {
            temp.next = temp2;
        }
        return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn)，其中 n 是链表的长度。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;最小路径和&#34;&gt;最小路径和&lt;/h4&gt;
&lt;p&gt;给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public int minPathSum (int[][] matrix) {
        // write code here
        int[][] dp = new int[matrix.length][matrix[0].length];
        dp[0][0] = matrix[0][0];
        for (int i = 1;i&amp;lt;matrix.length;i++) {
            dp[i][0] = dp[i-1][0]+matrix[i][0];
        }
        for(int i=1;i&amp;lt;matrix[0].length;i++) {
            dp[0][i] = dp[0][i-1]+matrix[0][i];
        }
        for(int i = 1;i&amp;lt;matrix.length;i++) {
            for (int j= 1;j&amp;lt; matrix[0].length;j++) {
                dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1])+matrix[i][j];
            }
        }
        return dp[matrix.length-1][matrix[0].length-1];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(mn)，其中m和n分别是网格的行数和列数。需要对整个网格遍历一次，计算 dp 的每个元素的值。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(mn)，其中m和n分别是网格的行数和列数。创建一个二维数组dp，和网格大小相同。空间复杂度可以优化，例如每次只存储上一行的dp 值，则可以将空间复杂度优化到 O(n)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;表达式求值-基本计算器&#34;&gt;表达式求值 基本计算器&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    // 使用 map 维护一个运算符优先级（其中加减法优先级相同，乘法有着更高的优先级）
    Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;Character, Integer&amp;gt;(){{
        put(&#39;-&#39;, 1);
        put(&#39;+&#39;, 1);
        put(&#39;*&#39;, 2);
    }};

    public int solve(String s) {
        // 将所有的空格去掉
        s = s.replaceAll(&amp;quot; &amp;quot;, &amp;quot;&amp;quot;);

        char[] cs = s.toCharArray();
        int n = s.length();

        // 存放所有的数字
        Deque&amp;lt;Integer&amp;gt; nums = new ArrayDeque&amp;lt;&amp;gt;();
        // 为了防止第一个数为负数，先往 nums 加个 0
        nums.addLast(0);
        // 存放所有「非数字以外」的操作
        Deque&amp;lt;Character&amp;gt; ops = new ArrayDeque&amp;lt;&amp;gt;();

        for (int i = 0; i &amp;lt; n; i++) {
            char c = cs[i];
            if (c == &#39;(&#39;) {
                ops.addLast(c);
            } else if (c == &#39;)&#39;) {
                // 计算到最近一个左括号为止
                while (!ops.isEmpty()) {
                    if (ops.peekLast() != &#39;(&#39;) {
                        calc(nums, ops);
                    } else {
                        ops.pollLast();
                        break;
                    }
                }
            } else {
                if (isNumber(c)) {
                    int u = 0;
                    int j = i;
                    // 将从 i 位置开始后面的连续数字整体取出，加入 nums
                    while (j &amp;lt; n &amp;amp;&amp;amp; isNumber(cs[j])) u = u * 10 + (cs[j++] - &#39;0&#39;);
                    nums.addLast(u);
                    i = j - 1;
                } else {
                    if (i &amp;gt; 0 &amp;amp;&amp;amp; (cs[i - 1] == &#39;(&#39; || cs[i - 1] == &#39;+&#39; || cs[i - 1] == &#39;-&#39;)) {
                        nums.addLast(0);
                    }
                    // 有一个新操作要入栈时，先把栈内可以算的都算了 
                    // 只有满足「栈内运算符」比「当前运算符」优先级高/同等，才进行运算
                    while (!ops.isEmpty() &amp;amp;&amp;amp; ops.peekLast() != &#39;(&#39;) {
                        char prev = ops.peekLast();
                        if (map.get(prev) &amp;gt;= map.get(c)) {
                            calc(nums, ops);
                        } else {
                            break;
                        }
                    }
                    ops.addLast(c);
                }
            }
        }
        // 将剩余的计算完
        while (!ops.isEmpty() &amp;amp;&amp;amp; ops.peekLast() != &#39;(&#39;) calc(nums, ops);
        return nums.peekLast();
    }
    // 计算逻辑：从 nums 中取出两个操作数，从 ops 中取出运算符，然后根据运算符进行计算即可
    void calc(Deque&amp;lt;Integer&amp;gt; nums, Deque&amp;lt;Character&amp;gt; ops) {
        if (nums.isEmpty() || nums.size() &amp;lt; 2) return;
        if (ops.isEmpty()) return;
        int b = nums.pollLast(), a = nums.pollLast();
        char op = ops.pollLast();
        int ans = 0;
        if (op == &#39;+&#39;) ans = a + b;
        else if (op == &#39;-&#39;) ans = a - b;
        else if (op == &#39;*&#39;) ans = a * b;    
        nums.addLast(ans);
    }
    boolean isNumber(char c) {
        return Character.isDigit(c);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;判断平衡二叉树&#34;&gt;判断平衡二叉树&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        int height = judge(root);
        return height &amp;gt;= 0;
    }
    private int judge (TreeNode root) {
        if (root == null)
            return 0;
        int left = judge(root.left);
        int right = judge(root.right);
        if(left==-1||right==-1||Math.abs(left-right)&amp;gt;1) {
            return -1;
        } else {
            return Math.max(left,right)+1;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)，其中n是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是O(n)。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)，其中n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过n。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数组中超过一半的数字&#34;&gt;数组中超过一半的数字&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int majorityElement(int[] nums) {
        int candidate = 0;
        int count = 0;
        for (int n : nums) {
            if (count == 0)
                candidate = n;
            if (candidate == n) {
                count++;
            } else {
                count--;
            }
        }
        return candidate;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)。Boyer-Moore 算法只对数组进行了一次遍历。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。Boyer-Moore 算法只需要常数级别的额外空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;字符串出现次数topk&#34;&gt;字符串出现次数topk&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;
public class Solution {
public String[][] topKstrings (String[] strings, int k) {
   // write code here
   if (k == 0){
       return new String[][]{};
   }
   String[][] res = new String[k][2];
   TreeMap&amp;lt;String,Integer&amp;gt; map = new TreeMap&amp;lt;&amp;gt;();
   // 统计各个字符串出现的次数
   for (int i=0;i&amp;lt;strings.length;++i){
       String s = strings[i];
       if (!map.containsKey(s)) {
           map.put(s, 1);
       } else {
           map.put(s, map.get(s) + 1);
       }
   }

   ArrayList&amp;lt;Map.Entry&amp;lt;String, Integer&amp;gt;&amp;gt; list = 
       new ArrayList&amp;lt;&amp;gt;(map.entrySet());
   // 先是按出现次数降序比较，相同则再按照字符ASCII码降序比较
   Collections.sort(list,
                    (o1, o2) -&amp;gt; 
                    (o1.getValue().compareTo(o2.getValue()) ==
                     0 ? o1.getKey().compareTo(o2.getKey()) : 
                     o2.getValue().compareTo(o1.getValue()))
                   );
   // 返回topK
   for (int i = 0; i &amp;lt; k; i++) {
       res[i][0] = list.get(i).getKey();
       res[i][1] = String.valueOf(list.get(i).getValue());
   }
   return res;
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(nlogn)，遍历统计为O(N)，但是降序排序需要O(nlogn)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)，使用hashmap辅助结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;进制转换&#34;&gt;进制转换&lt;/h4&gt;
&lt;p&gt;给定一个十进制数 M ，以及需要转换的进制数 N 。将十进制数 M 转化为 N 进制数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public String solve (int M, int N) {
        // write code here
        if(M == 0)  return &amp;quot;0&amp;quot;;
        String s = &amp;quot;0123456789ABCDEF&amp;quot;;
        StringBuffer sb = new StringBuffer();
        boolean f = false;
        if(M &amp;lt; 0){
            f = true;
            M = -M;
        }
        while(M != 0){
            sb.append(s.charAt(M%N));
            M /= N;
        }
        if(f) sb.append(&amp;quot;-&amp;quot;);
        return sb.reverse().toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间 O(M)&lt;/li&gt;
&lt;li&gt;空间 O((N))&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;leetcode&#34;&gt;leetcode&lt;/h2&gt;
&lt;h4 id=&#34;整数反转&#34;&gt;整数反转&lt;/h4&gt;
&lt;p&gt;给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。&lt;/p&gt;
&lt;p&gt;如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int reverse(int x) {
        int res = 0;
        while (x != 0) {
            if (res &amp;lt; Integer.MIN_VALUE/10||res&amp;gt;Integer.MAX_VALUE/10) {
                return 0;
            }
            int digit = x % 10;
            x /= 10;
            res = res*10 + digit;
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：&lt;em&gt;O&lt;/em&gt;(log∣&lt;em&gt;x&lt;/em&gt;∣)。翻转的次数即 x十进制的位数。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;字典序的第k小数字&#34;&gt;字典序的第K小数字&lt;/h4&gt;
&lt;p&gt;给定整数 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt;，返回 &lt;code&gt;[1, n]&lt;/code&gt; 中字典序第 &lt;code&gt;k&lt;/code&gt; 小的数字。&lt;/p&gt;
&lt;p&gt;1.初始化前缀为1，计算以1开头的节点树的所有子树结点个数，如果小于k，那么根节点往右走（说明当前子 树的结点树不够）；如果大于k，那么根节点往下走（说明答案就在当前根节点的子 树结点）&lt;/p&gt;
&lt;p&gt;2.减去已遍历过的结点数之后，可以直接将当前结点看成新的根节点，一直重复这两步的操作，直到k = 0，找到答案。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public int findKthNumber(int n, int k) {
        //从根节点下面的第一个结点1开始遍历，由于数据范围很大，所以用long
        long cur = 1;
        //从1出发开始往后按字典序从小到大的顺序走k-1步到达的就是 字典序的第K小数字
        k -= 1;
        while (k &amp;gt; 0) {
            //得到以当前结点为根的所有子树节点数目
            int nodes = getNodes(n, cur);
            //如果k要大于当前根节点下所有子树结点的数目，就向右侧节点走(-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6-&amp;gt;7-&amp;gt;8-&amp;gt;9)：字典序上升nodes位
            if (k &amp;gt;= nodes) {
                //减去已经遍历的个数
                k -= nodes;
                //根节点右移
                cur ++;
            } 
            //如果k小于当前根节点下所有子树结点的数目，说明答案就在当前根节点的子树结点中
            else {
                //减去根节点的数量1
                k -= 1;
                //将根结点移动到下一层（每一层右10个结点）
                cur *= 10;
            }
        }
        //最终k = 0时，就找到了答案
        return (int)cur;
    }

    // 计算以cur为根的子树节点数目，所有节点的值必须 &amp;lt;= n
    private int getNodes(int n, long cur){
        // 记录子树中的全部节点数目
        long totalNodes = 0; 
        // 当前节点右侧右边节点的值
        long next = cur + 1; 
        while(cur &amp;lt;= n){
            //取整行结点的个数，可能全部都满了，也可能是叶子结点，没有充满
            totalNodes += Math.min(n - cur + 1, next - cur);
            //cur - cur在当前层的第一个结点， next - cur右侧根结点的第一个结点
            next *= 10;
            cur *= 10;
        }
        return (int)totalNodes;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(log2n)，其中 n为 给定的 数值的大小。每次计算子树下的节点数目的搜索深度最大为log10n，最多需要搜索log10n 层，每一层最多需要计算10 次，最多需要计算 (log 10n) 2 次，因此时间复杂度为 O(log 2n)。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)不需要开辟额外的空间，只需常数空间记录常量即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;分发糖果&#34;&gt;分发糖果&lt;/h4&gt;
&lt;p&gt;n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：&lt;/p&gt;
&lt;p&gt;每个孩子至少分配到 1 个糖果。相邻两个孩子评分更高的孩子会获得更多的糖果。&lt;br&gt;
请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int candy(int[] ratings) {
        int n = ratings.length;
        int ret = 1;
        int inc = 1, dec = 0, pre = 1;
        for (int i = 1; i &amp;lt; n; i++) {
            if (ratings[i] &amp;gt;= ratings[i - 1]) {
                dec = 0;
        //如果当前同学比上一个同学评分高，说明我们就在最近的递增序列中，直接分配给该同学pre+1个糖果即可。
                pre = ratings[i] == ratings[i - 1] ? 1 : pre + 1;
                ret += pre;
                inc = pre;
            } else {
       //否则我们就在一个递减序列中，我们直接分配给当前同学一个糖果，并把该同学所在的递减序列中所有的同学都再多分配一个糖果，以保证糖果数量还是满足条件。
                dec++;
                if (dec == inc) {
  //当当前的递减序列长度和上一个递增序列等长时，需要把最近的递增序列的最后一个同学也并进递减序列中
                    dec++;
                }
                ret += dec;
                pre = 1;
            }
        }
        return ret;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时间复杂度：O(n)，其中 n是孩子的数量。我们需要遍历两次数组以分别计算满足左规则或右规则的最少糖果数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间复杂度：O(1)。我们只需要常数的空间保存若干变量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">bytedance</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/neteast/"" data-c="
          &lt;h5 id=&#34;lru缓存请你设计并实现一个满足lru-最近最少使用-缓存约束的数据结构&#34;&gt;LRU缓存请你设计并实现一个满足LRU (最近最少使用) 缓存约束的数据结构。&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class LRUCache {
    class Node{
        int key;
        int value;
        Node pre;
        Node next;
        public Node(){}
        public Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
    private int size = 0;
    private HashMap&amp;lt;Integer,Node&amp;gt; cache = new HashMap&amp;lt;&amp;gt;();
    private int capacity = 0;
    private Node head,tail;
    public LRUCache(int capacity) {
        this.capacity = capacity;
        head = new Node();
        tail = new Node();
        head.next = tail;
        tail.pre = head;
    }
    
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        }
        moveToHead(node);
        return node.value;
    }
    private void moveToHead(Node node) {
        removeNode(node);
        addToHead(node);
    }
    private void removeNode(Node node) {
        node.pre.next = node.next;
        node.next.pre = node.pre;
    }
    private void addToHead (Node node) {
        node.pre = head;
        node.next = head.next;
        head.next.pre = node;
        head.next = node;
    }
    public void put(int key, int value) {
        Node node = cache.get(key);
        if (node == null) {
            Node newNode = new Node(key,value);
            cache.put(key,newNode);
            addToHead(newNode);
            size++;
            if (size &amp;gt; capacity) {
                Node tail = removeTail();
                cache.remove(tail.key);
            }
        } else {
            node.value = value;
            moveToHead(node);
        }
    }
    private Node removeTail() {
        Node res = tail.pre;
        removeNode(res);
        return res;//返回要在cache中删除掉node
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：对于 put 和 get 都是O(1)。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(capacity)，因为哈希表和双向链表最多存储capacity+1个元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;在圆内随机生成点&#34;&gt;在圆内随机生成点&lt;/h4&gt;
&lt;p&gt;给定圆的半径和圆心的位置，实现函数 &lt;code&gt;randPoint&lt;/code&gt; ，在圆中产生均匀随机点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    double rad, xc, yc;
    public Solution(double radius, double x_center, double y_center) {
        rad = radius;
        xc = x_center;
        yc = y_center;
    }

    public double[] randPoint() {
        double x0 = xc - rad;
        double y0 = yc - rad;

        while(true) {
            double xg = x0 + Math.random() * rad * 2;
            double yg = y0 + Math.random() * rad * 2;
            if (Math.sqrt(Math.pow((xg - xc) , 2) + Math.pow((yg - yc), 2)) &amp;lt;= rad)
                return new double[]{xg, yg};
        }
    }
}	
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：期望时间复杂度为O(1)，但最坏情况下会达到 O(∞)（一直被拒绝）。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;缺失的第一个正数&#34;&gt;缺失的第一个正数&lt;/h4&gt;
&lt;p&gt;给你一个未排序的整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出其中没有出现的最小的正整数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        int res = 0;
        //把所有负数设为n+1，和[1,n]区分开
        for (int i = 0; i &amp;lt; n; i++) {
            if (nums[i] &amp;lt;= 0) {
                nums[i] = n + 1;
            }
        }
      //将存在的整数i用复数打标记
        for (int i = 0; i &amp;lt; n; i++) {
            int cur = Math.abs(nums[i]);
            if (cur &amp;lt;= n) {
                nums[cur-1] = -Math.abs(nums[cur-1]);
            }
        }
      //找到第一个没被负数标记的索引，i+1则是最小正整数
        for (int i = 0; i &amp;lt; n; i++) {
            if (nums[i] &amp;gt; 0)
                return i + 1;
        }
        return n+1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(N)，其中 N是数组的长度。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;多数元素&#34;&gt;多数元素&lt;/h4&gt;
&lt;p&gt;给定一个大小为 &lt;em&gt;n&lt;/em&gt; 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 &lt;strong&gt;大于&lt;/strong&gt; &lt;code&gt;⌊ n/2 ⌋&lt;/code&gt; 的元素。&lt;/p&gt;
&lt;p&gt;核心就是对拼消耗。玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int majorityElement(int[] nums) {
        int candidate = 0;
        int count = 0;
        for (int n : nums) {
            if (count == 0)
                candidate = n;
            if (candidate == n) {
                count++;
            } else {
                count--;
            }
        }
        return candidate;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;时间复杂度：O(n)。Boyer-Moore 算法只对数组进行了一次遍历。&lt;/p&gt;
&lt;p&gt;空间复杂度：O(1)。只需要常数级别的额外空间。&lt;/p&gt;
&lt;h4 id=&#34;ip-到-cidr&#34;&gt;IP 到 CIDR&lt;/h4&gt;
&lt;p&gt;给你一个起始IP地址 ip 和我们需要覆盖的IP地址数量 n 。你的目标是使用 尽可能少的CIDR块 来 覆盖范围 [ip, ip + n - 1] 内的所有IP地址 。不应该覆盖范围之外的其他IP地址。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public List&amp;lt;String&amp;gt; ipToCIDR(String ip, int n) {
        long start = ipToLong(ip);
        List&amp;lt;String&amp;gt; ans = new ArrayList();
        while (n &amp;gt; 0) {
            int mask = Math.max(33 - bitLength(Long.lowestOneBit(start)),
                                33 - bitLength(n));
            ans.add(longToIP(start) + &amp;quot;/&amp;quot; + mask);
            start += 1 &amp;lt;&amp;lt; (32 - mask);
            n -= 1 &amp;lt;&amp;lt; (32 - mask);
        }
        return ans;
    }
    private long ipToLong(String ip) {
        long ans = 0;
        for (String x: ip.split(&amp;quot;\\.&amp;quot;)) {
            ans = 256 * ans + Integer.valueOf(x);
        }
        return ans;
    }
    private String longToIP(long x) {
        return String.format(&amp;quot;%s.%s.%s.%s&amp;quot;,
            x &amp;gt;&amp;gt; 24, (x &amp;gt;&amp;gt; 16) % 256, (x &amp;gt;&amp;gt; 8) % 256, x % 256);
    }
    private int bitLength(long x) {
        if (x == 0) return 1;
        int ans = 0;
        while (x &amp;gt; 0) {
            x &amp;gt;&amp;gt;= 1;
            ans++;
        }
        return ans;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(N)。其中 N 表示的是 &lt;code&gt;nums&lt;/code&gt; 的长度&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;至少有-k-个重复字符的最长子串&#34;&gt;至少有 K 个重复字符的最长子串&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int longestSubstring(String s, int k) {
        int ret = 0;
        int n = s.length();
        for (int t = 1; t &amp;lt;= 26; t++) {
            int l = 0, r = 0;
            int[] cnt = new int[26];
            int tot = 0;
            int less = 0;
            while (r &amp;lt; n) {
                cnt[s.charAt(r) - &#39;a&#39;]++;
                if (cnt[s.charAt(r) - &#39;a&#39;] == 1) {
                    tot++;
                    less++;
                }
                if (cnt[s.charAt(r) - &#39;a&#39;] == k) {
                    less--;
                }

                while (tot &amp;gt; t) {
                    cnt[s.charAt(l) - &#39;a&#39;]--;
                    if (cnt[s.charAt(l) - &#39;a&#39;] == k - 1) {
                        less++;
                    }
                    if (cnt[s.charAt(l) - &#39;a&#39;] == 0) {
                        tot--;
                        less--;
                    }
                    l++;
                }
                if (less == 0) {
                    ret = Math.max(ret, r - l + 1);
                }
                r++;
            }
        }
        return ret;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(N⋅∣Σ∣+∣Σ∣ *∣Σ∣  )，其中 N 为字符串的长度，Σ 为字符集，本题中字符串仅包含小写字母，因此 ∣Σ∣=26。我们需要遍历所有可能的 t，共 ∣Σ∣ 种可能性；内层循环中滑动窗口的复杂度为 O(N)，且初始时需要 O(∣Σ∣) 的时间初始化 cnt 数组。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(∣Σ∣)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;堆排序-heapsort&#34;&gt;堆排序 Heapsort&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public void heapSort(int[] nums){
        if(nums==null||nums.length&amp;lt;2){
            return;
        }
        for(int i=0;i&amp;lt;nums.length;i++){
            heapInsert(nums,i);
        }
        int heapSize = nums.length;
        swap(nums,0,--heapSize);
        while(heapSize&amp;gt;0){
            heapify(nums,0,heapSize);
            swap(nums,0,--heapSize);
        }
    }
    //某个数处在index，往上继续移动
    private void heapInsert(int[] nums,int index){
        while(nums[(index-1)/2]&amp;lt;nums[index]){
            swap(nums,(index-1)/2,index);
            index = (index-1)/2;
        }
    }
    private void swap(int[] nums,int left,int right){
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
  	//和左、右节点比较，小于则往下换
    private void heapify(int[] nums,int index,int heapSize){
        int left = index*2+1;//从上往下移动,左孩子下标
        while(left&amp;lt;heapSize){
            int largest=left+1&amp;lt;heapSize&amp;amp;&amp;amp;nums[left+1]&amp;gt;nums[left]?left+1:left;
            largest=nums[largest]&amp;gt;nums[index]?largest:index;
            if(largest==index){
                break;
            }
            swap(nums,largest,index);
            index = largest;
            left=index*2+1;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;数组中的第k个最大元素-快排-quicksort&#34;&gt;数组中的第K个最大元素  快排 quicksort&lt;/h4&gt;
&lt;p&gt;给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int findKthLargest(int[] nums, int k) {
        quickSort(nums,0,nums.length-1);
        return nums[nums.length-k];
    }
    private void quickSort(int[] nums,int left,int right){
        if(left&amp;lt;right){
            swap(nums,(int)(left+Math.random()*(right-left+1)),right);
            int[] res = partition(nums,left,right);
            quickSort(nums,left,res[0]-1);
            quickSort(nums,res[1]+1,right);
        }
    }
    private void swap(int[] nums,int left,int right){
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
    private int[] partition(int[] nums,int left,int right){
        int less = left-1; //小于区域
        int more = right;  //大于区域
        while(left&amp;lt;more){
            if(nums[left]&amp;lt;nums[right]){
                swap(nums,++less,left++);
            }else if(nums[left]&amp;gt;nums[right]){
                swap(nums,--more,left);
            }else{
                left++;
            }
        }
        swap(nums,more,right);
        return new int[]{less+1,more};//返回相等区域
    }
}
&lt;/code&gt;&lt;/pre&gt;
">neteast</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/malware/"" data-c="
          &lt;h2 id=&#34;intro-to-malware&#34;&gt;Intro to Malware&lt;/h2&gt;
&lt;h3 id=&#34;types-of-malware&#34;&gt;Types of malware&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Target&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Mass&lt;/li&gt;
&lt;li&gt;Specific&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Forms&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Trojan Horse: Beware of Greeks...&lt;/li&gt;
&lt;li&gt;Virus: Spreading by host file&lt;/li&gt;
&lt;li&gt;Worm: Spreading by vulnerability&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;information-stealing&#34;&gt;Information Stealing&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Collect information from computer and send it to the attacker&lt;/li&gt;
&lt;li&gt;Keyloggers: Actively recording everything typed&lt;/li&gt;
&lt;li&gt;Sniffers: Monitor for anything that looks interested&lt;/li&gt;
&lt;li&gt;Password stealers: Grab autocomplete and password information from web browsers and send them off&lt;/li&gt;
&lt;li&gt;Intercepting: Browser extensions, proxy or similar technologies to intercept and manipulate web traffic&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;remote-access&#34;&gt;Remote Access&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Backdoor&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Allows an attacker remote access&lt;/li&gt;
&lt;li&gt;Commonly a remote shell&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Botnet&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;P2P networks, IRC, Twitter...&lt;/li&gt;
&lt;li&gt;Listen and wait for commands&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ransomware&#34;&gt;&lt;strong&gt;Ransomware&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Silently install, and start encrypting files in the background that you’re not using&lt;/li&gt;
&lt;li&gt;using asymmetric encryption, so you’d never have had the key on the system&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;rootkit&#34;&gt;Rootkit&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Hooking into operating system calls and changing their behaviour
&lt;ul&gt;
&lt;li&gt;Conceal the payload&lt;/li&gt;
&lt;li&gt;If you can’t see it, you can’t easily remove it&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Common examples
&lt;ul&gt;
&lt;li&gt;File and directory hiding&lt;/li&gt;
&lt;li&gt;Process hiding&lt;/li&gt;
&lt;li&gt;Registry hiding&lt;/li&gt;
&lt;li&gt;Falsified files&lt;/li&gt;
&lt;li&gt;Preventing applications from running&lt;/li&gt;
&lt;li&gt;Resisting removal&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;downloaders-and-launchers&#34;&gt;Downloaders and Launchers&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Specific standalone code to bundle other malware&lt;/li&gt;
&lt;li&gt;Downloaders/Droppers&lt;/li&gt;
&lt;li&gt;Launchers
&lt;ul&gt;
&lt;li&gt;To launch other malware&lt;/li&gt;
&lt;li&gt;Generally to make use of exploits and launch in a specific way&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;malware-on-windows&#34;&gt;Malware on Windows&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Portable Execute format (PE)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Linking&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Static&lt;/strong&gt;: Code from library is in executable&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dynamic&lt;/strong&gt;: Imports listed, OS loads at start&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Runtime&lt;/strong&gt;: Connect to libraries only when function needed&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PE Header&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Information about the entire file&lt;/li&gt;
&lt;li&gt;Type of code&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flags (e.g. executable, DLL)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Linking information&lt;/li&gt;
&lt;li&gt;Size and memory information&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;pe-sections&#34;&gt;PE Sections&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PE file made up of sections&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sections have names, flags (e.g. executable) and content&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Typical layout:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;.text&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Instructions–whattheCPUexecutes&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Containstheexecutablecode&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.rdata&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Imports and exports&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.data&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Globaldatafortheprogram&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.rsrc&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Resources used by the program (e.g. icons, dialogs, strings)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;pe-execution&#34;&gt;PE Execution&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Extract entry point, heap and stack sizes from PE header&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Iterate through sections and load into virtual memory&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Find address of entry point from symbol table&lt;/li&gt;
&lt;li&gt;Load imports&lt;/li&gt;
&lt;li&gt;Create a new thread at that address, and execute&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;linking-information&#34;&gt;Linking Information&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Imports&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;What will be called outside&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DLLs – libraries of functions that you can use&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;get used to seeing certain DLLs
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Kernel32.dll – Core functionality (memory, files, hardware)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Advapi32.dll – Windows components (service manger, registry)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;User32.dll - User interface components&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gdi32.dll – Display&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ntdll.dll – Interface to windows kernel&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WSock32.dll/WS2_32.dll – Winsock (network)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Wininet.dll – High level networking functions&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exports&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;What can be called inside
&lt;ul&gt;
&lt;li&gt;Dllmain&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;common-techniques-employed&#34;&gt;Common techniques employed&lt;/h3&gt;
&lt;h4 id=&#34;persistence&#34;&gt;Persistence&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Malware generally needs to persist between system boots&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;How can they make sure they load each time?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Logon (Shell, Run)&lt;/li&gt;
&lt;li&gt;Explorer hooks&lt;/li&gt;
&lt;li&gt;Scheduled tasks&lt;/li&gt;
&lt;li&gt;Services&lt;/li&gt;
&lt;li&gt;Drivers&lt;/li&gt;
&lt;li&gt;Boot execute&lt;/li&gt;
&lt;li&gt;AppInit (DLL loaded into every application that starts)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Generally: Remove their persistence, remove the malware!&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the malware is running&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Make it hard to stop the Malware once it is running&lt;/li&gt;
&lt;li&gt;Prevent removing/changing the persistence&lt;/li&gt;
&lt;li&gt;Hide the presence of persistence (Rootkit behaviour)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RunOnce&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every boot, the malware is loaded from the RunOnce key, then removed – but it’s in memory&lt;/li&gt;
&lt;li&gt;No tools will show it as being persistent anywhere, as the RunOnce key is no longer populated&lt;/li&gt;
&lt;li&gt;On a clean shutdown, write back to the RunOnce key&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Solution: Don’t clean shutdown!&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;stealth&#34;&gt;Stealth&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Camouflage against legitimate system files&lt;/li&gt;
&lt;li&gt;Pretend to be Microsoft&lt;/li&gt;
&lt;li&gt;Inject into other processes&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Replace legitimate files&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Hiding from the operating system
&lt;ul&gt;
&lt;li&gt;Rootkit time&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;analysing-malware&#34;&gt;Analysing Malware&lt;/h2&gt;
&lt;h3 id=&#34;basic-static-analysis&#34;&gt;Basic Static Analysis&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Examine the PE file itself&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Signature&lt;/strong&gt;: What was it compiled with?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Structure&lt;/strong&gt;: Is it packed?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sections&lt;/strong&gt;: How is the file made up?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Metadata&lt;/strong&gt;: What other information is there?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Certification&lt;/strong&gt;: Has the file been digitally signed?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Imports&lt;/strong&gt;: What does it use?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exports&lt;/strong&gt;: What does it make available?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Strings&lt;/strong&gt;: What text does it contain?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Resources&lt;/strong&gt;: What icons, menus, dialogs does it have?&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;signature-structure&#34;&gt;Signature &amp;amp; Structure&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Detect it Easy&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-03-28%2016.46.36.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Helps you before you try to do static analysis&lt;/li&gt;
&lt;li&gt;Uses signatures for PE information&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;examining-the-pe-file&#34;&gt;Examining the PE File&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;Portable Executable (PE)&lt;/strong&gt; file format is used by Windows executables, object code, and DLLs&lt;/li&gt;
&lt;li&gt;The PE file format is a data structure that contains the information necessary for the Windows OS loader to manage the wrapped executable code&lt;/li&gt;
&lt;li&gt;The information in the PE can provide valuable information to the malware analyst&lt;/li&gt;
&lt;li&gt;Use DependencyWalker and Peview to examine a PE file&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;pe-file-structure&#34;&gt;PE File Structure&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;Header&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stores information about every library that will be loaded and every function that will be used by the program&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Sections&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;.text&lt;/strong&gt; Contains the executable code&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.rdata&lt;/strong&gt; Holds &lt;strong&gt;read-only&lt;/strong&gt; data that is globally accessible within the program&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.data&lt;/strong&gt; Stores global data accessed throughout the program&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.rsrc&lt;/strong&gt; Stores resources needed by the executable&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;packing-and-obfuscation&#34;&gt;Packing and Obfuscation&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Is it packed?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Barely any imports&lt;/li&gt;
&lt;li&gt;No useful strings&lt;/li&gt;
&lt;li&gt;Non-standard names of sections o Section specifications&lt;/li&gt;
&lt;li&gt;Section contains code&lt;/li&gt;
&lt;li&gt;Section can be executed as code o Size differences&lt;/li&gt;
&lt;li&gt;Two main functions
&lt;ul&gt;
&lt;li&gt;LoadLibrary&lt;/li&gt;
&lt;li&gt;GetProcAddress&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Other functions
&lt;ul&gt;
&lt;li&gt;Functions which work with virtual memory&lt;/li&gt;
&lt;li&gt;Functions to work with libraries&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Is it obfuscated?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No useful names&lt;/li&gt;
&lt;li&gt;Conventions not adhered to&lt;/li&gt;
&lt;li&gt;No useful strings&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;sections-and-metadata&#34;&gt;&lt;strong&gt;Sections and Metadata&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;PEStudio&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;imports-and-exports&#34;&gt;&lt;strong&gt;Imports and Exports:&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Dependency Walker&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Imports&lt;/strong&gt;: What functions does the malware use&lt;/li&gt;
&lt;li&gt;Only includes those directly accessed&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exports&lt;/strong&gt;: What functions does the malware make available – when the malware isn’t a single file&lt;/li&gt;
&lt;li&gt;Dependency walker breaks this down for us&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;common-dlls&#34;&gt;Common DLLs&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-03-28%2016.56.19.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;examples-of-imported-functions&#34;&gt;Examples of Imported functions&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;OpenProcess, GetCurrentProcess, and GetProcessHeap
&lt;ul&gt;
&lt;li&gt;open and manipulate processes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ReadFile, CreateFile, and WriteFile&lt;/li&gt;
&lt;li&gt;FindFirstFile and FindNextFile&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;strings&#34;&gt;&lt;strong&gt;Strings&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;Simple tool – find all the strings that are accessible in the file&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;resources&#34;&gt;&lt;strong&gt;Resources&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Resource Hacker&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;View the sections inside the application&lt;/li&gt;
&lt;li&gt;View the resources that are associated with it&lt;/li&gt;
&lt;li&gt;Inspect any images, icons, dialogs and other resources inside&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;advanced-static-analysis&#34;&gt;Advanced Static Analysis&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;The only real tool for the job: IDA&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;graph-and-text-mode&#34;&gt;Graph and Text Mode&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Spacebar switches mode&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-03-28%2017.01.59.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;functions&#34;&gt;Functions&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Shows each function, length, and flags
&lt;ul&gt;
&lt;li&gt;L = Library functions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sortable
&lt;ul&gt;
&lt;li&gt;Large functions usually more important&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;names-window&#34;&gt;Names Window&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Every address with a name
&lt;ul&gt;
&lt;li&gt;Functions, named code, named data, strings&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-03-28%2017.03.33.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;imports-exports&#34;&gt;Imports &amp;amp; Exports&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-03-28%2017.04.48.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;structures&#34;&gt;Structures&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;All active data structures
&lt;ul&gt;
&lt;li&gt;Hover to see yellow pop-up window&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;function-call&#34;&gt;Function Call&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Parameters pushed onto stack&lt;/li&gt;
&lt;li&gt;CALL to start function&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-03-28%2017.06.16.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;jump-to-location&#34;&gt;Jump to Location&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Press G&lt;/li&gt;
&lt;li&gt;Can jump to address or named location&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;searching-function-and-argument-recognition&#34;&gt;Searching &amp;amp; Function and Argument Recognition&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;IDA Pro identifies a function, names it, and also names the local variables&lt;/li&gt;
&lt;li&gt;It&#39;s not always correct&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;advanced-analysis&#34;&gt;Advanced Analysis&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;You are only looking to see if you can spot anything interesting, you’re not trying to reverse engineer the whole thing&lt;/li&gt;
&lt;li&gt;Look up strings and function calls and see if there is any interesting code around it&lt;/li&gt;
&lt;li&gt;For UPX packed binaries, you’ll need to unpack them first&lt;/li&gt;
&lt;li&gt;Don’t worry about reverse engineering other packed binaries!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;reading-list&#34;&gt;Reading List&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Michael Sikorski and Andrew Honig. &lt;strong&gt;Practical Malware Analysis&lt;/strong&gt;. The Hands- On Guide to Dissecting Malicious Software. Chapters 4, 5, 7,8, 9&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hex-rays.com/products/ida/&#34;&gt;IDA Pro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ollydbg.de/&#34;&gt;OllyDbg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Malware</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/memory-management-file-io/"" data-c="
          &lt;h2 id=&#34;memory-layout-heap&#34;&gt;Memory Layout - Heap&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-03-14%2014.46.55.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Global variables, static variables and program instructions get their memory in permanent storage area&lt;/li&gt;
&lt;li&gt;local variables are stored in Stack.&lt;/li&gt;
&lt;li&gt;The memory space between these two region is known as Heap area.&lt;/li&gt;
&lt;li&gt;This region is used for dynamic memory allocation during execution of the program.&lt;/li&gt;
&lt;li&gt;The size of heap keep changing.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;memory-allocation&#34;&gt;Memory Allocation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The header &amp;lt;stdlib.h&amp;gt; declares functions for storage allocation&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;malloc &lt;strong&gt;returns a pointer to space for an object of a specified size&lt;/strong&gt;, or NULL if the request cannot be satisfied. The allocated space is uninitialized&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void *malloc(size_t size)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;free &lt;strong&gt;deallocates the space that previously allocated by&lt;/strong&gt; calloc, malloc, or realloc&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void free(void *P)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;size_t is an unsigned integer defined in stddef.h as (on my computer):&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef long unsigned int size_t;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;calloc&#34;&gt;calloc&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;calloc &lt;strong&gt;returns a pointer to space for an array of objects&lt;/strong&gt;, each of size size, or NULL &lt;strong&gt;if the request cannot be satisfied. The space is initialized to zero bytes&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void *calloc(size_t nobj, size_t size)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;realloc &lt;strong&gt;changes the size of the previously allocated memory by a new size.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;realloc &lt;strong&gt;returns a pointer to the new space, or NULL if the request cannot be satisfied, in which case the old allocated memory is unchanged.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void *realloc(void *p, size_t size)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio .h&amp;gt; 
#include &amp;lt;stdlib .h&amp;gt; 
#include &amp;lt;string .h&amp;gt;
int main() {
	char ∗language ;
	language = calloc ( 200, sizeof (char) );
	if( language == NULL ) { 
    fprintf(stderr ,
            &amp;quot;Error − ...\n&amp;quot;);
}
else {
	strcpy( language , &amp;quot;C programming language&amp;quot;);
}
	printf (&amp;quot;Language : %s\n&amp;quot; , language ); 
  free ( language );
	return 0;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;realloc&#34;&gt;realloc&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main() {
	char ∗language ;
	language = malloc( 25 ∗ sizeof(char) ); 
  if( language == NULL ) {
    fprintf(stderr , &amp;quot;...\n&amp;quot;);
}
	else {
	strcpy( language , &amp;quot;C programming language&amp;quot;);
}
language = realloc( language , 10 ∗ sizeof(char) ); 
  if( language == NULL ) {
    fprintf(stderr , &amp;quot;...\n&amp;quot;);
	}
	else {
	strcat( language , &amp;quot; tutorial&amp;quot;);
}
	printf (&amp;quot;Language : %s\n&amp;quot; , language ); 
  free ( language );
	return 0;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;pointer&#34;&gt;Pointer&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main() {
	int ∗iptr = malloc (sizeof(int));
	float ∗fptr = malloc (sizeof(float )); 
  double ∗dptr = malloc ( sizeof (double ));
	∗iptr = 100; 
	∗fptr = 4.13f; 
	∗dptr = 459000.0;
	printf(&amp;quot;∗iptr: %d\n&amp;quot;, ∗iptr); 
	printf(&amp;quot;∗fptr: %.2f\n&amp;quot;, ∗fptr); 
	printf(&amp;quot;∗dptr: %.2f\n&amp;quot;, ∗dptr);
	free(iptr); 
	free(fptr); 
	free(dptr); 
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;file-io&#34;&gt;File IO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;fopen &lt;strong&gt;opens the named file, and returns a stream, or NULL if the attempt fails&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;FILE *fopen(const char *filename, const char *mode)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Legal values for mode include:&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&amp;quot;r&amp;quot;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;open text file for reading&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;quot;w&amp;quot;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;create text file for writing; discard previous contents if any&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;quot;a&amp;quot;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;append; open or create text file for writing at end of file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;quot;r+&amp;quot;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;open text file for update (i.e., reading and writing)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;quot;w+&amp;quot;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;create text file for update; discard previous contents if any&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;quot;a+&amp;quot;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;append; open or create text file for update, writing at end&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;fflush &lt;strong&gt;causes any buffered but unwritten data to be written on an output stream&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int fflush(FILE *Stream)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;on an input stream, the effect is undefined&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;It returns EOF for a write error, and zero otherwise&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;fflush(NULL) &lt;strong&gt;flushes all output streams&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;fclose flushes any unwritten data for stream, discards any unread buffered input&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int fclose(FILE *Stream)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;frees any automatically allocated buffer, then closes the stream&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;It returns EOF if any errors occurred, and zero otherwise&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;writing-a-file&#34;&gt;Writing a file&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;fputc() writes the character value to an output stream&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int fputc( int c, FILE *fp );
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;fputs() writes a string to an output stream&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int fputs( const char *s, FILE *fp );
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;fprintf write a string to an output stream&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int fprintf(FILE *fp, const char *format, ...)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;reading-a-file&#34;&gt;Reading a file&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;fgetc() reads a character from the input file. he return value is the character read, or in case of any error, it returns EOF&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fgets() reads up to n-1 characters from an input stream. It copies the read string into a buffer, appending a null character to terminate the string.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fscanf reads strings from a file, but it stops reading after encountering the first space character&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;miscellaneous&#34;&gt;Miscellaneous&lt;/h2&gt;
&lt;h3 id=&#34;command-line-arguments&#34;&gt;Command-line Arguments&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;In C it is possible to accept command line arguments&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Command-line arguments are given after the name of a program&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;passed to the program by the operating system&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;The full declaration of main looks like this:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main ( int argc, char *argv[] )
#argc:number of command line arguments including the name of the program
#argv:list of all command line arguments
  #argv[0]: the program name (or an empty string)
  #argv[1] to argv[argc-1]: the actual command line arguments
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;variable-arguments&#34;&gt;Variable Arguments&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Sometimes, you would like to have a function that accept an arbitrary number of arguments&lt;/li&gt;
&lt;li&gt;for example a function that accepts any number of values and returns the average&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;the last argument is written as ellipses, i.e. three dotes (...)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;the one just before the ellipses is always an int which will represent the total number variable arguments passed&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;header-file&#34;&gt;Header file&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The header file stdarg.h provides the functions and macros to implement the functionality of variable arguments as follows&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Define a function with its last parameter as ellipses and the one just before the ellipses is always an int which will represent the number of arguments.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Create a va_list type variable in the function definition&lt;/li&gt;
&lt;li&gt;Use int parameter and va_start macro to initialize the va_list variable to an argument list&lt;/li&gt;
&lt;li&gt;Use va_arg macro and va_list variable to access each item in argument list&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use a macro va_end to clean up the memory assigned to va_list variable&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio .h&amp;gt; 
#include &amp;lt;stdarg .h&amp;gt;
double average(int num,...) { 
  va_list valist ;
	double sum = 0.0;
	inti;
	va_start(valist , num);
	for (i = 0; i &amp;lt; num; i++) {
    sum += va_arg( valist , int );
  }
	 va_end( valist );
	return sum/num;
}
int main() {
  printf(&amp;quot;Average of 2, 3, 4, 5 =%f\n&amp;quot;, average (4 , 2 ,3 ,4 ,5));
	printf(&amp;quot;Average of 5, 10, 15 =%f\n&amp;quot;, average (3 , 5 ,10 ,15));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;typedef&#34;&gt;typedef&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The typedef keyword allows the programmer to create new names for types such as int&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Typedefs can be used both to provide more clarity to your code and to make it easier to make changes to the underlying data types&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;in C, struct variables must be declared by a combination of the keyword struct and the name of the struct&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;typedef-vs-define&#34;&gt;typedef vs #define&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;#define is a &lt;strong&gt;C-directive which is also used to define the aliases for various data types similar to typedef but with the following differences:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;typedef is limited to giving symbolic names to types only where as #define can be used to define alias for values as well&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;typedef interpretation is performed by the compiler whereas #define statements are processed by the pre-processor&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;preprocessors&#34;&gt;Preprocessors&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Preprocessors are a way of making text processing with your C program before they are actually compiled&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Before the actual compilation of every C program it is passed through a Preprocessor.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;The Preprocessor looks through the program trying to find out specific instructions called Preprocessor directives that it can understand.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;All Preprocessor directives begin with the # (hash) symbol&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define Substitutes a preprocessor macro. 
#include Inserts a particular header from another file. 
#undef Undefines a preprocessor macro.
#ifdef Returns true if this macro is defined. 
#ifndef Returns true if this macro is not defined. 
#if Tests if a compile time condition is true. 
#else The alternative for #if.
#elif #else and #if in one statement.
#endif Ends preprocessor conditional.
#error Prints error message on stderr.
#pragma Issues special commands to the compiler,using a standardized method.
&lt;/code&gt;&lt;/pre&gt;
">Memory management, File IO, ...</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/pointers-in-c/"" data-c="
          &lt;h2 id=&#34;pointers&#34;&gt;Pointers&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A pointer is a variable that contains the address of a variable&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-15%2009.21.06.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int x=1, y=2, z[10];
/∗ip is a pointer to int∗/
int ∗ip;
/∗ip now points to x ∗/ 				
ip = &amp;amp;x; 	
/∗y is now 1∗/							 
y = ∗ip; 
/∗x is now0∗/								  
∗ip = 0;
/∗ x = x + 1 ∗/						     
∗ip = ∗ip + 1; 	
/∗ ip now points to z[0] ∗/				       
ip = &amp;amp;z[0];	
/∗ y = z[0] + 1 ∗/						    
y = ∗ip + 1; 					    	
++∗ip;          				        
(∗ip)++; 							
int∗iq = ip;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;pointers-to-pointers&#34;&gt;Pointers to Pointers&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-25%2010.30.53.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;pointer-arithmetic&#34;&gt;Pointer arithmetic&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;the variable pointer can be incremented&lt;/li&gt;
&lt;li&gt;the formula for computing the address of pa + i where pa has type T*:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	&lt;strong&gt;addr(pa + i) = addr(pa) + [sizeof(T) * i]&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;i is scaled according to the size of the objects pa points to, which is determined by the declaration of p&lt;/li&gt;
&lt;li&gt;If an &lt;strong&gt;int&lt;/strong&gt; is four bytes, for example, then i will be scaled by four&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;null-pointers&#34;&gt;Null Pointers&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int *ptr = NULL; /* ptr = 0*/
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;use address 0 because that memory is reserved by the OS, so &lt;strong&gt;access to address 0 is not permitted&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;can use if statement to check null pointer&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;return-pointer-from-functions&#34;&gt;Return pointer from functions&lt;/h3&gt;
&lt;p&gt;​	C allows you to return a pointer from function. It is not good to return the address of a local variable to outside of the function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/∗ if compilation failed , use gcc −ansi or gcc −std=c89 ∗/ 
#include &amp;lt;stdio .h&amp;gt;
#include &amp;lt;time.h&amp;gt;
int ∗ getRandom(){
	static int r[10];
	int i;
	srand((unsigned)time(NULL)); /∗ set the seed ∗/ 
    for (i = 0; i &amp;lt; 10; ++i)
      r[i] = rand();
  		return r;
}
int main () {
	int ∗p; int i;
	p = getRandom();
	for ( i=0; i&amp;lt;10; i++)
    printf(&amp;quot;∗(p+[%d]) :%d\n&amp;quot;, i, ∗(p+i) );
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;pointers-and-arrays&#34;&gt;Pointers and Arrays&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;In C, there is a strong relationship between pointers and arrays&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[10];
int *pa;
pa = &amp;amp;a[0]; /* pa = a*/
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-25%2011.12.31.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int x = *pa; /* same as x = a[0] */
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;the variable pointer can be incremented, but the array name cannot, because it is a &lt;strong&gt;constant pointer.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;pa + i point &lt;strong&gt;i elements after pa&lt;/strong&gt;, and &lt;strong&gt;pa - i&lt;/strong&gt; points i elements before&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-25%2011.15.19.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;The name of an array is a synonym for the location of the initial element&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;a&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;pa&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&amp;amp;a[0]&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;*a&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;*pa&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;a[0]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;a+1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pa+1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;amp;a[1]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;a+i&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;pa+i&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;amp;a[i]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;*(a+1)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;*(pa+1)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;a[1]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;*(a+i)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;*(pa+i)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;a[i]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;pointers-to-functions&#34;&gt;Pointers to Functions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;in C, it is possible to define pointers to functions&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int (*func)(int, int);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;like pointer to variables, function pointers can be assigned, placed in arrays, passed to functions, returned by functions, ...&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio .h&amp;gt;
int max (int, int);
int main ()
{
	int (∗func)(int, int);
	func = max; /∗ or func = &amp;amp;max ∗/ 
  printf(&amp;quot;%d\n&amp;quot;, func(3, 4)); 
  return 0;
}
int max(int a, int b)
{
	return a&amp;gt;b ? a : b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;pointers-to-constants-and-constant-pointers&#34;&gt;Pointers to constants and constant pointers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;constant pointer&lt;/strong&gt; is a pointer that cannot change the address its holding&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int * const ptr;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;A pointer to constant is a pointer through which we cannot change the &lt;strong&gt;value of the variable it points&lt;/strong&gt; to.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;const int * ptr;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;we could have both in one definition&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;const int * const ptr;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;strings&#34;&gt;Strings&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;string in C is actually a &lt;strong&gt;one-dimensional array&lt;/strong&gt; of characters which is terminated by a &lt;strong&gt;null character &#39;\0&#39;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;a &lt;strong&gt;null-terminated string&lt;/strong&gt; contains the character that comprise the string followed by a null&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char greeting[6] = {&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;\0&#39;};
/* same as */
char greeting[] = &amp;quot;Hello&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The C compiler automatically &lt;strong&gt;places the &#39;\0&#39; at the end of the string&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-25%2011.39.55.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;there is a difference between these definitions:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char amessage[] = &amp;quot;now is the time&amp;quot;;
char *pmessage = &amp;quot;now is the time&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Individual characters within the array may be changed but amessage will always refer to the same storage&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pmessage points to a string constant and may be modi􏰁ed to point elsewhere, but the result is unde􏰁ned if you try to modify the string contents&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-25%2011.42.28.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;string-io&#34;&gt;String IO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;reading string:
&lt;ul&gt;
&lt;li&gt;using scanf(): scanf(&amp;quot;%s&amp;quot;, str);&lt;/li&gt;
&lt;li&gt;reading it character by character using &lt;strong&gt;getchar()&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;using &lt;strong&gt;gets()&lt;/strong&gt; but it is &lt;strong&gt;unsafe and dangerous&lt;/strong&gt;, never use it. It continues reading &lt;strong&gt;until ‘\n’ or EOF&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;printing strings:
&lt;ul&gt;
&lt;li&gt;using printf(): printf(&amp;quot;%s\n&amp;quot;, str);&lt;/li&gt;
&lt;li&gt;printing it character by character using &lt;strong&gt;putchar()&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;using &lt;strong&gt;puts(str)&lt;/strong&gt; to print the entire string&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;structures&#34;&gt;Structures&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;structure is a user de􏰁ned data type that allows to combine data items of different kinds&lt;/li&gt;
&lt;li&gt;used to represent a record&lt;/li&gt;
&lt;li&gt;format of the struct statements:&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-25%2011.45.47.png&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;ul&gt;
&lt;li&gt;to access member of a structure, use .&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;structures-as-function-arguments&#34;&gt;Structures as Function Arguments&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio .h&amp;gt;
#include &amp;lt;string .h&amp;gt;
struct Books { ... };
void printBook(struct Books book);
int main( ) {
	struct
	...
	printBook ( book1 ) ;
	return 0;
}
void printBook(struct Books book){
	printf( &amp;quot;title : %s\n&amp;quot;, book. title );
	printf( &amp;quot;author : %s\n&amp;quot;, book.author);
	printf( &amp;quot;book_id : %d\n&amp;quot;, book.book_id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;can pass a structure to a function as a pointer&lt;/li&gt;
&lt;li&gt;use &lt;strong&gt;-&amp;gt;&lt;/strong&gt; to access the members&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bit-fields&#34;&gt;Bit Fields&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Bit Fields allow the packing of data in a structure. This is especially useful when memory or data storage is at a premium&lt;/li&gt;
&lt;li&gt;Typical examples include:
&lt;ul&gt;
&lt;li&gt;Packing several objects into a machine word. e.g. 1 bit 􏰂ags can be compacted&lt;/li&gt;
&lt;li&gt;Reading external (non-standard) 􏰁le formats, e.g., 9-bit integers&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;unions&#34;&gt;Unions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;union is a special data type available in C that enables you to &lt;strong&gt;store different data types&lt;/strong&gt; in the same memory location&lt;/li&gt;
&lt;li&gt;define a union with many members, but only one member can contain a value at any given time&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;union Data {
	int i;
	float f;
	char str[20];
} data;
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-25%2011.52.44.png&#34; style=&#34;zoom:50%;&#34; /&gt;
">Pointers in C</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/web-and-cloud-app-development/"" data-c="
          &lt;h2 id=&#34;web-app-architecture&#34;&gt;Web App Architecture&lt;/h2&gt;
&lt;h3 id=&#34;web-frameworks-pros-cons&#34;&gt;Web Frameworks – Pros &amp;amp; Cons&lt;/h3&gt;
&lt;h4 id=&#34;pros&#34;&gt;Pros&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Saves time, makes development process going faster&lt;/li&gt;
&lt;li&gt;Ease of maintenance&lt;/li&gt;
&lt;li&gt;Security&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;cons&#34;&gt;Cons&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Every framework has its limits and rules&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;examples-of-full-stack-js-web-frameworks&#34;&gt;Examples of Full-stack JS Web Frameworks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MEAN stack&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MERN stack&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hosting-websites&#34;&gt;Hosting websites&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;First, a web server has to store the website&#39;s files, namely all HTML documents and their related assets, including images, CSS stylesheets, JavaScript files, fonts, and video.
&lt;ul&gt;
&lt;li&gt;A dedicated web server is typically more available.&lt;/li&gt;
&lt;li&gt;A dedicated web server is always connected to the Internet.&lt;/li&gt;
&lt;li&gt;A dedicated web server is typically maintained by a third-party.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http-methodsverbs&#34;&gt;HTTP Methods/Verbs&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;GET: Get a specific resource (e.g. an HTML file containing information about a product, or a list of products).&lt;/li&gt;
&lt;li&gt;POST: Create a new resource (e.g. add a new article to a wiki, add a new contact to a database).&lt;/li&gt;
&lt;li&gt;HEAD: Get the metadata information about a specific resource without getting the body like GET would.&lt;/li&gt;
&lt;li&gt;PUT: Update an existing resource&lt;/li&gt;
&lt;li&gt;DELETE: Delete the specified resource.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;static-sites&#34;&gt;Static Sites&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-09%2016.19.42.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​	The server for a static site will only ever need to process GET requests, because the server doesn&#39;t store any modifiable data. It also doesn&#39;t change its responses based on HTTP Request data (e.g., URL parameters or cookies).&lt;/p&gt;
&lt;h3 id=&#34;dynamic-sites&#34;&gt;Dynamic sites&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-09%2016.21.59.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;single-page-applications&#34;&gt;Single Page Applications&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A web application or web site that interacts with the user by dynamically rewriting the current page rather than loading &lt;strong&gt;entire new pages&lt;/strong&gt; from a server.&lt;/li&gt;
&lt;li&gt;JavaScript frameworks, such as &lt;strong&gt;Angular, Ember.js, Knockout.js, Meteor.js, ExtJS, Vue.js and React&lt;/strong&gt; have adopted SPA principles.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;single-page-vs-traditional-web-apps&#34;&gt;Single Page VS Traditional Web Apps&lt;/h3&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-09%2016.25.28.png&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h2 id=&#34;intro-to-html&#34;&gt;Intro to HTML&lt;/h2&gt;
&lt;h3 id=&#34;uniform-resource-locators-url&#34;&gt;Uniform Resource Locators (URL)&lt;/h3&gt;
&lt;p&gt;​	In order to allow clients to request different resources from the server, a naming mechanism is required so that the client knows how to ask the server for the file.&lt;/p&gt;
&lt;h3 id=&#34;html-syntax&#34;&gt;HTML Syntax&lt;/h3&gt;
&lt;h4 id=&#34;elements-and-attributes&#34;&gt;Elements and Attributes&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;HTML element encompasses
&lt;ul&gt;
&lt;li&gt;the element name within angle brackets&lt;/li&gt;
&lt;li&gt;HTML elements can also contain &lt;strong&gt;attributes.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-09%2016.30.27.png&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h4 id=&#34;basic-use&#34;&gt;Basic use&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Insert images using the &lt;strong&gt;&lt;img&gt;&lt;/strong&gt; tag&lt;/li&gt;
&lt;li&gt;Create links with the &lt;strong&gt;&lt;a&gt;&lt;/strong&gt; tag&lt;/li&gt;
&lt;li&gt;Create lists with the &lt;strong&gt;&lt;ul&gt;, &lt;ol&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;li&gt;&lt;/strong&gt; tags&lt;/li&gt;
&lt;li&gt;Create headings with &lt;strong&gt;&lt;H1&gt;, &lt;H2&gt;, ..., &lt;H6&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Define metadata with &lt;strong&gt;&lt;meta&gt;&lt;/strong&gt; tag&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;sample-html-document&#34;&gt;Sample HTML Document&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-09%2016.33.33.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Headings&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	HTML provides six levels of heading (&lt;strong&gt;h1-h6&lt;/strong&gt;), with the higher heading number indicating a heading of less importance.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Paragraphs&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	Notice that the &lt;p&gt; tag is a container and can contain HTML and other inline HTML elements&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Divisions&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This &lt;div&gt; tag is also a container element and is used to create a logical grouping of content&lt;/li&gt;
&lt;li&gt;has no intrinsic presentation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Links&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Links use the &lt;a&gt; element (the “a” stands for anchor).&lt;/li&gt;
&lt;li&gt;A link has two main parts: the destination and the label.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a href=&amp;quot;http://www.somewhere.com&amp;quot;&amp;gt;Photo&amp;lt;/a&amp;gt;
&amp;lt;!-- Same directory--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;url-relative-referencing&#34;&gt;URL Relative Referencing&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-09%2016.41.21.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;main-article-section&#34;&gt;Main, article, section&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;main&lt;/strong&gt;&lt;/em&gt; is meant to contain the main unique content of the document.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;main&lt;/strong&gt;&lt;/em&gt; provides a semantic replacement for markup such as &lt;div id=&#34;main&#34;&gt; or &lt;div id=&#34;main-content&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;section&lt;/strong&gt;&lt;/em&gt; is a much broader element, while the&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;article&lt;/strong&gt;&lt;/em&gt; element is to be used for blocks of content that could potentially be read or consumed independently of the other content on the page&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;intro-to-css&#34;&gt;Intro to CSS&lt;/h2&gt;
">Web & Cloud App Development</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/x86_64-assembler/"" data-c="
          &lt;h3 id=&#34;register-names&#34;&gt;Register Names&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;64-bit register&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;32-bit sub-register&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;16-bit sub-register&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;strong&gt;8-bit sub-register&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%rax&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%eax&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%ax&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%al&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%rbx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%ebx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%bx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%bl&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%rcx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%ecx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%cx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%cl&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%rdx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%edx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%dx&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%dl&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%rsi&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%esi&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%si&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%sil&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%rdi&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%edi&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%di&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%dil&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%rbp&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%ebp&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%bp&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%bpl&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%rsp&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%esp&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%sp&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%spl&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r8d&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r8w&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r8b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r9&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r9d&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r9w&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r9b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r10&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r10d&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r10w&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r10b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r11&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r11d&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r11w&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r11b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r12&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r12d&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r12w&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r12b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r13&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r13d&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r13w&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r13b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r14&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r14d&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r14w&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r14b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r15&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r15d&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r15w&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%r15b&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;architecture-byte-order&#34;&gt;&lt;strong&gt;architecture: byte order&lt;/strong&gt;&lt;/h3&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-10%2015.16.45.png&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h3 id=&#34;references-to-memory&#34;&gt;references to memory&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-16(%rsp)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;8(%rbp)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;127(%rip)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;relative-addressing&#34;&gt;&lt;strong&gt;relative addressing&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;syntax: disp(base,index,scale) -&amp;gt; base + index*scale +disp
eg: -3(%rbp,%rdi,8)
;typically used to access %rbp[%rdi] where each array element is 8 bytes long and you’re 
;accessing at -3 bytes from it
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;addressing-modes&#34;&gt;addressing modes&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;;immediate:
mov $10, %eax
;register to register
mov %r8l, %al
;indirect
mov 1234(%rcx,%rax,8), %r8w
;it sometime is necessary to add a size postfix to instructions: movb, movw, movl, movq (b = byte, w = word, l = long, q = quadword)
;rip-relative:
movb 12(%rip), %al
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;a-simple-example&#34;&gt;a simple example&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;sum numbers 1 to 10 in register %eax&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;	xor %eax, %eax	# zero %eax – why not “mov $0, %eax” ?
	mov $10, %ecx 	# set the loop index
lab:
	add %ecx, %eax  # %eax += %ecx
	loop lab				# dec %ecx, jump to lab if not zero
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;common-instruction&#34;&gt;common instruction&lt;/h3&gt;
&lt;h4 id=&#34;mov&#34;&gt;&lt;strong&gt;MOV&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;movl $1, 0x604892    		#direct (address is constant value)
movl $1, (%rax)			 		#indirect (address is in register %rax)
movl $1, -24(%rbp)	 		#address = base(%rbp) + displacement(-24)
movl $1, 8(%rsp,%rdi,4) #address = %rsp + 8 + %rdi*4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;mov-v-lea&#34;&gt;MOV V LEA&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;mov d(b,i,s), %rax is like rax = *(b+s*i+d)
lea d(b,i,s), %rax is like rax = (b+s*i+d)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;cmov&#34;&gt;CMOV&lt;/h4&gt;
&lt;p&gt;**CMOVcc instructions can replace two instructions in situations like **&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;quot;if ecx == 5 then eax = ebx”&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;    cmp $5, %ecx
    jnz continue
    mov %ebx, %eax
continue:
;it equals to 
	cmp $5, %ecx
    cmovz %ebx, %eax
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;push-and-pop&#34;&gt;&lt;strong&gt;push and pop&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;push &amp;lt;src&amp;gt; is like dec %rsp; mov &amp;lt;src&amp;gt;,(%rsp) 
pop &amp;lt;dst&amp;gt; is like mov (%rsp),&amp;lt;dst&amp;gt;; inc %rsp
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;compile-and-link-the-files&#34;&gt;compile and link the files&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;testmax3.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;inttypes.h&amp;gt;

int64_t maxofthree(int64_t, int64_t, int64_t);

int main() {
    printf(&amp;quot;%ld\n&amp;quot;, maxofthree(1, -4, -7));
    printf(&amp;quot;%ld\n&amp;quot;, maxofthree(2, -6, 1));
    printf(&amp;quot;%ld\n&amp;quot;, maxofthree(2, 3, 1));
    printf(&amp;quot;%ld\n&amp;quot;, maxofthree(-2, 4, 3));
    printf(&amp;quot;%ld\n&amp;quot;, maxofthree(2, -6, 5));
    printf(&amp;quot;%ld\n&amp;quot;, maxofthree(2, 4, 6));
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;max3.s&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;        .globl  _maxofthree
        
        .text
_maxofthree:
        mov     %rdi, %rax              # result (rax) initially holds x
        cmp     %rsi, %rax              # is x less than y?
        cmovl   %rsi, %rax              # if so, set result to y
        cmp     %rdx, %rax              # is max(x,y) less than z?
        cmovl   %rdx, %rax              # if so, set result to z
        ret                
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;complie and link&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clang -o result testmax3.c max3.s 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;then execute the result file&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/20220210164141.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;calling-conventions&#34;&gt;calling conventions&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Register&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Convention&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;%rip&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Instruction pointer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;%rsp&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Stack pointer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;%rax&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Return value&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;%rdi&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1st argument&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;%rsi&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2nd argument&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;%rdx&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3rd argument&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;%rcx&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4th argument&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;%r8&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5th argument&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;%r9&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6th argument&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;%r10,%r11&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Callee-owned&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;%rbx,%rbp,%r12-%15&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Caller-owned&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">x86_64 Assembler</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/software-security/"" data-c="
          &lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;
&lt;h3 id=&#34;risks&#34;&gt;Risks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Service and data unavailability&lt;/li&gt;
&lt;li&gt;Data leaks (client list, industrial secret, business plans, e-mail...)&lt;/li&gt;
&lt;li&gt;Bank fraud, credit cards stolen ...&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;consequences&#34;&gt;Consequences&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Companies: losing money (stock market value)&lt;/li&gt;
&lt;li&gt;Services (water, electricity ...)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vulnerabilities&#34;&gt;Vulnerabilities&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Vulnerabilities in physical systems&lt;/li&gt;
&lt;li&gt;Vulnerabilities in infrastructures as networking systems&lt;/li&gt;
&lt;li&gt;Vulnerabilities in Operative Systems&lt;/li&gt;
&lt;li&gt;Vulnerabilities in Software&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cia-triad&#34;&gt;CIA Triad&lt;/h3&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-08%2016.24.38.png&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;h4 id=&#34;simple-example&#34;&gt;Simple Example&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main (int args, char** argv) {
		char buffer[500];
		strcpy(buffer,argv[1]);
		return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;this program copy argv in a buffer&lt;/li&gt;
&lt;li&gt;this program can do &lt;strong&gt;everything&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;severe-vulnerability&#34;&gt;Severe Vulnerability&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Why? Because this program has a severe &lt;strong&gt;buffer overflow vulnerability&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Buffer Overflow&lt;/strong&gt; is a situation&lt;/li&gt;
&lt;li&gt;wherewecanaccidentallyoverflowabuffer meant to manipulate data and overwrite arbitrary memory addresses&lt;/li&gt;
&lt;li&gt;Overwritinglatermemoryaddresseswecancausemanykindsofproblems, including executing arbitrary code&lt;/li&gt;
&lt;li&gt;Wecanexploitthismaliciouslytoperformanattack,e.g.byoverwritingthe original program’s code with our own code&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vulnerability-threats-and-risk&#34;&gt;Vulnerability, Threats and Risk&lt;/h3&gt;
&lt;h4 id=&#34;vulnerability&#34;&gt;Vulnerability&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;weakness in the system&lt;/li&gt;
&lt;li&gt;Internal factor&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;threat&#34;&gt;Threat&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;condition that can cause harm&lt;/li&gt;
&lt;li&gt;External factor&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;risk&#34;&gt;Risk&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Likelihood of the realisation of a threat&lt;/li&gt;
&lt;li&gt;Vulnerability without a threat = &lt;strong&gt;no risk&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;hreat without a vulnerability = &lt;strong&gt;no risk&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cvecvsscwe&#34;&gt;CVE/CVSS/CWE&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;In 1999 MITRE (no-profit company) introduced an official uniform catalogue of vulnerabilities&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cve.mitre.org/&#34;&gt;CVE&lt;/a&gt; – Common Vulnerabilities and Exposures&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nvd.nist.gov/vuln-metrics/cvss&#34;&gt;CVSS&lt;/a&gt; – Common Vulnerability Scoring System&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cwe.mitre.org&#34;&gt;CWE&lt;/a&gt; – Common Weakness Enumeration&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;low-level-programming-languages-c&#34;&gt;Low-level Programming Languages &amp;amp; C&lt;/h2&gt;
&lt;h3 id=&#34;c-memory-layout&#34;&gt;C memory layout&lt;/h3&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/20220208163923.png&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int main (int args, char** argv) {
		char buffer[500];
		strcpy(buffer,argv[1]);
		return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Use this code for an example&lt;/li&gt;
&lt;li&gt;What happens if put 508 bytes&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/20220208164132.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​	&lt;strong&gt;On re-entry, the code will try to jump back to a possibly illegal address, causing a so-called “&lt;em&gt;Segmentation Fault&lt;/em&gt;” and a crash, a total system failure.&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;we-can-be-more-evil&#34;&gt;we can be more evil&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;executeanarbitrarycodelike A shell, a malware, etc.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Which of course gives me a lot of control over the machine, and sends all the CIA properties packing...&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;low-level-v-high-level-languages&#34;&gt;&lt;strong&gt;Low-level v High-level languages&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;High-level are more “programmer” friendly&lt;/li&gt;
&lt;li&gt;Low-level languages are difficult to understand, read and code&lt;/li&gt;
&lt;li&gt;Machine Code is impossible to read&lt;/li&gt;
&lt;li&gt;C is the language of all software libraries, so the foundation of our current software stacks&lt;/li&gt;
&lt;li&gt;Assembly can be used for analysis of decompiled code&lt;/li&gt;
&lt;/ul&gt;
">Software Security</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/functions-memory-layout-stack-and-arrays/"" data-c="
          &lt;h3 id=&#34;definging-functions&#34;&gt;Definging Functions&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;return_type function_name (parameter list)
{
				body of the function
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The return_type is the type the function returns&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Some functions do not return values, in this case void is used&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The function name and the parameter list together constitute the function signature&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;a function may contain no parameters&lt;/li&gt;
&lt;li&gt;The function body contains a collection of statements that define what the function does&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;call-by-value&#34;&gt;call by value&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;call by value&lt;/strong&gt; method of passing arguments to a function copies the actual value of an argument into the formal parameter of the function&lt;/li&gt;
&lt;li&gt;changes made to the parameters inside the function have no effect on the arguments&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void swap (int x, int y);
int main (){
		int a = 100, b = 20;
		printf(&amp;quot;Before swap, value of a : %d\n&amp;quot;, a);
		printf(&amp;quot;Before swap, value of b : %d\n&amp;quot;, b);
		swap(a,b);
		printf(&amp;quot;After swap, value of a : %d\n&amp;quot;, a ); 
		printf(&amp;quot;After swap, value of b : %d\n&amp;quot;, b );
		return 0;
}
void swap (int x, int y) {
		int temp = x;
		x = y;
		y = temp;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;call-by-reference&#34;&gt;call by reference&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;call by reference&lt;/strong&gt; method of passing arguments to a function copies the address of an argument into the formal parameter&lt;/li&gt;
&lt;li&gt;Inside the function, the address is used to access the actual argument used in the call
&lt;ul&gt;
&lt;li&gt;changes made to the parameter affect the passed argument&lt;/li&gt;
&lt;li&gt;To pass by reference, argument pointers are passed to the functions just&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;the function parameters need to be declared as &lt;strong&gt;pointer&lt;/strong&gt; types&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void swap (int *x, int *y);
int main (){
		int a = 100, b = 20;
		printf(&amp;quot;Before swap, value of a : %d\n&amp;quot;, a);
		printf(&amp;quot;Before swap, value of b : %d\n&amp;quot;, b);
		swap(&amp;amp;a,&amp;amp;b);
		printf(&amp;quot;After swap, value of a : %d\n&amp;quot;, a ); 
		printf(&amp;quot;After swap, value of b : %d\n&amp;quot;, b );
		return 0;
}
void swap (int *x, int *y) {
		int temp = *x;
		*x = *y;
		*y = temp;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;memory-layout-stack&#34;&gt;Memory Layout - Stack&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/20220208121904.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;The stack segment is the area where local variables are stored
&lt;ul&gt;
&lt;li&gt;local variable are declared in every function including main() in C program&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;When we call any function a &lt;strong&gt;stack frame&lt;/strong&gt; is created&lt;/li&gt;
&lt;li&gt;function returns, stack frame is destroyed including all local variables of that particular function&lt;/li&gt;
&lt;li&gt;Stack frame contain some data like &lt;strong&gt;return address&lt;/strong&gt;, arguments passed to the function, local variables,. . .&lt;/li&gt;
&lt;li&gt;A “stack pointer (SP)” keeps track of stack by each push and pop operation onto it&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-08%2012.22.43.png&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-08%2012.23.03.png&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h3 id=&#34;arrays&#34;&gt;Arrays&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Array a fixed-size sequential collection of elements of the same type&lt;/li&gt;
&lt;li&gt;An array is used to store a collection of data of the same type&lt;/li&gt;
&lt;li&gt;All arrays consist of contiguous memory locations
&lt;ul&gt;
&lt;li&gt;The lowest address corresponds to the first element and the highest address to the last element&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Declaring arrays&lt;/strong&gt;: double balance[10];&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;initialingzing-arrays&#34;&gt;Initialingzing arrays:&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;we-can-ommit-the-size&#34;&gt;we can ommit the size:&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;double balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;accessing-an-array&#34;&gt;Accessing an array:&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;balance[4] = 50.0;
double salary = balance[3];
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;two-dimensional-arrays&#34;&gt;Two-dimensional Arrays&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The simplest form of multidimensional array is the two-dimensional array&lt;/li&gt;
&lt;li&gt;A two-dimensional array is an array of one-dimensional arrays&lt;/li&gt;
&lt;li&gt;Declaring 2D arrays:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[3][4];
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Initializing 2D arrays:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[3][4] = {
		{0, 1, 2, 3} ,
		{4, 5, 6, 7} , {8, 9, 10, 11}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;three-ways-to-pass-an-array-to-functions&#34;&gt;three ways to pass an array to functions&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;as a pointer:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void myFunction(int *param) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;as a sized array:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void myFunction(int param[10]) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;as a unsized array:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void myFunction(int param[]) {...}
&lt;/code&gt;&lt;/pre&gt;
">Functions, Memory Layout - stack, and Arrays</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/redis-fen-bu-shi-suo/"" data-c="
          &lt;h3 id=&#34;分布式锁&#34;&gt;分布式锁&lt;/h3&gt;
&lt;p&gt;​	分布式应用进行逻辑处理时经常会遇到并发问题, 比如一个操作要修改用户的状态，修改状态需要先读出用户的状态，在内存里进行修 改，改完了再存回去。如果这样的操作同时进行了，就会出现并发问题，因为读取和保存状态这两个操作不是原子的。(Wiki 解释:所谓原子操作是指不会被线程调度机制打断的操作;这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch 线程切换。)&lt;/p&gt;
&lt;h3 id=&#34;本质&#34;&gt;本质&lt;/h3&gt;
&lt;p&gt;​	分布式锁本质上要实现的目标就是在 Redis 里面使用 setnx(set if not exists) 指令占位，当别的进程也要来占位时，发现已经被他人捷足先登，就只好放弃或者稍后再试。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; setnx lock true
OK
... critial section ...
&amp;gt; del lock
(Integer) 1 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	但是有个问题，如果逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样 就会陷入死锁，锁永远得不到释放。&lt;/p&gt;
&lt;p&gt;​	于是我们在拿到锁之后，再给锁加上一个过期时间，比如 5s，这样即使中间出现异常也 可以保证 5 秒之后锁会自动释放。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; setnx lock true
OK
&amp;gt; expire lock 5
... critial section ...
&amp;gt; del lock
(Integer) 1 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	但是以上逻辑还有问题。如果在 setnx 和 expire 之间服务器进程突然挂掉了，可能是因 为机器掉电或者是被人为杀掉的，就会导致 expire 得不到执行，也会造成死锁。&lt;/p&gt;
&lt;p&gt;​	为了治理这个乱象，Redis 2.8 版本中作者加入了 set 指令的扩展参数，使得 setnx 和 expire 指令可以一起执行，彻底解决了分布式锁的乱象。从此以后所有的第三方分布式锁 library 可以休息了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; set lock true ex 5 nx 
OK 
... do something critical ...
 &amp;gt; del lock
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	上面这个指令就是 setnx 和 expire 组合在一起的原子指令，它就是分布式锁的奥义所在。&lt;/p&gt;
&lt;h3 id=&#34;超时问题&#34;&gt;超时问题&lt;/h3&gt;
&lt;p&gt;​	Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至 于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁， 但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻 辑执行完之间拿到了锁。&lt;/p&gt;
&lt;p&gt;​	为了避免这个问题，Redis 分布式锁不要用于较长时间的任务。如果真的偶尔出现了，数 据出现的小波错乱可能需要人工介入解决。&lt;/p&gt;
&lt;h3 id=&#34;可重入性&#34;&gt;可重入性&lt;/h3&gt;
&lt;p&gt;​	可重入性是指线程在持有锁的情况下再次请求加锁，如果一个锁支持同一个线程的多次加锁，那么这个锁就是可重入的。比如 Java 语言里有个 ReentrantLock 就是可重入锁。Redis 分布式锁如果要支持可重入，需要对客户端的 set 方法进行包装，使用线程的 Threadlocal 变量存储当前持有锁的计数。&lt;/p&gt;
">Redis 分布式锁</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/redis-ji-chu-shu-ju-jie-gou/"" data-c="
          &lt;h3 id=&#34;redis-基础数据结构&#34;&gt;Redis 基础数据结构&lt;/h3&gt;
&lt;p&gt;​	Redis 有 5 种基础数据结构，分别为:string (字符串)、list (列表)、set (集合)、hash (哈希) 和 zset (有序集合)。&lt;/p&gt;
&lt;h4 id=&#34;string-字符串&#34;&gt;string (字符串)&lt;/h4&gt;
&lt;p&gt;​	字符串 string 是 Redis 最简单的数据结构。Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据。不同类型的数据结构的差异就在于 value 的结构不一样。&lt;/p&gt;
&lt;p&gt;​	Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。当字符串长度小于 1M 时， 扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。&lt;/p&gt;
&lt;h5 id=&#34;过期和-set-命令扩展&#34;&gt;过期和 set 命令扩展&lt;/h5&gt;
&lt;p&gt;可以对 key 设置过期时间，到点自动删除，这个功能常用来控制缓存的失效时间。&lt;/p&gt;
&lt;h5 id=&#34;计数&#34;&gt;计数&lt;/h5&gt;
&lt;p&gt;如果 value 值是一个整数，还可以对它进行自增操作。自增是有范围的，它的范围是 signed long 的最大最小值，超过了这个值，Redis 会报错。字符串是由多个字节组成，每个字节又是由 8 个 bit 组成，如此便可以将一个字符串看成很多 bit 的组合，这便是 bitmap「位图」数据结构。&lt;/p&gt;
&lt;h4 id=&#34;list-列表&#34;&gt;list (列表)&lt;/h4&gt;
&lt;p&gt;​	Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。&lt;/p&gt;
&lt;h5 id=&#34;快速列表&#34;&gt;快速列表&lt;/h5&gt;
&lt;p&gt;​	首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的 时候才会改成 quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且 会加重内存的碎片化。比如这个列表里存的只是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next 。所以 Redis 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空 间冗余。&lt;/p&gt;
&lt;h4 id=&#34;hash-字典&#34;&gt;hash (字典)&lt;/h4&gt;
&lt;p&gt;​	Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞 时，就会将碰撞的元素使用链表串接起来。&lt;/p&gt;
&lt;h4 id=&#34;set-集合&#34;&gt;set (集合)&lt;/h4&gt;
&lt;p&gt;​	Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。&lt;/p&gt;
&lt;p&gt;​	当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。set 结构可以用来 存储活动中奖的用户 ID，因为有去重功能，可以保证同一个用户不会中奖两次。&lt;/p&gt;
&lt;h4 id=&#34;zset-有序列表&#34;&gt;zset (有序列表)&lt;/h4&gt;
&lt;p&gt;​	它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。&lt;/p&gt;
&lt;p&gt;​	zset 可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们 可以对成绩按分数进行排序就可以得到他的名次。&lt;/p&gt;
&lt;h3 id=&#34;容器型数据结构的通用规则&#34;&gt;容器型数据结构的通用规则&lt;/h3&gt;
&lt;p&gt;list/set/hash/zset 这四种数据结构是容器型数据结构，它们共享下面两条通用规则:&lt;/p&gt;
&lt;h5 id=&#34;1-create-if-not-exists&#34;&gt;1、create if not exists&lt;/h5&gt;
&lt;p&gt;​	如果容器不存在，那就创建一个，再进行操作。比如 rpush 操作刚开始是没有列表的，&lt;/p&gt;
&lt;p&gt;Redis 就会自动创建一个，然后再 rpush 进去新元素。&lt;/p&gt;
&lt;h5 id=&#34;2-drop-if-no-elements&#34;&gt;2、drop if no elements&lt;/h5&gt;
&lt;p&gt;​	如果容器里元素没有了，那么立即删除元素，释放内存。这意味着 lpop 操作到最后一&lt;/p&gt;
&lt;p&gt;个元素，列表就消失了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过期时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	Redis 所有的数据结构都可以设置过期时间，时间到了，Redis 会自动删除相应的对象。 需要注意的是过期是以对象为单位，比如一个 hash 结构的过期是整个 hash 对象的过期， 而不是其中的某个子 key。&lt;/p&gt;
&lt;p&gt;​	还有一个需要特别注意的地方是如果一个字符串已经设置了过期时间，然后你调用了&lt;/p&gt;
&lt;p&gt;set 方法修改了它，它的过期时间会消失。&lt;/p&gt;
">Redis基础数据结构</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/shi-yong-springboot-gou-jian-ding-shi-ren-wu/"" data-c="
          &lt;p&gt;在新闻系统中，我需要网站具备用户定时发布文章的功能，因此考虑使用SpringBoot自带的注解来实现。具体实现思路是，使SpringBoot定时扫描数据库，当发现文章表中，&lt;strong&gt;publish_time&lt;/strong&gt;属性小于当前时间，则更改文章预约发布状态至立即发布。&lt;/p&gt;
&lt;h3 id=&#34;创建定时任务&#34;&gt;创建定时任务&lt;/h3&gt;
&lt;p&gt;在本项目中，创建定时任务类，启动**@EnableScheduling**注解，开启对定时任务的支持。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 文章发布定时任务
 */
@Configuration      //1.标记配置类，使springboot扫描
@EnableScheduling   //2.开启定时任务
public class TaskPublishArticles {
    @Autowired
    private ArticleService articleService;
    //添加定时任务，和其执行任务表达式
    @Scheduled(cron = &amp;quot;0/3 * * * * ？*&amp;quot;)
    private void publishArticles () {
        //System.out.println(&amp;quot;----test----&amp;quot;+ LocalDateTime.now());
        //调用自定义文章service，将当前时间该发布的文章类型，改为即时发布
        articleService.updateAppointTopublish();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;strong&gt;@EnableScheduling&lt;/strong&gt;注解的作用是发现注解**@Scheduled**的任务并后台执行。&lt;/p&gt;
&lt;h4 id=&#34;cron表达式&#34;&gt;cron表达式&lt;/h4&gt;
&lt;p&gt;在注解**@Scheduled**中，需要配置cron表达式来进行任务时间的设定。cron源码中解释了cron各个位置的数值所代表的含义。为了更容易编码，推荐使用如下网站生产cron表达式：&lt;a href=&#34;https://www.freeformatter.com/cron-expression-generator-quartz.html&#34;&gt;Cron&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	/**
	 * A cron-like expression, extending the usual UN*X definition to include triggers
	 * on the second, minute, hour, day of month, month, and day of week.
	 * &amp;lt;p&amp;gt;For example, {@code &amp;quot;0 * * * * MON-FRI&amp;quot;} means once per minute on weekdays
	 * (at the top of the minute - the 0th second).
	 * &amp;lt;p&amp;gt;The fields read from left to right are interpreted as follows.
	 * &amp;lt;ul&amp;gt;
	 * &amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;
	 * &amp;lt;li&amp;gt;minute&amp;lt;/li&amp;gt;
	 * &amp;lt;li&amp;gt;hour&amp;lt;/li&amp;gt;
	 * &amp;lt;li&amp;gt;day of month&amp;lt;/li&amp;gt;
	 * &amp;lt;li&amp;gt;month&amp;lt;/li&amp;gt;
	 * &amp;lt;li&amp;gt;day of week&amp;lt;/li&amp;gt;
	 * &amp;lt;/ul&amp;gt;
	 * &amp;lt;p&amp;gt;The special value {@link #CRON_DISABLED &amp;quot;-&amp;quot;} indicates a disabled cron
	 * trigger, primarily meant for externally specified values resolved by a
	 * &amp;lt;code&amp;gt;${...}&amp;lt;/code&amp;gt; placeholder.
	 * @return an expression that can be parsed to a cron schedule
	 * @see org.springframework.scheduling.support.CronSequenceGenerator
	 */
	String cron() default &amp;quot;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;实现定时发布&#34;&gt;实现定时发布&lt;/h3&gt;
&lt;p&gt;为了实现该操作，需要自己写mapper.xml文件，同时继承自定义的mapper.java类。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;update id=&amp;quot;updateAppointToPublish&amp;quot;&amp;gt;
update
    article
set
    is_appoint = 0
where
    publish_time &amp;amp;lt;= NOW()
and
    is_appoint = 1
&amp;lt;/update&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;优化&#34;&gt;优化&lt;/h3&gt;
&lt;p&gt;使用该方法实现的定时发布功能，在大流量的情况下会对数据库造成巨大压力，因此可以进一步优化。可以考虑加入消息队列。&lt;/p&gt;
">使用SpringBoot构建定时任务</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/soft-model-tool-and-tech-critcal-system-zong-jie/"" data-c="
          &lt;h4 id=&#34;problem-statement-for-the-given-brief-issue-questions&#34;&gt;Problem statement for the given brief issue questions&lt;/h4&gt;
&lt;p&gt;Problem statement should contain 5W (when = when the issue occurs, where=where the issue occurs, why=why this is important, what=what is the issue, and who=who does the problem affect)&lt;/p&gt;
&lt;h4 id=&#34;writing-functional-and-non-functional-requirements-for-the-given-brief-issue-questions-writing-use-case-diagram-for-the-given-brief-issue-questions&#34;&gt;Writing functional and non-functional requirements for the given brief issue questions. Writing Use Case diagram for the given brief issue questions.&lt;/h4&gt;
&lt;p&gt;Tips: summary of using the arrows of Use Case Diagram&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/20220130231947.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;be aware of arrow pointing of the include (arrow point to sub-activity that been include) and extent (arrow point to main-activity)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;example-use-case-diagram&#34;&gt;example Use Case diagram&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/20220130232041.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;design-system-architecture-eg-class-diagram-package-diagram-mvc-pattern-for-the-given-brief-issue-questions&#34;&gt;Design system architecture (e.g. Class diagram, Package diagram, MVC pattern) for the given brief issue questions.&lt;/h5&gt;
&lt;h5 id=&#34;class-diagram&#34;&gt;Class diagram:&lt;/h5&gt;
&lt;p&gt;Tip: Summary of using arrow&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/20220130232138.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;example-class-diagram&#34;&gt;Example Class diagram&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/20220130232207.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;sequence-diagram-uml&#34;&gt;Sequence Diagram (UML):&lt;/h4&gt;
&lt;p&gt;Tip: Summary of using arrow&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/20220130232238.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/20220130232250.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;what-are-design-patterns-and-architecture-patterns&#34;&gt;What are design patterns and architecture patterns:&lt;/h4&gt;
&lt;p&gt;Architecture pattern is a description of component and connector types and a pattern of their runtime control and/or data transfer. Example of architecture pattern:  &lt;em&gt;&lt;the exam previous year asking which pattern will be adopted to use and clarify&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Model-View-Controller (MVC): having three logical components&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	o  Model component - manage system data and associate operation.&lt;/p&gt;
&lt;p&gt;​	o  View component – how data is present to user&lt;/p&gt;
&lt;p&gt;​	o  Controller component – manage user interaction&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Repository Pattern: managed in a central repository that is accessible to all system components. Components not interact directly with others but only through the repository.&lt;/li&gt;
&lt;li&gt;Client-Server Pattern: system is organized into services, with each service delivered from a separate server.&lt;/li&gt;
&lt;li&gt;Microservice Architecture Pattern: building a small independent application that communicates with each other for the entire system.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Design pattern is a description of the problem and the essence of its solution. There are 4 essential elements (Pattern name, Problem description, Solution description, Consequences) Example of design pattern:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Adapter Pattern (Structural: how class and object are composed to form larger structure) : When an exiting class performs the service that client needs but has different method name. Adater pattern can be applied.&lt;/li&gt;
&lt;li&gt;Observe Pattern (Behavioral: the way of class and object interact. Communication between classes) : defined one to many, dependency between objects so that when one object change state, all will be updated automatically. (trigger)&lt;/li&gt;
&lt;li&gt;Composite Pattern (Structural: how class and object are composed to form larger structure) : represent part, hierarchies of objects.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;what-is-a-wireframe-and-what-is-it-useful-for&#34;&gt;What is a Wireframe and what is it useful for&lt;/h4&gt;
&lt;p&gt;Wire Frame is a tool in any screen design process. It’s a schematic produced display where all of agreed features and functions within the web site specifications will appear. It is a Blueprint for layout, text and image placement.&lt;/p&gt;
&lt;p&gt;The main purpose of using Wirefram is they are very cost effective, in that they save time further down line within project&lt;/p&gt;
&lt;h4 id=&#34;other-useful-stuff&#34;&gt;Other useful stuff&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Critical system&lt;/strong&gt;: when the system failure it may have serious consequences.eg. People die if it failed (medical device).&lt;/p&gt;
&lt;p&gt;Meaning of the words&lt;br&gt;
&lt;strong&gt;Boundaries&lt;/strong&gt; - Which problem needs to be solved?&lt;br&gt;
&lt;strong&gt;Context&lt;/strong&gt; – Where is the problem?&lt;br&gt;
&lt;strong&gt;Stakeholder&lt;/strong&gt; – Whose problem, is it?&lt;br&gt;
&lt;strong&gt;Goal&lt;/strong&gt; – Why does it need to be solved?&lt;br&gt;
&lt;strong&gt;Scenarios&lt;/strong&gt; – How might a software system help?&lt;br&gt;
&lt;strong&gt;Constraints&lt;/strong&gt; – (“Limit”) &lt;em&gt;??What is the difference between constraints and scope??&lt;/em&gt;&lt;br&gt;
&lt;strong&gt;Feasibility and Risks&lt;/strong&gt; – What might prevent us solving it?&lt;/p&gt;
&lt;p&gt;Software Modelling – There are 8 design principles, in the exam 2014-2015 asking only 3 meanings of &lt;strong&gt;Modularization, Abstraction, and Encapsulation.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Modularization&lt;/strong&gt;: separate the software into small pieces. Keep separate into small parts until only one component is made for one purpose.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Abstraction&lt;/strong&gt;: focus only on important features only. Specify what need to be done&lt;br&gt;
e.g.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;a.   “computer 1 send message to server 2”&lt;/p&gt;
&lt;p&gt;b.   “computer1 retrieves the servers’ information, open TCP/IP connection, send the message, wait for response, and closes the connection”&lt;/p&gt;
&lt;p&gt;So message a is abstraction as it is focus on important words only.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Encapsulation&lt;/strong&gt;: Adding more detail from Abstraction step with only the essential information that needs to be carried out.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/20220130232833.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;in-software-architectures-there-are-41-view-model&#34;&gt;In Software Architectures there are 4+1 view model&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Development view: illustrates a system from programmers (component diagram, package diagram)&lt;/li&gt;
&lt;li&gt;Logical view: concern about functionality (class diagrams, state diagrams)&lt;/li&gt;
&lt;li&gt;Physical view: depict system from system engineering (deployment diagram)&lt;/li&gt;
&lt;li&gt;Process view: explain about process (activity diagram)&lt;/li&gt;
&lt;li&gt;Scenario: (use case view)&lt;/li&gt;
&lt;/ul&gt;
">Soft Model Tool & Tech Critcal System总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/variables-io-and-operators/"" data-c="
          &lt;h3 id=&#34;variable-names&#34;&gt;Variable Names&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;variables user defined identifiers&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;variables are case sensitive, numVar and numvar are two different&lt;/p&gt;
&lt;p&gt;variables&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;All variables must be declared before they are used&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;standard-io&#34;&gt;Standard IO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C provides a set of functions in the header file stdio.h to read inputs and write outputs.&lt;/li&gt;
&lt;li&gt;C treats all devices as files:&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Standard File&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;File Pointer&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Device&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Standard Input&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;stdin&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Keyboard&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Standard Output&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;stdout&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Screen&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Standard Error&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;stderr&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;your Screen&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;formatting-outputs-printf&#34;&gt;Formatting Outputs - printf()&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int printf (char *format , arg1 , arg2 , ...)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;printf prints a list of arbitrary arguments (arg1, arg2, ...) on the standard output under control of the format&lt;/li&gt;
&lt;li&gt;returns the number of characters printed&lt;/li&gt;
&lt;li&gt;format contains two types of objects:
&lt;ul&gt;
&lt;li&gt;ordinary characters: printed to the output stream&lt;/li&gt;
&lt;li&gt;specifiers: causes conversion and printing of the next successive argument&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;format-spceifiers&#34;&gt;Format Spceifiers&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;%d (%i) int signed decimal&lt;/li&gt;
&lt;li&gt;%u int unsigned decimal&lt;/li&gt;
&lt;li&gt;%o int unsigned octal value&lt;/li&gt;
&lt;li&gt;%x (%X) int unsigned hex value&lt;/li&gt;
&lt;li&gt;%f float or double&lt;/li&gt;
&lt;li&gt;%e (%E) float or double exponential format&lt;/li&gt;
&lt;li&gt;%s array of char (string)&lt;/li&gt;
&lt;li&gt;%p pointer address stored in pointer&lt;/li&gt;
&lt;li&gt;%ld long signed decimal&lt;/li&gt;
&lt;li&gt;%hd short signed decimal&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;reading-inputs-scanf&#34;&gt;Reading inputs - scanf()&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int scanf (char *format , arg1 , arg2 , ...)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;scanf reads characters from the keyboard, interprets them according to the specifiers in format, and stores the results through the remaining arguments&lt;/li&gt;
&lt;li&gt;each argument after format is a pointer (&amp;amp;c) indicates the memory address where the input should be store&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;relational-and-logical-operators&#34;&gt;Relational and Logical Operators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Relational Operators: ==, !=, &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=&lt;/li&gt;
&lt;li&gt;Logical Operators: &amp;amp;&amp;amp;, ||, !&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bitwise-operators&#34;&gt;Bitwise Operators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Bitwise Operators: &amp;amp;, |, ^, ⇠, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;&lt;/li&gt;
&lt;li&gt;bit manipulation operators, only used with integer datatypes&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;assignment-operators&#34;&gt;Assignment Operators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Assignment Operators: =, +=, -=, *=, /=, %=, &amp;amp;=, |=, ^=, &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=&lt;/li&gt;
&lt;li&gt;Most binary operators op have a corresponding assignment operator op=&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;misc-operators&#34;&gt;Misc Operators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Misc Operators: sizeof(), &amp;amp; (address of a variable), * (pointer to a variable), ?: (if?then:otherwise)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pointer-and-addresses-and&#34;&gt;Pointer and Addresses (* and &amp;amp;)&lt;/h3&gt;
&lt;p&gt;​	The unary operator * is the indirection or dereferencing operator; when applied to a pointer, it accesses the object the pointer points to&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int x =1, y =2;
int *ip; /* ip is a pointer to int */ ip =&amp;amp;x; /* ip now points to x */
y = *ip; /* y is now 1 */
*ip = 0; /* x is now 0 */
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;type-conversion&#34;&gt;Type Conversion&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;In arithmetic and bitwise operation the narrower operand will be converted to the wider one before applying the operation
&lt;ul&gt;
&lt;li&gt;char --&amp;gt;short --&amp;gt; int --&amp;gt; unsigned int --&amp;gt; long --&amp;gt; unsigned long --&amp;gt; long long --&amp;gt; float --&amp;gt; double --&amp;gt; long double&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;expressions like assignment might result in losing information like assigning longer integer to shorter or a float to an integer (may draw a warning)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;function&#34;&gt;Function&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;every C program has at least one function: main()&lt;/li&gt;
&lt;li&gt;you can devide you program into sepatate functions, each function perform a specfic task&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The C standard library provides numerous built-in functions:&lt;/strong&gt; printf() and scanf()&lt;/li&gt;
&lt;li&gt;The function declaration consists of:
&lt;ul&gt;
&lt;li&gt;the function’s name&lt;/li&gt;
&lt;li&gt;return type&lt;/li&gt;
&lt;li&gt;list of parameters&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A function definition provides the actual body of the function&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;static-variables&#34;&gt;Static Variables&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;the compiler to keeps the static variables in existence during the life-time of the program&lt;/li&gt;
&lt;li&gt;local variables static allows them to maintain their values between function calls&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;memory-layout-of-c-programs&#34;&gt;Memory Layout of C Programs&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-02-03%2021.00.00.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;A typical memory representation of C program consists of following sections
&lt;ul&gt;
&lt;li&gt;Text segment&lt;/li&gt;
&lt;li&gt;Initialized data segment&lt;/li&gt;
&lt;li&gt;Uninitialized data segment&lt;/li&gt;
&lt;li&gt;Stack&lt;/li&gt;
&lt;li&gt;Heap&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;text-segment&#34;&gt;Text Segment&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;text segment, also known as a code segment or text&lt;/li&gt;
&lt;li&gt;contains executable instructions&lt;/li&gt;
&lt;li&gt;may be placed below the heap or stack in order to prevent heaps and stack overflows from overwriting it&lt;/li&gt;
&lt;li&gt;shareable: single copy needs to be in memory for frequently executed programs&lt;/li&gt;
&lt;li&gt;readonly: to prevent a program from accidentally modifying its instructions&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;initialized-data-segment&#34;&gt;Initialized Data Segment&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;simply the Data Segment: is a portion of virtual address space of a program,&lt;/li&gt;
&lt;li&gt;contains the global variables and static variables that are initialized by the programmer&lt;/li&gt;
&lt;li&gt;is not read-only since the values of variables can be altered at runtime&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;uninitialized-data-segment&#34;&gt;Uninitialized Data Segment&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;often called the &amp;quot;bss&amp;quot; segment, &amp;quot;block started by symbol&amp;quot;&lt;/li&gt;
&lt;li&gt;Data in this segment is initialized by the kernel to arithmetic 0 before the program starts executing&lt;/li&gt;
&lt;li&gt;contains all global variables and static variables that are initialized to zero or do not have explicit initialization in source code, for instance:&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;stack&#34;&gt;Stack&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;A &amp;quot;stack pointer&amp;quot; tracks the top of the stack&lt;/li&gt;
&lt;li&gt;The set of values pushed for one function call is termed a &amp;quot;stack frame&amp;quot;; A stack frame consists at minimum of a return address&lt;/li&gt;
&lt;li&gt;Each time a function is called, the address of where to return to and certain information about the caller’s environment, such as some of the machine registers, are saved on the stack&lt;/li&gt;
&lt;li&gt;The newly called function then allocates room on the stack for its variables&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;heap&#34;&gt;Heap&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Heap is the segment where dynamic memory allocation usually takes place&lt;/li&gt;
&lt;li&gt;The Heap area is managed by malloc, realloc, and free&lt;/li&gt;
&lt;li&gt;The Heap area is shared by all shared libraries and dynamically loaded modules in a process&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;constants&#34;&gt;Constants&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;There are two simple ways in C to define constants:&lt;/li&gt;
&lt;li&gt;Using #define preprocessor&lt;/li&gt;
&lt;li&gt;Using const keyword&lt;/li&gt;
&lt;/ul&gt;
">Variables, IO, and Operators</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/introduction-to-c/"" data-c="
          &lt;h3 id=&#34;c-language-features&#34;&gt;C language features&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Provides lowlevel access to memory&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;used in system programming&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Operating systems: such as Linux&lt;/li&gt;
&lt;li&gt;Microcontrollers: cars and planes&lt;/li&gt;
&lt;li&gt;embedded systems: phones, portable electronics, ..&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;used in derivation of C++, Objective C, C#&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C has enormous influence on other languages: Java, PHP, Python, . . .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;High-level but close to the hardware&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fast: allows low-level programming&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;compiles to native code&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C lacks: garbage collection, OOP, . . .&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;installation&#34;&gt;Installation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Linux: included with most linux distributions
&lt;ul&gt;
&lt;li&gt;you can check it by entering this into the command line: gcc -v&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Mac OS: you need to install &lt;a href=&#34;https://developer.apple.com/xcode/&#34;&gt;Xcode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Windows: download and install &lt;a href=&#34;http://www.mingw.org&#34;&gt;MinGW&lt;/a&gt;, ensure that bin subdirectory is in PATH&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hello-world&#34;&gt;Hello World!&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int main(void)
{
  #&amp;quot;\n&amp;quot; is an escape character means &amp;quot;newline&amp;quot;
	printf(&amp;quot;Hello World!\n&amp;quot;);
  #0 indicates the program ends normally
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;C standard library header files include function definitions, variable declarations.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Other header files are&lt;/strong&gt;&lt;/em&gt; math.h, stdlib.h, string.h, time.h.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;the main entry of the of C programs, returns integer (int) and has no parameters (void) followed by a curly bracket&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;complie-and-run&#34;&gt;Complie and run&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;save the code in hello.c (.c is the extension used for c language programs)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;compile the program by entering to the command line&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	gcc hello.c&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;this create an executable file a.out on Linux and Mac OS, and a.exe on Windows&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;now you can run it by typing ./a.out (Linux MacOS) or a.exe (Windows)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;you can change the name of the output file with:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;gcc hello.c -o hello&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;c-keywords-and-identifiers&#34;&gt;C keywords and Identifiers&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;C keywords&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;auto&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;break&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;case&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;char&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;const&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;continue&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;do&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;double&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;enum&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;extern&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;float&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;goto&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;long&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;register&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;short&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;signed&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;sizeof&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;static&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;struct&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;switch&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;typedef&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;union&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;unsigned&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;volatile&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;integer-types&#34;&gt;Integer Types&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;datatype&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;size&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;range&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;char&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1 byte&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-128 to 127 or 0 to 255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;unsigned char&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1 byte&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0 to 255&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;signed char&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1 byte&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-128 to 127&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2 or 4 bytes&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-32,768 to 32,767 or -2,147,483,648 to 2,147,483,647&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;unsigned int&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2 or 4 bytes&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0 to 65,535 or 0 to 4,294,967,295&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;short&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2 bytes&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-32,768 to 32,767&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;unsigned short&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2 bytes&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0 to 65,535&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;long&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4 bytes&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-2,147,483,648 to 2,147,483,647&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;unsigned long&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4 bytes&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0 to 4,294,967,295&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;datatypes&#34;&gt;Datatypes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Integer Types&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;in unsigned the most significant bit (MSB) will not be used as sign (+ or -)&lt;/li&gt;
&lt;li&gt;The header file limits.h has many useful constants to check the range of different datatypes: SCHAR_MIN, SCHAR_MAX, UCHAR_MAX, INT_MIN, INT_MAX, UINT_MAX, ...&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Floating-Point Types&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;datatype&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;size&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;range&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;precision&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;float&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4 bytes&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.2E-38 to 3.4E+38&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6 decimal places&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;double&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8 bytes&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2.3E-308 to 1.7E+308&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;15 decimal places&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;long double&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10 bytes&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3.4E-4932 to 1.1E+4932&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;19 decimal places&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;The header file float.h provides constants to check the range of float datatypes : FLT_MIN, FLT_MAX, ...&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;the sizes and ranges may be different on you computer based on the platform you use (hardware and OS)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
">Introduction to C</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/jie-jue-tomcat-qi-dong-cheng-gong-hou-wu-fa-fang-wen-ye-mian/"" data-c="
          &lt;h3 id=&#34;问题描述更改tomcat端口为9090终端显示启动成功后无法访问该页面&#34;&gt;问题描述：更改Tomcat端口为9090，终端显示启动成功后无法访问该页面。&lt;/h3&gt;
&lt;h3 id=&#34;问题分析&#34;&gt;问题分析：&lt;/h3&gt;
&lt;h5 id=&#34;可以开启-关闭tomcat且更改其他端口tomcat运行正常推测是9090该端口被占用&#34;&gt;可以开启、关闭Tomcat，且更改其他端口Tomcat运行正常，推测是9090该端口被占用。&lt;/h5&gt;
&lt;h3 id=&#34;问题解决&#34;&gt;问题解决&lt;/h3&gt;
&lt;h4 id=&#34;1查看tomcat日志文件打开如下路径&#34;&gt;1.查看Tomcat日志文件，打开如下路径：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;Users/lijiexi/Downloads/apache-tomcat-9.0.58/logs/catalina.out 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2分析日志&#34;&gt;2.分析日志：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;INFO [main] org.apache.coyote.AbstractProtocol.init Initializing ProtocolHandler [&amp;quot;http-nio-9090&amp;quot;]
SEVERE [main] org.apache.catalina.util.LifecycleBase.handleSubClassException Failed to initialize component [Connector[HTTP/1.1-9090]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;9090端口号被占用&lt;/p&gt;
&lt;h4 id=&#34;3解决&#34;&gt;3.解决：&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/%E6%88%AA%E5%B1%8F2022-01-29%2013.51.21.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;#查找占用该端口的程序
sudo lsof -i tcp:9090
#关闭该进程
sudo kill -9 PID
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4优化&#34;&gt;4.优化：&lt;/h4&gt;
&lt;p&gt;在修改server.xml配置文件时发现未修改shutdown端口，可能存在安全隐患，因此直接禁止。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Server port=&amp;quot;-1&amp;quot; shutdown=&amp;quot;SHUTDOWN&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">解决Tomcat启动成功后无法访问页面</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/springboot-lan-jie-qi-interceptor/"" data-c="
          &lt;p&gt;在开发短信注册功能时，希望用户在60s内只能获取一次验证码。因此使用SpringBoot中的拦截器。Interceptor和Filter一样，都是AOP的具体实现。&lt;/p&gt;
&lt;h3 id=&#34;自定义拦截器&#34;&gt;自定义拦截器&lt;/h3&gt;
&lt;p&gt;在新闻自媒体项目中，我使用Redis来存取短信验证码，因此需要自定拦截器，在用户访问到达controller层前，检测Redis，如果60s内该ip没有进行访问，则放行。&lt;/p&gt;
&lt;p&gt;如果拦截器须实现 &lt;code&gt;org.springframework.web.servlet.HandlerInterceptor&lt;/code&gt;接口或继承 &lt;code&gt;org.springframework.web.servlet.handler.HandlerInterceptorAdapter&lt;/code&gt;类，并且需要重写下面下面 3 个方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;preHandler(HttpServletRequest request, HttpServletResponse response, Object handler)&lt;/li&gt;
&lt;li&gt;postHandler(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)&lt;/li&gt;
&lt;li&gt;afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class PassportInterceptor implements HandlerInterceptor {
    @Autowired
    public RedisOperator redis;

    public static final String MOBILE_SMSCODE = &amp;quot;mobile:smscode&amp;quot;;

    /**
     * 在进入controller之前拦截请求
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 获得用户ip
        String userIp = IPUtil.getRequestIp(request);

        boolean keyIsExit = redis.keyIsExist(MOBILE_SMSCODE + &amp;quot;:&amp;quot; + userIp);

        if(keyIsExit){
            System.out.println(&amp;quot;频率过快&amp;quot;);
            return false;
        }
        /**
         * return false:请求被拦截
         * return true：请求放行
         */
        return true;
    }

    /**
     * 在请求访问到controller后，渲染视图之前
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
    }

    /**
     * controller之后，渲染视图之后
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;配置拦截器&#34;&gt;配置拦截器&lt;/h3&gt;
&lt;p&gt;在自定义拦截器后，需要将其在MVC容器中注册；在加入拦截器的同时，还需传入路由地址。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class InterceptorConfig implements WebMvcConfigurer {
    @Bean
    public PassportInterceptor passportInterceptor(){
        return new PassportInterceptor();
    }
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&amp;quot;/passport/getSMSCode&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
">SpringBoot拦截器Interceptor</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/centos7-xu-ni-ji-xiu-gai-ip-di-zhi/"" data-c="
          &lt;p&gt;​	在使用secureCRT连接虚拟机时，发现无法连接，报错host is down。接着尝试RDM连接在虚拟机中的Redis，也无法访问，因此推断是虚拟机IP地址改变，需要重新配置。&lt;/p&gt;
&lt;h3 id=&#34;查看虚拟机ip&#34;&gt;查看虚拟机IP&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ip addr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在终端输入如下命令后，ens33则会显示当前IP地址，果然相较于之前改变。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ens33: flags=4163&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu 1500
        inet 192.168.130.19  netmask 255.255.240.0  broadcast 192.168.143.255
        inet6 fe80::61fb:c73:beb0:2438  prefixlen 64  scopeid 0x20&amp;lt;link&amp;gt;
        ether 00:0c:29:fa:02:fb  txqueuelen 1000  (Ethernet)
        RX packets 867498  bytes 429720208 (409.8 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 402654  bytes 39951689 (38.1 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;更改ip&#34;&gt;更改IP&lt;/h3&gt;
&lt;p&gt;使用命令打开network-scripts目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /etc/sysconfig/network-scripts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改ifcfg-ens33文件，修改IPADDR为原来的IP地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim ifcfg-ens33
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在文件中追加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IPADDR=192.168.0.171
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时保存退出，确遇到了错误&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For some reason the file you are writing to cannot be created or overwritten. The reason could be that you do not have permission to write in the directory or the file name is not valid.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;解决追加问题&#34;&gt;解决追加问题&lt;/h3&gt;
&lt;p&gt;此时有两种解决方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种，强制退出，切换root用户，再编辑该文件&lt;/li&gt;
&lt;li&gt;第二种，如果不想放弃已经编辑的文件，可以直接执行如下指令：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;:w !sudo tee % &amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;重启网络服务&#34;&gt;重启网络服务&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;service network restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时问题已经得到解决，虚拟机又可以被愉快的访问了&lt;/p&gt;
">Centos7虚拟机修改IP地址</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/auto-software-verification-zong-jie/"" data-c="
          &lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/MicrosoftTeams-image.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-the-technique-of-model-checking&#34;&gt;1. the technique of model checking&lt;/h3&gt;
&lt;h3 id=&#34;2-modelling-programs-with-transition-systemsfrom-concurrent-programs-to-transitions-systems&#34;&gt;2. modelling programs with transition systems(from concurrent programs to transitions systems)&lt;/h3&gt;
&lt;h3 id=&#34;3-types-of-correctness-propertiessafetyliveness&#34;&gt;3. types of correctness properties(safety,liveness)&lt;/h3&gt;
&lt;h3 id=&#34;4fairness-assumptions-and-their-use&#34;&gt;4.fairness assumptions and their use&lt;/h3&gt;
&lt;h3 id=&#34;5-ltl&#34;&gt;5. LTL&lt;/h3&gt;
&lt;h4 id=&#34;51-understand-ltl-specifications&#34;&gt;5.1 understand LTL specifications&lt;/h4&gt;
&lt;h4 id=&#34;52-formalise-properties-in-ltl&#34;&gt;5.2 formalise properties in LTL&lt;/h4&gt;
&lt;h3 id=&#34;6-automa-based-ltl-model-checking&#34;&gt;6. Automa-based LTL model checking&lt;/h3&gt;
&lt;h4 id=&#34;61-buchi-automata-and-their-relationship-to-ltl&#34;&gt;6.1 buchi automata and their relationship to LTL&lt;/h4&gt;
&lt;h4 id=&#34;62-model-checking-algorithmapply-to-simple-examples&#34;&gt;6.2 model-checking algorithm(apply to simple examples)&lt;/h4&gt;
&lt;h3 id=&#34;7-symbolic-modelling-of-systemsinittrans&#34;&gt;7. symbolic modelling of systems(Init,Trans)&lt;/h3&gt;
&lt;h3 id=&#34;8-symbolic-modelling-of-boolean-programs&#34;&gt;8. symbolic modelling of (boolean) programs&lt;/h3&gt;
&lt;h4 id=&#34;81-understand-apply-encoding-of-different-programs-statements&#34;&gt;8.1 understand /apply encoding of different programs statements&lt;/h4&gt;
&lt;h3 id=&#34;9-symbolic-model-checking&#34;&gt;9. symbolic model checking&lt;/h3&gt;
&lt;h4 id=&#34;91-algorithm-for-computing-reachable-states&#34;&gt;9.1 algorithm for computing reachable states&lt;/h4&gt;
&lt;h4 id=&#34;92-checking-simple-safety-properties&#34;&gt;9.2 checking simple safety properties&lt;/h4&gt;
&lt;h4 id=&#34;93-checking-ltl-properties&#34;&gt;9.3 checking LTL properties&lt;/h4&gt;
&lt;h3 id=&#34;10-robdds&#34;&gt;10. ROBDDs&lt;/h3&gt;
&lt;h4 id=&#34;101-definition-construction-variable-orderings&#34;&gt;10.1 definition, construction, variable orderings&lt;/h4&gt;
&lt;h4 id=&#34;102-logical-operations-on-bdds-and-their-use&#34;&gt;10.2 logical operations on BDDs and their use&lt;/h4&gt;
&lt;h4 id=&#34;103-use-of-bdds-for-computing-reachability&#34;&gt;10.3 use of BDDs for computing reachability&lt;/h4&gt;
&lt;h3 id=&#34;qa&#34;&gt;Q&amp;amp;A&lt;/h3&gt;
&lt;h3 id=&#34;loop-invariant-it-must-be-true-in-the-very-beginning-its-preserved-by-every-execution-including-the-last-one-and-its-always-true-in-the-loop-no-matter-how-many-times-the-loop-executes&#34;&gt;Loop invariant: it must be true in the very beginning, it&#39;s preserved by every execution including the last one. And it&#39;s always true in the loop, no matter how many times the loop executes.&lt;/h3&gt;
&lt;h3 id=&#34;loop-variant-some-variables-can-change-during-each-loop-so-that-the-loop-could-have-a-condition-to-stop&#34;&gt;Loop variant : some variables can change during each loop, so that the loop could have a condition to stop.&lt;/h3&gt;
&lt;h3 id=&#34;describe-the-approach-of-bounded-model-checking-for-the-reachability-problem&#34;&gt;Describe the approach of bounded model-checking for the reachability problem.&lt;/h3&gt;
&lt;h4 id=&#34;first-we-decide-a-positive-integer-k-and-check-whether-the-target-is-reached-in-k-steps-we-encode-the-bmc-problem-as-a-sat-problem-then-the-problem-become&#34;&gt;First, we decide a positive integer k, and check whether the target is reached in k steps. We encode the BMC problem as a SAT problem then the problem become:&lt;/h4&gt;
&lt;h4 id=&#34;x-initx-targetx-transxx-k&#34;&gt;x, Init(x), Target(x), Trans(x,x&#39;), K&lt;/h4&gt;
&lt;h4 id=&#34;and-transferred-to-boolean-formula-k-k-is-satifiable-if-targetx-is-reachable-from-initx-with-in-k-steps-following-transxx-if-we-cant-reach-in-k-steps-then-we-try-k1-steps-until-we-meet-the-bound&#34;&gt;And transferred to boolean formula k. k is satifiable if target(x) is reachable from init(x) with in k steps following trans(x,x&#39;). If we can&#39;t reach in k steps then we try k+1 steps until we meet the bound.&lt;/h4&gt;
&lt;h3 id=&#34;what-is-the-difference-between-gray-box-black-box-and-white-box&#34;&gt;What is the difference between Gray box, Black box, and White box&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Black-box: creating a specification test-case without looking at code.&lt;/li&gt;
&lt;li&gt;White-box: access / looking at the code and predict which case can fail.&lt;/li&gt;
&lt;li&gt;Grey-box: combination of both black-box and white-box. Using specification and knowledge of the code.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;what-is-the-meaning-of-failure-fault-and-error&#34;&gt;What is the meaning of Failure, Fault and Error?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Failure: observed incorrect behavior with respect to the expected behavior.&lt;/li&gt;
&lt;li&gt;Fault: a defect in software causing it to fail to perform its required function.&lt;/li&gt;
&lt;li&gt;Error: an incorrect internal state.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;what-is-the-difference-between-testing-and-debugging&#34;&gt;What is the difference between Testing and Debugging?&lt;/h3&gt;
&lt;h4 id=&#34;testing-is-concerned-with-finding-failures-but-debugging-is-concerned-with-associating-failures-to-faults&#34;&gt;Testing is concerned with finding failures, but Debugging is concerned with associating failures to faults.&lt;/h4&gt;
&lt;h3 id=&#34;what-is-tuple-d-or&#34;&gt;What is tuple (D, Or)?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;D is the test data contain (PD: input parameters, SD: initial state)&lt;/li&gt;
&lt;li&gt;Or is an Oracle containing (R: return value, Sf: final state)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;what-is-statement-coverage-branch-coverage-and-condition-coverage&#34;&gt;What is Statement coverage, Branch Coverage, and Condition coverage?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Statement coverage is making sure all the stages are executed&lt;/li&gt;
&lt;li&gt;Branch coverage is making sure all the paths though are executed&lt;/li&gt;
&lt;li&gt;Condition coverage is making sure all conditions [if-condition e.g., if((x&lt;mark&gt;1) || (y&lt;/mark&gt;1))] are executed.&lt;/li&gt;
&lt;li&gt;* if you using Brach coverage and Condition coverage, this already make sure all the cases are covered *&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;what-is-concolic&#34;&gt;What is Concolic?&lt;/h3&gt;
&lt;h4 id=&#34;it-is-a-combination-of-concrete-and-symbolic-trying-to-make-a-progress-when-analysis-using-symbolic-execution-gets-stuck&#34;&gt;It is a combination of “Concrete” and “Symbolic” trying to make a progress when analysis using symbolic execution gets stuck.&lt;/h4&gt;
">Auto Software Verification总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/java-bing-fa-yi/"" data-c="
          &lt;h3 id=&#34;线程和进程&#34;&gt;线程和进程&lt;/h3&gt;
&lt;h4 id=&#34;进程&#34;&gt;进程&lt;/h4&gt;
&lt;p&gt;​	进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。&lt;/p&gt;
&lt;h4 id=&#34;线程&#34;&gt;线程&lt;/h4&gt;
&lt;p&gt;​	线程是一个比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的&lt;strong&gt;堆&lt;/strong&gt;和&lt;strong&gt;方法区&lt;/strong&gt;资源，但每个线程有自己的&lt;strong&gt;程序计数器&lt;/strong&gt;、&lt;strong&gt;虚拟机栈&lt;/strong&gt;和&lt;strong&gt;本地方法栈&lt;/strong&gt;，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多。&lt;/p&gt;
&lt;h3 id=&#34;并发和并行&#34;&gt;并发和并行&lt;/h3&gt;
&lt;p&gt;并发：同一时间段内，多个任务都在执行&lt;/p&gt;
&lt;p&gt;并行：单位时间内，多个任务同时执行&lt;/p&gt;
&lt;h3 id=&#34;线程的生命周期&#34;&gt;线程的生命周期&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;新建状态(New)：新创建了一个线程对象&lt;/li&gt;
&lt;li&gt;就绪状态(Runnable)：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权&lt;/li&gt;
&lt;li&gt;运行状态(Running)：就绪状态的线程获取了CPU，执行程序代码&lt;/li&gt;
&lt;li&gt;阻塞状态(Blocked)：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
&lt;ul&gt;
&lt;li&gt;等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)&lt;/li&gt;
&lt;li&gt;同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中&lt;/li&gt;
&lt;li&gt;其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;死亡状态(Dead)：线程执行完了或者因异常退出了run()方法，该线程结束生命周期&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用线程&#34;&gt;使用线程&lt;/h3&gt;
&lt;p&gt;有三种使用线程的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现Runnable接口&lt;/li&gt;
&lt;li&gt;实现Callable接口&lt;/li&gt;
&lt;li&gt;继承Thread类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。&lt;/p&gt;
&lt;h4 id=&#34;实现runnable接口&#34;&gt;实现Runnable接口&lt;/h4&gt;
&lt;p&gt;需要实现接口中的run方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;实现callable接口&#34;&gt;实现Callable接口&lt;/h4&gt;
&lt;p&gt;与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyCallable implements Callable&amp;lt;Integer&amp;gt; {
    public Integer call() {
        return 123;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask&amp;lt;Integer&amp;gt; ft = new FutureTask&amp;lt;&amp;gt;(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;继承thread类&#34;&gt;继承Thread类&lt;/h4&gt;
&lt;p&gt;​	同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyThread extends Thread {
    public void run() {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
    MyThread mt = new MyThread();
    mt.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;实现接口-vs-继承-thread&#34;&gt;实现接口 VS 继承 Thread&lt;/h4&gt;
&lt;p&gt;实现接口会更好一些，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口&lt;/li&gt;
&lt;li&gt;类可能只要求可执行就行，继承整个 Thread 类开销过大&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;守护线程&#34;&gt;守护线程&lt;/h3&gt;
&lt;p&gt;​	守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。main() 属于非守护线程。&lt;/p&gt;
&lt;h3 id=&#34;join&#34;&gt;join()&lt;/h3&gt;
&lt;p&gt;​	t.join()使t线程加塞到当前线程之前获得CPU，当前线程进入等待状态，直到线程t结束为止，当前线程恢复为就绪状态，等待线程调度。可以通过传入线程t2,并t2.join()使得按照一定顺序的运行t2-&amp;gt;t。thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。&lt;/p&gt;
&lt;h3 id=&#34;yield&#34;&gt;yield()&lt;/h3&gt;
&lt;p&gt;​	对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void run() {
    Thread.yield();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;sleep&#34;&gt;sleep()&lt;/h3&gt;
&lt;p&gt;​	Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。&lt;/p&gt;
&lt;h3 id=&#34;waitnotify&#34;&gt;wait()notify()&lt;/h3&gt;
&lt;p&gt;​	调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。它们都属于 Object 的一部分，而不属于 Thread。&lt;/p&gt;
&lt;p&gt;​	使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。&lt;/p&gt;
&lt;h3 id=&#34;线程的终止&#34;&gt;线程的终止&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;无限循环中使用退出标志&lt;/li&gt;
&lt;li&gt;stop()，不推荐&lt;/li&gt;
&lt;li&gt;非运行状态，interrupt()，抛出异常，可以捕获，然后退出，也可以捕获后不退出&lt;/li&gt;
&lt;li&gt;stop()方法回立即释放所持有的锁，会将正在写入的数据写坏，比如写坏一半&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;互斥同步&#34;&gt;互斥同步&lt;/h3&gt;
&lt;p&gt;​	Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。&lt;/p&gt;
&lt;h4 id=&#34;synchorinized&#34;&gt;synchorinized&lt;/h4&gt;
&lt;p&gt;1.同步代码块&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void func() {
    synchronized (this) {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。&lt;/p&gt;
&lt;p&gt;2.同步一个方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public synchronized void func () {
	//...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它页只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。&lt;/p&gt;
&lt;p&gt;3.同步一个类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SynchronizedExample {
    public void func2() {
        synchronized (SynchronizedExample.class) {
            for (int i = 0; i &amp;lt; 10; i++) {
                System.out.print(i + &amp;quot; &amp;quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作用于整个类，两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。&lt;/p&gt;
&lt;p&gt;4.同步一个静态方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public synchronized static void fun() {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作用于整个类&lt;/p&gt;
&lt;h4 id=&#34;reentrantlock&#34;&gt;ReentrantLock&lt;/h4&gt;
&lt;p&gt;ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。&lt;/p&gt;
&lt;h4 id=&#34;比较&#34;&gt;比较&lt;/h4&gt;
&lt;h5 id=&#34;锁的实现&#34;&gt;锁的实现&lt;/h5&gt;
&lt;p&gt;synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。&lt;/p&gt;
&lt;h5 id=&#34;性能&#34;&gt;性能&lt;/h5&gt;
&lt;p&gt;新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。&lt;/p&gt;
&lt;h5 id=&#34;等待中断&#34;&gt;等待中断&lt;/h5&gt;
&lt;p&gt;当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。&lt;/p&gt;
&lt;p&gt;ReentrantLock 可中断，而 synchronized 不行。&lt;/p&gt;
&lt;h5 id=&#34;公平锁&#34;&gt;公平锁&lt;/h5&gt;
&lt;p&gt;公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。&lt;/p&gt;
">Java并发（一）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/guan-yu-ke-cheng-software-prjct-man-and-secur-dev-de-yi-xie-zong-jie/"" data-c="
          &lt;p&gt;### &lt;strong&gt;Chapter 1: Module Introduction&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Software engineering: is an engineering discipline which is concerned with all aspects that are related to software. Including gathering requirements, design, development, testing, maintenance and managing all problems.&lt;/p&gt;
&lt;p&gt;Different from other engineers: Software engineering different from other engineering with 3 main parts below,&lt;/p&gt;
&lt;p&gt;•  Invisibility: Software progress is not immediately visible.&lt;/p&gt;
&lt;p&gt;•  Complexity: Software products are more complex than other engineering&lt;/p&gt;
&lt;p&gt;•  Flexibility: Software can be changed or modified in the future.&lt;/p&gt;
&lt;p&gt;Type of software:&lt;/p&gt;
&lt;p&gt;•  Generic product (Stand-alone product by development organization e.g., Microsoft office),&lt;/p&gt;
&lt;p&gt;•  Bespoke product (system develop for specific customer developed by contactor e.g., underground system).&lt;/p&gt;
&lt;p&gt;Software product attributes:&lt;/p&gt;
&lt;p&gt;•  Maintainability (can be changed later),&lt;/p&gt;
&lt;p&gt;•  Dependability (failure does not affect other damage),&lt;/p&gt;
&lt;p&gt;•  Efficiency(useable).&lt;/p&gt;
&lt;p&gt;Why secure software development needed&lt;/p&gt;
&lt;p&gt;•  Target attack has changed (Past focus on OS, Now focusses on Webpage)&lt;/p&gt;
&lt;p&gt;•  Attackers’ nature (Past just for fun, Now needs crime or money)&lt;/p&gt;
&lt;p&gt;•  Attacker can beat vulnerability&lt;/p&gt;
&lt;p&gt;•  Defects happen on design (bug in design called “Flaw”) and code.&lt;/p&gt;
&lt;p&gt;### &lt;strong&gt;Chapter summary&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Software engineering is the disciplined process of producing software.&lt;/p&gt;
&lt;p&gt;•  It helps communicate the design to members of them&lt;/p&gt;
&lt;p&gt;•  It helps manage the process through the life cycle: from concept to delivery and through to decommissioning.&lt;/p&gt;
&lt;p&gt;### &lt;strong&gt;Chapter 2: Managing software project&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Why the project failed&lt;/p&gt;
&lt;p&gt;•  People programming before understanding (want to want to make progress, so they want to code asap)&lt;/p&gt;
&lt;p&gt;•  The team has unrealistic ideas about how work is involved (wrong estimate about how much work, time, buget)&lt;/p&gt;
&lt;p&gt;•  Defects happen early but found it late e.g., v-model design is wrong but discovered at acceptance by user.&lt;/p&gt;
&lt;p&gt;•  Programmer has poor habit (e.g., code writing from one person, hard for another to pick up. New programmers do not have experience making poor programs)&lt;/p&gt;
&lt;p&gt;•  Managers try to test into software (e.g., everyone expected tester will catch all bugs, programmer feel tester have negative attitude with only him)&lt;/p&gt;
&lt;p&gt;How to make sure project success&lt;/p&gt;
&lt;p&gt;•  All decisions are openly shared with related workers.&lt;/p&gt;
&lt;p&gt;o  Is the goal clearly defined?&lt;/p&gt;
&lt;p&gt;o  Is there a list of jobs so that everyone knows their part?&lt;/p&gt;
&lt;p&gt;o  Does the project manager know what is going on?&lt;/p&gt;
&lt;p&gt;•  Trust your member team&lt;/p&gt;
&lt;p&gt;o  Has a job been assigned to people?&lt;/p&gt;
&lt;p&gt;•  Review everything, test everything from the beginning of the project.&lt;/p&gt;
&lt;p&gt;•  Create equally (too much hierarchy is slow down communication and lower voice do not touch higher level)&lt;/p&gt;
&lt;p&gt;o  Is there only one leader?&lt;/p&gt;
&lt;p&gt;•  Fastest way is to use good engineering (not about skipping reviews or testing)&lt;/p&gt;
&lt;p&gt;Project management lifecycle&lt;/p&gt;
&lt;p&gt;\1. Project Proposal selection&lt;/p&gt;
&lt;p&gt;o  SWOT: identifying Strengths and Weaknesses, any other Opportunities, and Threats to the project face. &amp;lt;&lt;using by a small project&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;o  PESTAL: political, economic, social, technological, legal and environment. Seems to be emphasized at external to the business.&lt;/p&gt;
&lt;p&gt;&amp;lt;&lt;Using by government&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;o  Balance Scorecard: used by manager to keep track of the execution of activities by staff.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/20220122214845.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Information about strategy maps won’t be included much here as past exams never had it.&lt;/p&gt;
&lt;p&gt;strategy map is a simple graphic that shows a logical, cause and effect connection between strategic objectives eg. Increase revenue (pay more money) -&amp;gt; will increase profitability (ability of software)&lt;/p&gt;
&lt;p&gt;In-balance scorecards it says every application carries risks and benefits.&lt;/p&gt;
&lt;p&gt;\2. Determined project scope: scope defined as ‘the work the project has to do’ “benefit”, “costs” and “timescales” are linked to project scope.&lt;/p&gt;
&lt;p&gt;\3. Project management Triangle: model of constraint of project management (scope, time, cost) Project should have only one major aim and several objectives supporting the aim.&lt;/p&gt;
&lt;p&gt;project management focuses on 3P (process, problem, people)&lt;/p&gt;
&lt;p&gt;\4. Management activity&lt;/p&gt;
&lt;p&gt;o  Proposal writing:&lt;/p&gt;
&lt;p&gt;o  Project planning and scheduling: most software projects in UK following PRINCE2 (it’s a structure project management method) Agile (a project management process that develops with customer need)&lt;/p&gt;
&lt;p&gt;o  Project costing: involve prediction and decisions about task need (Best-guess). The estimation will be a risk for time and budget.&lt;/p&gt;
&lt;p&gt;o  Project monitoring and review, Personal selection and evaluation, and Report writing and presentation: Monitoring to ensure the project is following its scheduled, monitoring time, cost, and quality.&lt;/p&gt;
&lt;p&gt;Extra information&lt;/p&gt;
&lt;p&gt;Disaster Recovery plan (backup plan): in case something went wrong we have a backup. People know where it is, and the backup is up to date. The backup should work. E.g., Building destroys by fired, we have a second place that people can work.&lt;/p&gt;
&lt;p&gt;### &lt;strong&gt;Chapter 3: Managing project&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Project VS Operation&lt;/p&gt;
&lt;p&gt;Project has a starting point and ending point. It is creating a product, service, or result.&lt;/p&gt;
&lt;p&gt;Operation work done until the business expires or something. It has been a long time.&lt;/p&gt;
&lt;p&gt;What is PMBOK? (Project management Body of Knowledge)&lt;/p&gt;
&lt;p&gt;PMBOK is a collection of processes, best practices. Terminologies, and guidelines. PMBOK helps the company as a standard practice across various departments. “We can adapt knowledge from PMBOK to apply to the project and it also have guideline how to manage with failure.”&lt;/p&gt;
&lt;p&gt;Project attributes and Project Constraints&lt;/p&gt;
&lt;p&gt;•  Project attributes&lt;/p&gt;
&lt;p&gt;o  It has a unique propose and only temporary.&lt;/p&gt;
&lt;p&gt;o  Change something and create valuable things.&lt;/p&gt;
&lt;p&gt;o  Require many resources from different areas.&lt;/p&gt;
&lt;p&gt;o  Should have sponsor, primary customer.&lt;/p&gt;
&lt;p&gt;•  Project constraints (Scope goal, Scope time, Cost goal)&lt;/p&gt;
&lt;p&gt;Project management: is “the application of knowledge skills, tools and techniques to project activities to meet project requirements” Project management strive to meet the triple constraint (scope time and cost).&lt;/p&gt;
&lt;p&gt;•  Project stakeholders: are people involved in or affected by project activities. (Project sponsor, project manager, support staff)&lt;/p&gt;
&lt;p&gt;•  Project management knowledge: must know in 10 knowledge area e.g., scope, scheduled, cost, resource, risk.&lt;/p&gt;
&lt;p&gt;•  Tools and techniques: Project charter, scope statement, and work breakdown structure WBS (scope).&lt;/p&gt;
&lt;p&gt;Defined project success&lt;/p&gt;
&lt;p&gt;•  Project meet scope, time, cost.&lt;/p&gt;
&lt;p&gt;•  Project satisfied by customer.&lt;/p&gt;
&lt;p&gt;•  Result of the project meet main objective&lt;/p&gt;
&lt;p&gt;*Top 3 reason that make technologies project successful 1. adequate funding 2. staff expertise 3. engagement from all stakeholders.&lt;/p&gt;
&lt;p&gt;Program and Project Portfolio Management&lt;/p&gt;
&lt;p&gt;•  Program: is a group of related projects managed in a coordinated manner e.g., MS office is a program combined with many projects such as word, excel, access.&lt;/p&gt;
&lt;p&gt;•  Project Portfolio: help their organization make wise investment decisions by helping select and analyze projects from a strategic perspective.&lt;/p&gt;
&lt;p&gt;Best practice is an optimal way recognized by industry to achieve a stated goal or objective.&lt;/p&gt;
&lt;p&gt;### &lt;strong&gt;Chapter summary&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;•  A project is a temporary endeavor undertaken to create a unique product service or result.&lt;/p&gt;
&lt;p&gt;•  Project management is the application of knowledge, skills, tools, and techniques to project activities to meet project requirements.&lt;/p&gt;
&lt;p&gt;•  A program is a group of related projects managed in a coordinated way&lt;/p&gt;
&lt;p&gt;•  Project portfolio management involves organizing and managing projects and programs as a portfolio of investments.&lt;/p&gt;
&lt;p&gt;•  Project Manager plays a key role in helping projects and organizations succussed.&lt;/p&gt;
&lt;p&gt;•  The project management profession continues to grow and mature.&lt;/p&gt;
&lt;p&gt;### &lt;strong&gt;Chapter 4: Project management and IT context&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Systems view of project management:&lt;/p&gt;
&lt;p&gt;•  System approach: project manager needs to use system thinking, taking overall view of carrying out projects within the context of the organization. Including 3 parts&lt;/p&gt;
&lt;p&gt;o  System philosophy – overall model thinking, think about things as systems.&lt;/p&gt;
&lt;p&gt;o  System analysis – problem solving approaches. Analytic system&lt;/p&gt;
&lt;p&gt;o  System management – address business, technology, and organizational issues before making changes.&lt;/p&gt;
&lt;p&gt;  Technology: Should tablets be based on Apple or Microsoft?&lt;/p&gt;
&lt;p&gt;  Organization: Will the tablet project affect all students or only certain majors?&lt;/p&gt;
&lt;p&gt;  Business: What will tablet cost the college?&lt;/p&gt;
&lt;p&gt;•  Organization&lt;/p&gt;
&lt;p&gt;o  Understand organization: Must understand organization and people om the organization as well.&lt;/p&gt;
&lt;p&gt;o  Four Frames of organization&lt;/p&gt;
&lt;p&gt;  Structural frame: Roles and responsibility. Coordination and control.&lt;/p&gt;
&lt;p&gt;  Political frame: various individuals and interest groups.&lt;/p&gt;
&lt;p&gt;  Symbolic frame: Culture, languages, tradition.&lt;/p&gt;
&lt;p&gt;  Human resources: needs or organization or needs of people.&lt;/p&gt;
&lt;p&gt;o  Organization structures: Three basic organizational structures&lt;/p&gt;
&lt;p&gt;  Functional – functional managers&#39; report to CEO e.g., university.&lt;/p&gt;
&lt;p&gt;  Project – Program managers report to CEO&lt;/p&gt;
&lt;p&gt;  Matrix – middle ground between functional and project structure.&lt;/p&gt;
&lt;p&gt;o  Organization culture: share assumption values and behavior. 10 characteristics of organizational culture. (Member identity, Group emphasis, people focus, Unit integration, control, Risk tolerance, Reward criteria, Conflict tolerance, Means-ends orientation, open-system focus)&lt;/p&gt;
&lt;p&gt;•  Focusing on stakeholder needs, ** using four frames of organization can help meet stakeholder needs and expectation.&lt;/p&gt;
&lt;p&gt;•  Importance of Top management commitment: People in the top management are key stakeholders in project. Because the project need support from top managers.&lt;/p&gt;
&lt;p&gt;Project and product lifecycle&lt;/p&gt;
&lt;p&gt;•  Project lifecycle: a collection of project phases (what work will be performed, what deliverable will be produced, who involved in each phrase)&lt;/p&gt;
&lt;p&gt;o  Early phases: resource needs are usually lowest, risk is highest&lt;/p&gt;
&lt;p&gt;o  Middle phase: more resources are needed. Project improves.&lt;/p&gt;
&lt;p&gt;o  Final phase: ensure project meets the requirement.&lt;/p&gt;
&lt;p&gt;•  Product lifecycle: System development Lyfe Cycle (SDLC) framework for describing the phase of developing information system. System development project can follow&lt;/p&gt;
&lt;p&gt;o  Predictive life cycle: scope and scheduled and cost are determined early. E.g., waterfall, spiral model.&lt;/p&gt;
&lt;p&gt;o  Iterative life cycle: scope is determined early but time, cost estimates are modified as understandable.&lt;/p&gt;
&lt;p&gt;o  Incremental life cycle: delivery is produced through a series of iterations. ** work best with low change but high delivery.&lt;/p&gt;
&lt;p&gt;o  Adaptive life cycle: stakeholders define and approve the detailed scope before the start of n iteration.&lt;/p&gt;
&lt;p&gt;o  Hybrid life cycle: combined of approaches.&lt;/p&gt;
&lt;p&gt;Project management Framework&lt;/p&gt;
&lt;p&gt;Process group  Knowledge area&lt;/p&gt;
&lt;p&gt;Initial integration&lt;/p&gt;
&lt;p&gt;Planning  scope&lt;/p&gt;
&lt;p&gt;execute Scheduled&lt;/p&gt;
&lt;p&gt;monitoring cost&lt;/p&gt;
&lt;p&gt;close  quality&lt;/p&gt;
&lt;p&gt;Resource&lt;/p&gt;
&lt;p&gt;Communication&lt;/p&gt;
&lt;p&gt;Risk&lt;/p&gt;
&lt;p&gt;Procumbent&lt;/p&gt;
&lt;p&gt;Stakeholder&lt;/p&gt;
&lt;p&gt;Project life cycle (PLC): focus on managing project&lt;/p&gt;
&lt;p&gt;System Development Life cycle (SDLC): focus on implement project’s product.&lt;/p&gt;
&lt;p&gt;Important of Project Phases and Management Reviews&lt;/p&gt;
&lt;p&gt;•  Project should pass through each project phase in order to continue to the next.&lt;/p&gt;
&lt;p&gt;•  Should not wait until the end of the project or product phrase to have management inputs.&lt;/p&gt;
&lt;p&gt;IT project&lt;/p&gt;
&lt;p&gt;•  Context of Information Technology Project:&lt;/p&gt;
&lt;p&gt;•  Nature of IT project: IT project can be diverse in terms of size and complexity.&lt;/p&gt;
&lt;p&gt;•  Characteristics of IT project team members: often have diverse backgrounds and skill set.&lt;/p&gt;
&lt;p&gt;•  Diverse Technology: Technology is changing rapidly so it keeps diverging.&lt;/p&gt;
&lt;p&gt;Recently trands in IT project management&lt;/p&gt;
&lt;p&gt;•  Outsourcing when an organization needs good sources from outside sources&lt;/p&gt;
&lt;p&gt;•  Offshoring describes outsourcing from another country&lt;/p&gt;
&lt;p&gt;•  Virtual team: low cost because you do not need office space. Can have team members globally working anytime.  But it will be an isolation team member. Reducing ability for team members to network and transfer information informally.&lt;/p&gt;
&lt;p&gt;•  Agile: being to move quickly and easily. 4 mains part of Manifesto&lt;/p&gt;
&lt;p&gt;o  Individuals and interaction over process and tools&lt;/p&gt;
&lt;p&gt;o  Working software over comprehensive document&lt;/p&gt;
&lt;p&gt;o  Customer&#39;s collaboration over contract negotiation&lt;/p&gt;
&lt;p&gt;o  Responding to change over follow the plan&lt;/p&gt;
&lt;p&gt;o  Scrum&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/20220122215326.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;### &lt;strong&gt;Chapter summary&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;•  Project managers need to take a system approach when working on projects.&lt;/p&gt;
&lt;p&gt;•  Organizations have four different frames: structural, human resources, political and symbolic.&lt;/p&gt;
&lt;p&gt;•  The structure and culture of an organization have strong implications for project managers.&lt;/p&gt;
&lt;p&gt;•  Project should successfully pass through each phase of the project life cycle.&lt;/p&gt;
&lt;p&gt;•  Project managers need to consider several factors due to the unique context of information technology projects.&lt;/p&gt;
&lt;p&gt;•  Current trends are outsourcing, virtual teams and agile project management.&lt;/p&gt;
&lt;p&gt;### &lt;strong&gt;Chapter 5: The project management process group&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Introduction: Project management consists of 10 areas of knowledge (Integration, scope, schedule, cost, quality, resource, communication risk, procurement, and stakeholder management)&lt;/p&gt;
&lt;p&gt;Project involves five project management: Initial, planning executing monitoring controlling and closing.&lt;/p&gt;
&lt;p&gt;Project management process group and knowledge: process is a series of actions directed toward a particular result.&lt;/p&gt;
&lt;p&gt;•  Project management process group&lt;/p&gt;
&lt;p&gt;o  Initiating processes&lt;/p&gt;
&lt;p&gt;o  Planning processes&lt;/p&gt;
&lt;p&gt;o  Executing processes&lt;/p&gt;
&lt;p&gt;o  Monitoring and controlling processes&lt;/p&gt;
&lt;p&gt;o  Closing processes&lt;/p&gt;
&lt;p&gt;•  Characteristics of process group&lt;/p&gt;
&lt;p&gt;o  Executing tasks requires the most resource and time&lt;/p&gt;
&lt;p&gt;o  Monitoring and controlling done throughout the project life span&lt;/p&gt;
&lt;p&gt;o  Initiating and closing tasks are the shortest. Required least amount of resource and time.&lt;/p&gt;
&lt;p&gt;•  Mapping process group with knowledge area&lt;/p&gt;
&lt;p&gt;1.initial project and output for Project integration and stakeholder management&lt;/p&gt;
&lt;p&gt;•  Identifying project stakeholders&lt;/p&gt;
&lt;p&gt;o  Internal project stakeholders: include project sensor, project team.&lt;/p&gt;
&lt;p&gt;o  External project stakeholders: project customers (if they are external the company) supplier.&lt;/p&gt;
&lt;p&gt;Stakeholder register: is a document details related to identify project but not include sensitive detail.&lt;/p&gt;
&lt;p&gt;Stakeholder analysis is a technique for analyzing information&lt;/p&gt;
&lt;p&gt;1: Low interest/ high power (keep satisfied)&lt;/p&gt;
&lt;p&gt;2: High power / high interest (manage closely)&lt;/p&gt;
&lt;p&gt;3: Low interest / low power (monitor)&lt;/p&gt;
&lt;p&gt;4: High interest/low power (keep informed)&lt;/p&gt;
&lt;p&gt;•  Creating the project charter:&lt;/p&gt;
&lt;p&gt;o  is a document that formally recognizes the existence of a project and summarizes.&lt;/p&gt;
&lt;p&gt;o  Authorize the project manager to use organization resources&lt;/p&gt;
&lt;p&gt;o  Have sign-off&lt;/p&gt;
&lt;p&gt;o  Summary scheduled timeline + data + manager name + estimate cost + project objective.&lt;/p&gt;
&lt;p&gt;•  Creating the assumption log: It is a document used to record and track assumptions and constraints thought out the project lifecycle. include scope, time, cost, risk, and knowledge area.&lt;/p&gt;
&lt;p&gt;•  Holding a kick-off meeting: a meeting held at the beginning of a project so that stakeholders can meet each other, review the goals of the project.&lt;/p&gt;
&lt;p&gt;### &lt;strong&gt;Chapter 6: Planning projects&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;\2. Planning project and output for project integration and scope management&lt;/p&gt;
&lt;p&gt;According to the table, describe meaning below,&lt;/p&gt;
&lt;p&gt;•  Project integration management involves coordinating all the project management knowledge&lt;/p&gt;
&lt;p&gt;•  Project management plans are a document used to integrate and coordinate all project planning documents. E.g., scope management plan, requirement management plan, scheduled management plan, Cost management plan. It must be dynamic, flexible, and receptive to change when the environment changes.&lt;/p&gt;
&lt;p&gt;•  Project scope management involves defending and controlling what work is or is not included in a project.&lt;/p&gt;
&lt;p&gt;•  Planning scope management: How project will define (validation: acceptation delivery by customer verification done by controlling quality)&lt;/p&gt;
&lt;p&gt;•  Scope management plan: this information will describe in scope management plan e.g., preparing a detailed project scope statement, creating, maintenance and approving WBS.&lt;/p&gt;
&lt;p&gt;•  Requirement management plan: describe how project requirements will be analyzed, documented, and managed.&lt;/p&gt;
&lt;p&gt;•  Requirement documents: text, diagram, image, table&lt;/p&gt;
&lt;p&gt;•  Requirement traceability matrix: table list requirements, many attributes of each requirement.&lt;/p&gt;
&lt;p&gt;•  Work Break Down structure (WBS): is a deliverable oriented grouping of the work involved in a project. Often shows in different forms (Graphical or char form / Tabular or list form)&lt;/p&gt;
&lt;p&gt;o  Work package: is deliverable to the lowest level of the WBS. Each package should have cost, time. It shows in level of the detail deep down. Or it could be a mind map.&lt;/p&gt;
&lt;p&gt;Integration planning for Agile/hybrid&lt;/p&gt;
&lt;p&gt;•  Scrum&lt;/p&gt;
&lt;p&gt;To priorities requirements MoSCoW&lt;/p&gt;
&lt;p&gt;o  M: Must have&lt;/p&gt;
&lt;p&gt;o  S: should have&lt;/p&gt;
&lt;p&gt;o  C: could have&lt;/p&gt;
&lt;p&gt;o  W: Will not have&lt;/p&gt;
&lt;p&gt;Story cards – contain user stories written on index cards (INVEST)&lt;/p&gt;
&lt;p&gt;o  Independent: can be completed on its own&lt;/p&gt;
&lt;p&gt;o  Negotiable: One or two sentences long. Can work out through the discussion&lt;/p&gt;
&lt;p&gt;o  Valuable: Provide value to customers&lt;/p&gt;
&lt;p&gt;o  Estimable: A good approximation&lt;/p&gt;
&lt;p&gt;o  Small: can be completed within one iteration&lt;/p&gt;
&lt;p&gt;o  Testable: know when it is complete&lt;/p&gt;
&lt;p&gt;### &lt;strong&gt;Chapter summary&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;•  Project planning: to guild execution.&lt;/p&gt;
&lt;p&gt;•  Project execution: this part takes the most resource.&lt;/p&gt;
&lt;p&gt;•  Project monitor and controlling: Involves measuring progress toward project objectives, monitoring, and taking correction actions.&lt;/p&gt;
&lt;p&gt;•  Project closing: Involves gaining stakeholders and customers&#39; acceptance of the final products and services.&lt;/p&gt;
&lt;p&gt;•  SCRUM&lt;/p&gt;
&lt;p&gt;o  Roles&lt;/p&gt;
&lt;p&gt;  Product owner: person responsible for the business value of the project. Make decisions in product backlog.&lt;/p&gt;
&lt;p&gt;  Scrum Master: encourage team to deductive, facilitates the daily scrum. Remove barriers that prevent the team from being effective.&lt;/p&gt;
&lt;p&gt;  Scrum team/ development team: five-nine people in the team. Work and reduce result in each sprint.&lt;/p&gt;
&lt;p&gt;o  Artifacts&lt;/p&gt;
&lt;p&gt;  Product backlog: feature priorities by business value.&lt;/p&gt;
&lt;p&gt;  Sprint backlog: highest priority from product backlog.&lt;/p&gt;
&lt;p&gt;  Burndown chart: showing work remains.&lt;/p&gt;
&lt;p&gt;o  Ceremonies&lt;/p&gt;
&lt;p&gt;  Sprint planning session: pull the activity from product backlog into scrum backlog.&lt;/p&gt;
&lt;p&gt;  Daily scrum: development team share progress and discussion challenge of work.&lt;/p&gt;
&lt;p&gt;  Sprint review: Demonstrate to product owner what have been complete.&lt;/p&gt;
&lt;p&gt;  Sprint retrospective: improve product and processes.&lt;/p&gt;
&lt;p&gt;### &lt;strong&gt;Chapter 7: Project planning – schedule and cost management&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.initial project and output for project schedule and cost management&lt;/p&gt;
&lt;p&gt;According to the table, describe meaning below,&lt;/p&gt;
&lt;p&gt;•  Project scheduled management: ensure timely completion of the project.&lt;/p&gt;
&lt;p&gt;•  Defining activities is to ensure that project team members have a complete understanding of all the work they must do so that they can start scheduling the work.&lt;/p&gt;
&lt;p&gt;•  Activity list and attributes is a table of activity to be included on a project scheduled. It should have an activity name, activity identifier brief description. We also can use WBS (work breakdown structure) for activity list.&lt;/p&gt;
&lt;p&gt;•  Milestone: is a significant point or event in a project. (No cost or duration). It helps marker identifies necessary activity.&lt;/p&gt;
&lt;p&gt;o  Best Practice (S=Specific M=Measurable A=Assignable R=Realistic T=Timeframe)&lt;/p&gt;
&lt;p&gt;o  Milestone can help reduce the scheduled risk – each milestone must be binary (complete or incomplete)&lt;/p&gt;
&lt;p&gt;•  Sequence activity: review activity list. Check the relation of tasks e.g., if this is not complete, other tasks can start? Is it overlap to other tasks?&lt;/p&gt;
&lt;p&gt;o  Reason for creating dependency&lt;/p&gt;
&lt;p&gt;  Mandatory dependencies: eg cannot hold training classes until the training materials are ready.&lt;/p&gt;
&lt;p&gt;  Discretionary dependencies: eg not start design until key stakeholders sign off.&lt;/p&gt;
&lt;p&gt;  External dependencies: involve relationship between project and non-project activity. E.g., installation of new software related to delivery of new hardware.&lt;/p&gt;
&lt;p&gt;  Internal dependencies: within project team control.&lt;/p&gt;
&lt;p&gt;•  Network diagram: showing activity sequence.&lt;/p&gt;
&lt;p&gt;o  Active-on-arrow (AOA): arrows are connected points called nodes.&lt;/p&gt;
&lt;p&gt;o  Step for creating an AOA network diagram&lt;/p&gt;
&lt;p&gt;  Find all activity&lt;/p&gt;
&lt;p&gt;  Continue drawing network diagram from left to right.&lt;/p&gt;
&lt;p&gt;  Line having duration of activities.&lt;/p&gt;
&lt;p&gt;o  Activity on node (PDM): network diagramming technique. Show all dependencies points.&lt;/p&gt;
&lt;p&gt;•  Duration estimation&lt;/p&gt;
&lt;p&gt;o  Duration: total time to complete the work activities.&lt;/p&gt;
&lt;p&gt;o  Effort: number of work units required to complete the activity.&lt;/p&gt;
&lt;p&gt;o  Elapsed time: Calander time or span required to complete.&lt;/p&gt;
&lt;p&gt;•  PERT&lt;/p&gt;
&lt;p&gt;•  Developing the project schedule: use result of all preceding project time manages processes to determine the start and end dates.&lt;/p&gt;
&lt;p&gt;Critical Path analysis: is a network diagramming technique used to predict total project duration. To find the earliest time by which the project can be completed.&lt;/p&gt;
&lt;p&gt;It is important because project managers can make trade-offs.&lt;/p&gt;
&lt;p&gt;•  Crashing: techniques for making cost and scheduled trade-off to obtain greatest amount.&lt;/p&gt;
&lt;p&gt;•  Fast Tracking: involve doing activities in parallel&lt;/p&gt;
&lt;p&gt;•  Scheduled compression: backfire by causing cost.&lt;/p&gt;
&lt;p&gt;Critical Chain scheduling: method of scheduling that considers limited resources when creating a project scheduled.&lt;/p&gt;
&lt;p&gt;Project cost Management: to ensure that the project team complete the project within an approved budget.&lt;/p&gt;
&lt;p&gt;Estimating cost: prepare cost estimates at various stages of a project. Important to provide the support details. Cost Estimating techniques&lt;/p&gt;
&lt;p&gt;•  Analogous estimates: use the actual cost of the previous, similar project&lt;/p&gt;
&lt;p&gt;•  Bottom up: involve estimating individual activity and summing them to get the project total.&lt;/p&gt;
&lt;p&gt;•  Parametric: use the project characteristic (math) to help calculate them.&lt;/p&gt;
&lt;p&gt;Cost estimating process 1) summary information 2) consult with internal and external experts and organize assistant.&lt;/p&gt;
&lt;p&gt;Cost budget: the main goal of the cost budget is a cost baseline.&lt;/p&gt;
&lt;p&gt;### &lt;strong&gt;Chapter 8:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4.Planning Processes and Outputs for Project Quality, Human Resource, Communications, Risk, Procurement, and Stakeholder Management&lt;/p&gt;
&lt;p&gt;Project quality management : ensure that the project will satisfy the state or implied needs.&lt;/p&gt;
&lt;p&gt;•  What is quality: the degree to which a set of inherent characteristics fulfull requirements.&lt;/p&gt;
&lt;p&gt;o  Conformance to requirements: project and product meet specification&lt;/p&gt;
&lt;p&gt;o  Fitness for use: product can be used as it was intended.&lt;/p&gt;
&lt;p&gt;•  Quality metrics: metric is a standard of measurement.&lt;/p&gt;
&lt;p&gt;o  Sample quality Metrix: customer satisfaction rating. Complete the project within one year.&lt;/p&gt;
&lt;p&gt;Project resource management is concerned with making effective use of the people involved with a project as well as physical resources.&lt;/p&gt;
&lt;p&gt;•  Team management plan&lt;/p&gt;
&lt;p&gt;o  Project organization charts are a graphical representation of how authority and responsibility is distributed within the project.&lt;/p&gt;
&lt;p&gt;o  Responsibility assignment Metris is a matrix that maps the work of the project as described in the WBS to the people responsible for performing the work.&lt;/p&gt;
&lt;p&gt;o  Resource Histograms is showing number of resources required for a project overtime.&lt;/p&gt;
&lt;p&gt;o  Staffing management plans: how people will be added and removed from a project.&lt;/p&gt;
&lt;p&gt;Team charter: help promote teamwork and clarify team communication.&lt;/p&gt;
&lt;p&gt;Estimating activity Resource: need to realize about how difficult, how unique, how specific resource.&lt;/p&gt;
&lt;p&gt;Project stakeholders&#39; management: engage stakeholders in project decision and activity based on their needs interest and potential impact.&lt;/p&gt;
&lt;p&gt;Project risk management: an uncertainty that can have a negative or positive effect on meeting project objectives. Risk management plan should include responsibility, budget, schedule estimates, risk categories, probability, and impact metrices.&lt;/p&gt;
&lt;p&gt;•  Risk event&lt;/p&gt;
&lt;p&gt;o  Negative risk event: include performance failure (increase cost, delay)&lt;/p&gt;
&lt;p&gt;o  Positive risk event: include completing work sooner (unexpected reduce cost)&lt;/p&gt;
&lt;p&gt;•  Performing Qualitative Risk Analysis: Prioritizing high, medium, low. Quantitative risk analysis techniques include decision tree analysis, simulation, influence diagram.&lt;/p&gt;
&lt;p&gt;•  Planning risk response&lt;/p&gt;
&lt;p&gt;o  Negative risk responses: Escalation of risk, Risk avoidance, Risk acceptance&lt;/p&gt;
&lt;p&gt;o  Positive risk responses: Escalation of risk, Risk sharing, Risk acceptance.&lt;/p&gt;
&lt;p&gt;•  Risk register: document that contains many risk management processes shown in table.&lt;/p&gt;
&lt;p&gt;Project procurement Management: make-or-buy analysis, comparing cost.&lt;/p&gt;
&lt;p&gt;Change management model: including A: Awareness D: Desire K: Knowledge A: Ability R: Reinforcement.&lt;/p&gt;
&lt;p&gt;Each role working for these tasks below,&lt;/p&gt;
&lt;p&gt;•  Project integration management: develop project management plan&lt;/p&gt;
&lt;p&gt;•  Project scope management: plan scope management&lt;/p&gt;
&lt;p&gt;•  Project cost management: Estimate cost&lt;/p&gt;
&lt;p&gt;•  Project Risk management: plan risk response, identify risk.&lt;/p&gt;
&lt;p&gt;### &lt;strong&gt;Chapter 9:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;\5. Executing Processes and Outputs&lt;/p&gt;
&lt;p&gt;Issue log: help to document, monitor and track issues.&lt;/p&gt;
&lt;p&gt;Change request: often that request for change happens during project execution. Process for handling change should be defined due to project planning. Due to project execution should request appropriate for the change.&lt;/p&gt;
&lt;p&gt;Conflict handling process:&lt;/p&gt;
&lt;p&gt;Quality&lt;/p&gt;
&lt;p&gt;•  Managing Quality: Quality assurance includes all activities related to satisfying. Key outputs of managing quality include quality report, test and evaluation documents, change requests.&lt;/p&gt;
&lt;p&gt;•  Quality improves tools&lt;/p&gt;
&lt;p&gt;o  Benchmarking: generates ideas for quality improvements by comparing specific project practice. E.g, training costs per employee and course ratings are benchmarks.&lt;/p&gt;
&lt;p&gt;o  A quality audit: it is a structure review of specific quality management. Lesson learns, improvement in the future project.&lt;/p&gt;
&lt;p&gt;o  Process analysis: it involves how processes operate and determining improvements. E.g. Kanban to do, in progress, done.&lt;/p&gt;
&lt;p&gt;Project resource management: effective use of resources is crucial to project execution.&lt;/p&gt;
&lt;p&gt;•  Dealing with people: before discussing resource assignments, it’s important to understand basic concept to deal with people in a work setting.&lt;/p&gt;
&lt;p&gt;•  Motivation:&lt;/p&gt;
&lt;p&gt;o  Intrinsic motivation: cause people to participate in an activity for their own enjoyment.&lt;/p&gt;
&lt;p&gt;o  Extrinsic motivation: cause people to do something for a reward or to avoid penalty.&lt;/p&gt;
&lt;p&gt;•  Acquiring Resource: The problems occur when assigning resources are availability and overallocation. project resource includes&lt;/p&gt;
&lt;p&gt;o  Physical resources: equipment, supplies, and materials.&lt;/p&gt;
&lt;p&gt;o  Human resources: people required to perform project work.&lt;/p&gt;
&lt;p&gt;•  Resource Loading: refers to the amount of individual resources and exiting schedule requires during specific time periods. “Overallocations mean more resources than what we are available assigned to task”&lt;/p&gt;
&lt;p&gt;•  Resource Leveling: it is a technique for resolving resource conflicts by delaying tasks. The main purpose of resource leveling is to create a smoother distribution of resources usage and reduce overallocation.&lt;/p&gt;
&lt;p&gt;Project stakeholder management: the process of managing stakeholder engagement involves working with many project stakeholders to meet their needs and expectations. “If done well, it allows project managers to increase support minimize resistance from stakeholders, increasing change to achieve project success”&lt;/p&gt;
&lt;p&gt;•  Managing Stakeholder engagement: need actively to engage project stakeholders. Need to set the stage early so stakeholder engagement is expected and welcomed.&lt;/p&gt;
&lt;p&gt;### &lt;strong&gt;Chapter 10:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Project Integration Management: main monitoring and controlling processes performed as a part of project integration.&lt;/p&gt;
&lt;p&gt;Forecasting with Earn value management: Earn value management (EVM) is a project performance measurement technique that integrates scope, time and cost. Baseline use for checking how well the project is meeting scope, time and cost goals by comparing baseline.&lt;/p&gt;
&lt;p&gt;•  Baseline information includes&lt;/p&gt;
&lt;p&gt;o  Scope data (WBS tasks)&lt;/p&gt;
&lt;p&gt;o  Time data (start and finish estimates for each task)&lt;/p&gt;
&lt;p&gt;o  Cost data (cost estimates for each task)&lt;/p&gt;
&lt;p&gt;Project Planning:&lt;/p&gt;
&lt;p&gt;•  Gether work performance information: project manager much get these task&lt;/p&gt;
&lt;p&gt;o  Budget at completion (BAC) it represents the original project budget.&lt;/p&gt;
&lt;p&gt;o  Plan value(PV):  budget cost for work scheduled&lt;/p&gt;
&lt;p&gt;PV.= Total project cost X % of planned work&lt;/p&gt;
&lt;p&gt;o  Actual cost (AC): actual cost of work performed. It includes several hidden costs. The value is straight forward, does not need to calculate.&lt;/p&gt;
&lt;p&gt;In our example, let’s assume, AC at the end of 2 months = $15000&lt;/p&gt;
&lt;p&gt;o  Earn value (EV): At the end of 2 months, plan to completed 40% but finish 30%.&lt;/p&gt;
&lt;p&gt;EV = Total project cost X % of actual work = $25000 X 30% = $7500&lt;/p&gt;
&lt;p&gt;•  Determie scheduled Status:&lt;/p&gt;
&lt;p&gt;o  Ahead or behind our scheduled&lt;/p&gt;
&lt;p&gt;o  Under or above the estimated cost.&lt;/p&gt;
&lt;p&gt;•  Variance Analysis: how far off we are from the project baseline&lt;/p&gt;
&lt;p&gt;o  Scheduled status&lt;/p&gt;
&lt;p&gt;  Schedule variance (SV) quantitative indicator of divergence from initial planned scheduled.&lt;/p&gt;
&lt;p&gt;•  Negative SV = behind / positive SV = ahead / 0 = on scheduled&lt;/p&gt;
&lt;p&gt;SV = EV-PV&lt;/p&gt;
&lt;p&gt;Example: SV at 2 months = $7500-$10000 =$2500&lt;/p&gt;
&lt;p&gt;SV% = (SV/PV) &lt;strong&gt;100 = $2500/$10000&lt;/strong&gt;100 = -25%&lt;/p&gt;
&lt;p&gt;*&lt;em&gt;Mean behind the scheduled.&lt;/em&gt; *&lt;/p&gt;
&lt;p&gt;  Schedule performance index (SPI) project performance from variance.&lt;/p&gt;
&lt;p&gt;•  SPI = EV/PV&lt;/p&gt;
&lt;p&gt;•  SPI &amp;gt; 1 = ahead of scheduled / SPI &amp;lt; 1 = behind the scheduled. Greater than 1.0 is good.&lt;/p&gt;
&lt;p&gt;Example SPI=$7500/$10000=0.75 indicating the project is only going 75% as per the original plan or it is 25% behind scheduled.&lt;/p&gt;
&lt;p&gt;  Cost performance Index (CPI) gives a sense of project performance from a cost perspective.&lt;/p&gt;
&lt;p&gt;•  CPI=EV/AC&lt;/p&gt;
&lt;p&gt;•  CPI &amp;gt; 1 indicates project under budget and CPI &amp;lt; 1 indicates project is over budget.&lt;/p&gt;
&lt;p&gt;Example CPI = $7500/$15000 = 0.5&lt;/p&gt;
&lt;p&gt;o  CPI=0.5 twice amount that should have this point.&lt;/p&gt;
&lt;p&gt;o  CPI=1.0 project on scheduled&lt;/p&gt;
&lt;p&gt;o  CPI=2.0 spend half amount that should have this point&lt;/p&gt;
&lt;p&gt;•  Interpreting Earned Value Number: Negative number mean the project is costing more than planned or taking longer than planned.&lt;/p&gt;
&lt;p&gt;•  Earn value Forecasting contains four calculations&lt;/p&gt;
&lt;p&gt;o  Estimate to complete (ETC) exceed cost require to complete&lt;/p&gt;
&lt;p&gt;o  Estimate at completion (EAC) full task or project cost expected at completion&lt;/p&gt;
&lt;p&gt;o  Variance at completion (VAC) is. Forecast of what the variance, specifically the Cost Variance (CV), will be upon the completion of the project.&lt;/p&gt;
&lt;p&gt;o  To complete performance Index (TCPI) represents the efficiency level, specifically the CPI, that will make the project finish on time.&lt;/p&gt;
&lt;p&gt;Project quality management:&lt;/p&gt;
&lt;p&gt;•  Quantity mean a product should meet its specification.&lt;/p&gt;
&lt;p&gt;•  Challenge of software quality&lt;/p&gt;
&lt;p&gt;•  Quality control tools:&lt;/p&gt;
&lt;p&gt;o  Cause and effect diagram&lt;/p&gt;
&lt;p&gt;o  Check sheet&lt;/p&gt;
&lt;p&gt;o  Control charts&lt;/p&gt;
&lt;p&gt;o  Histograms&lt;/p&gt;
&lt;p&gt;o  Pareto charts&lt;/p&gt;
&lt;p&gt;o  Scatter diagram&lt;/p&gt;
&lt;p&gt;o  Stratification&lt;/p&gt;
&lt;p&gt;### &lt;strong&gt;Chapter 11:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;\6. Closing output&lt;/p&gt;
&lt;p&gt;Closing output:&lt;/p&gt;
&lt;p&gt;•  Project document updates: All project documents should be reviewed and marked as final version.&lt;/p&gt;
&lt;p&gt;•  Final product, service, or result transition: Project sponsors are usually most interested in all delivery to the appropriate part of organization.&lt;/p&gt;
&lt;p&gt;•  Final project reports and presentation are commonly created during project closing.&lt;/p&gt;
&lt;p&gt;•  Update to organization process assets: During closing the project team should update appropriate process assets, especially the lessons learned repository.&lt;/p&gt;
&lt;p&gt;### &lt;strong&gt;Chapter 12:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;What is PRINCE2: structure project management method. Emphasizes dividing projects into manageable and controllable stages.&lt;/p&gt;
&lt;p&gt;7 Processes of PRINCE2:&lt;/p&gt;
&lt;p&gt;•  Starting a project: customer submit a new request for a new project. It is called “Project mandate.”&lt;/p&gt;
&lt;p&gt;•  Directing a project: assign to project manager.&lt;/p&gt;
&lt;p&gt;•  Initiating a project: Project manager prepares a plan such as cost, time required.&lt;/p&gt;
&lt;p&gt;•  Controlling a stage: subdivided into stages and teams are assigned for each stage.&lt;/p&gt;
&lt;p&gt;•  Managing Product delivery: Project manager make sure that there is no gap between deliverable and quality expectations.&lt;/p&gt;
&lt;p&gt;•  Managing a state boundary: manager and board will review the outcomes. Ensure the projects are on the right track.&lt;/p&gt;
&lt;p&gt;•  Closing a project: mark the closing of the outcome, documentation, and reporting.&lt;/p&gt;
&lt;p&gt;Type of PRINCE2 documentation&lt;/p&gt;
&lt;p&gt;•  Business case: detailed description of why the project needed.&lt;/p&gt;
&lt;p&gt;•  Risk register: Lists the probability and potential impacts of risks and opportunities.&lt;/p&gt;
&lt;p&gt;•  Quality register: A running log of quality checks ensure deliverable meet expectations.&lt;/p&gt;
&lt;p&gt;•  Issue register: a list of problem and concern.&lt;/p&gt;
&lt;p&gt;•  Lessons log: net on lesson learn to apply to next work stage.&lt;/p&gt;
&lt;p&gt;•  Daily log: daily diary written by project manager report activity and progress.&lt;/p&gt;
&lt;p&gt;Summary documentation in each stage of PRINCE2&lt;/p&gt;
&lt;p&gt;Additional Agile information&lt;/p&gt;
&lt;p&gt;Scheduled for Agile Project: instead of creating details scheduled for all of the activity, agile teams focus on the most valuable work they complete within each iteration. “Time-Boxing” - it’s a previous agree upon time.&lt;/p&gt;
&lt;p&gt;Cost planning for Agile Project: Unlike predictive project, there is no total project budget, detailed or cost estimate for entire project for agile project.&lt;/p&gt;
&lt;p&gt;Agile with risk and procurement: agile can use any predictive project plan process tools in this step. E.g., using survey evaluations.&lt;/p&gt;
&lt;p&gt;Agile estimating methods: predictive&lt;/p&gt;
&lt;p&gt;•  T-shirt sizing: S, M, L, XL, XXL&lt;/p&gt;
&lt;p&gt;•  Planning poker: each team member estimates user stories with number cards.&lt;/p&gt;
&lt;p&gt;•  The bucket system: Extension of planning poker when there are many user stories, and the team is large.&lt;/p&gt;
&lt;p&gt;Agile Quality planning:&lt;/p&gt;
&lt;p&gt;•  Definition of Done: a list of criteria which must be met before a product increment ‘often a user story’ is considered ‘done’&lt;/p&gt;
&lt;p&gt;Agile resource planning: Different resource planning between predictive and agile is instead of project manager assign people tasks, in agile team will self-manage. They decide who will work on the tasks themselves.&lt;/p&gt;
&lt;p&gt;Agile stakeholders planning: at the end of the sprint; sprint review meeting allows key stakeholders to inspect the outcomes of each sprint and determine future adaptations.&lt;/p&gt;
&lt;p&gt;Agile risk planning: Emphasizing value to customers, prioritizing work and collaborating as a team focused on one sprint goal at a time.&lt;/p&gt;
&lt;p&gt;Monitor and control Agile: There are 2 meetings as monitoring 1) Daily scrum 2) Sprint review.&lt;/p&gt;
&lt;p&gt;More information: burn down chart – showing how much work remains. Burn up chart – showing how much work is complete. Combined burn chart – showing both how much work remains and how much work has been completed.&lt;/p&gt;
&lt;p&gt;Closing Agile project: the same as predictive project, agile and hybrid projects should be closed.&lt;/p&gt;
">关于课程Software Prjct Man & Secur Dev的一些总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/java-ji-he/"" data-c="
          &lt;h2 id=&#34;集合概述&#34;&gt;集合概述&lt;/h2&gt;
&lt;h3 id=&#34;java-集合概览&#34;&gt;Java 集合概览&lt;/h3&gt;
&lt;p&gt;Java 集合， 也叫作容器，主要包括 Collection 和 Map 两种，Collection 又包含了 List、Set 以及 Queue。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/java-collection-hierarchy.71519bdb.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;list-set-queue-map-四者的区别&#34;&gt;List, Set, Queue, Map 四者的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;List&lt;/code&gt;: 存储的元素是有序的、可重复的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Set&lt;/code&gt;: 存储的元素是无序的、不可重复的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Queue&lt;/code&gt;(实现排队功能): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map&lt;/code&gt;(用 key 来搜索): 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;集合框架底层数据结构总结&#34;&gt;集合框架底层数据结构总结&lt;/h3&gt;
&lt;h4 id=&#34;list&#34;&gt;List&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Arraylist&lt;/code&gt;： &lt;code&gt;Object[]&lt;/code&gt; 数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vector&lt;/code&gt;：&lt;code&gt;Object[]&lt;/code&gt; 数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedList&lt;/code&gt;： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;set&#34;&gt;Set&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HashSet&lt;/code&gt;(无序，唯一): 基于 &lt;code&gt;HashMap&lt;/code&gt; 实现的，底层采用 &lt;code&gt;HashMap&lt;/code&gt; 来保存元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedHashSet&lt;/code&gt;: &lt;code&gt;LinkedHashSet&lt;/code&gt; 是 &lt;code&gt;HashSet&lt;/code&gt; 的子类，并且其内部是通过 &lt;code&gt;LinkedHashMap&lt;/code&gt; 来实现的。有点类似于我们之前说的 &lt;code&gt;LinkedHashMap&lt;/code&gt; 其内部是基于 &lt;code&gt;HashMap&lt;/code&gt; 实现一样，不过还是有一点点区别的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TreeSet&lt;/code&gt;(有序，唯一): 红黑树(自平衡的排序二叉树)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;queue&#34;&gt;Queue&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PriorityQueue&lt;/code&gt;: &lt;code&gt;Object[]&lt;/code&gt; 数组来实现二叉堆&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ArrayQueue&lt;/code&gt;: &lt;code&gt;Object[]&lt;/code&gt; 数组 + 双指针&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;map&#34;&gt;Map&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HashMap&lt;/code&gt;： JDK1.8 之前 &lt;code&gt;HashMap&lt;/code&gt; 由数组+链表组成的，数组是 &lt;code&gt;HashMap&lt;/code&gt; 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;： &lt;code&gt;LinkedHashMap&lt;/code&gt; 继承自 &lt;code&gt;HashMap&lt;/code&gt;，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，&lt;code&gt;LinkedHashMap&lt;/code&gt; 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：&lt;a href=&#34;https://www.imooc.com/article/22931&#34;&gt;《LinkedHashMap 源码详细分析（JDK1.8）》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt;： 数组+链表组成的，数组是 &lt;code&gt;Hashtable&lt;/code&gt; 的主体，链表则是主要为了解决哈希冲突而存在的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TreeMap&lt;/code&gt;： 红黑树（自平衡的排序二叉树）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何选用集合&#34;&gt;如何选用集合?&lt;/h3&gt;
&lt;p&gt;主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 &lt;code&gt;Map&lt;/code&gt; 接口下的集合，需要排序时选择 &lt;code&gt;TreeMap&lt;/code&gt;,不需要排序时就选择 &lt;code&gt;HashMap&lt;/code&gt;,需要保证线程安全就选用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当我们只需要存放元素值时，就选择实现&lt;code&gt;Collection&lt;/code&gt; 接口的集合，需要保证元素唯一时选择实现 &lt;code&gt;Set&lt;/code&gt; 接口的集合比如 &lt;code&gt;TreeSet&lt;/code&gt; 或 &lt;code&gt;HashSet&lt;/code&gt;，不需要就选择实现 &lt;code&gt;List&lt;/code&gt; 接口的比如 &lt;code&gt;ArrayList&lt;/code&gt; 或 &lt;code&gt;LinkedList&lt;/code&gt;，然后再根据实现这些接口的集合的特点来选用。&lt;/p&gt;
&lt;h2 id=&#34;collection-子接口之-list&#34;&gt;Collection 子接口之 List&lt;/h2&gt;
&lt;h3 id=&#34;arraylist-和-vector-的区别&#34;&gt;Arraylist 和 Vector 的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ArrayList&lt;/code&gt; 是 &lt;code&gt;List&lt;/code&gt; 的主要实现类，底层使用 &lt;code&gt;Object[ ]&lt;/code&gt;存储，适用于频繁的查找工作，线程不安全 ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vector&lt;/code&gt; 是 &lt;code&gt;List&lt;/code&gt; 的古老实现类，底层使用&lt;code&gt;Object[ ]&lt;/code&gt; 存储，线程安全的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;arraylist-与-linkedlist-区别&#34;&gt;Arraylist 与 LinkedList 区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;是否保证线程安全：&lt;/strong&gt; &lt;code&gt;ArrayList&lt;/code&gt; 和 &lt;code&gt;LinkedList&lt;/code&gt; 都是不同步的，也就是不保证线程安全；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;底层数据结构：&lt;/strong&gt; &lt;code&gt;Arraylist&lt;/code&gt; 底层使用的是 &lt;strong&gt;&lt;code&gt;Object&lt;/code&gt; 数组&lt;/strong&gt;；&lt;code&gt;LinkedList&lt;/code&gt; 底层使用的是 &lt;strong&gt;双向链表&lt;/strong&gt; 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;插入和删除是否受元素位置的影响：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ArrayList&lt;/code&gt; 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行&lt;code&gt;add(E e)&lt;/code&gt;方法的时候， &lt;code&gt;ArrayList&lt;/code&gt; 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（&lt;code&gt;add(int index, E element)&lt;/code&gt;）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedList&lt;/code&gt; 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（&lt;code&gt;add(E e)&lt;/code&gt;、&lt;code&gt;addFirst(E e)&lt;/code&gt;、&lt;code&gt;addLast(E e)&lt;/code&gt;、&lt;code&gt;removeFirst()&lt;/code&gt; 、 &lt;code&gt;removeLast()&lt;/code&gt;），近似 O(1)，如果是要在指定位置 &lt;code&gt;i&lt;/code&gt; 插入和删除元素的话（&lt;code&gt;add(int index, E element)&lt;/code&gt;，&lt;code&gt;remove(Object o)&lt;/code&gt;） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;是否支持快速随机访问：&lt;/strong&gt; &lt;code&gt;LinkedList&lt;/code&gt; 不支持高效的随机元素访问，而 &lt;code&gt;ArrayList&lt;/code&gt; 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于&lt;code&gt;get(int index)&lt;/code&gt;方法)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存空间占用：&lt;/strong&gt; ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;https://juejin.cn/post/6844903648154271757)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;randomaccess-接口&#34;&gt;RandomAccess 接口&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface RandomAccess {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看源码我们发现实际上 &lt;code&gt;RandomAccess&lt;/code&gt; 接口中什么都没有定义。 &lt;code&gt;RandomAccess&lt;/code&gt; 接口标识实现这个接口的类具有随机访问功能。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;binarySearch（)&lt;/code&gt; 方法中，它要判断传入的 list 是否 &lt;code&gt;RamdomAccess&lt;/code&gt; 的实例，如果是，调用&lt;code&gt;indexedBinarySearch()&lt;/code&gt;方法，如果不是，那么调用&lt;code&gt;iteratorBinarySearch()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static &amp;lt;T&amp;gt;
    int binarySearch(List&amp;lt;? extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; list, T key) {
        if (list instanceof RandomAccess || list.size()&amp;lt;BINARYSEARCH_THRESHOLD)
            return Collections.indexedBinarySearch(list, key);
        else
            return Collections.iteratorBinarySearch(list, key);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; 实现了 &lt;code&gt;RandomAccess&lt;/code&gt; 接口， 而 &lt;code&gt;LinkedList&lt;/code&gt; 没有实现。为什么呢？我觉得还是和底层数据结构有关！&lt;code&gt;ArrayList&lt;/code&gt; 底层是数组，而 &lt;code&gt;LinkedList&lt;/code&gt; 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，&lt;code&gt;ArrayList&lt;/code&gt; 实现了 &lt;code&gt;RandomAccess&lt;/code&gt; 接口，就表明了他具有快速随机访问功能。 &lt;code&gt;RandomAccess&lt;/code&gt; 接口只是标识，并不是说 &lt;code&gt;ArrayList&lt;/code&gt; 实现 &lt;code&gt;RandomAccess&lt;/code&gt; 接口才具有快速随机访问功能的！&lt;/p&gt;
&lt;h3 id=&#34;arraylist-的扩容机制&#34;&gt;ArrayList 的扩容机制&lt;/h3&gt;
&lt;p&gt;详见:&lt;a href=&#34;https://snailclimb.gitee.io/javaguide/#/docs/java/collection/arraylist-source-code?id=_2-arraylist-%e6%a0%b8%e5%bf%83%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb&#34;&gt;通过源码一步一步分析 ArrayList 扩容机制&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;collection-子接口之-set&#34;&gt;Collection 子接口之 Set&lt;/h2&gt;
&lt;h3 id=&#34;comparable-和-comparator-的区别&#34;&gt;comparable 和 Comparator 的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;comparable&lt;/code&gt; 接口实际上是出自&lt;code&gt;java.lang&lt;/code&gt;包 它有一个 &lt;code&gt;compareTo(Object obj)&lt;/code&gt;方法用来排序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;comparator&lt;/code&gt;接口实际上是出自 java.util 包它有一个&lt;code&gt;compare(Object obj1, Object obj2)&lt;/code&gt;方法用来排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般我们需要对一个集合使用自定义排序时，我们就要重写&lt;code&gt;compareTo()&lt;/code&gt;方法或&lt;code&gt;compare()&lt;/code&gt;方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写&lt;code&gt;compareTo()&lt;/code&gt;方法和使用自制的&lt;code&gt;Comparator&lt;/code&gt;方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 &lt;code&gt;Collections.sort()&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;comparator-定制排序&#34;&gt;Comparator 定制排序&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        // 定制排序的用法
        Collections.sort(arrayList, new Comparator&amp;lt;Integer&amp;gt;() {

            @Override
            public int compare(Integer o1, Integer o2) {
                return o2.compareTo(o1);
            }
        });
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;重写-compareto-方法实现按年龄来排序&#34;&gt;重写 compareTo 方法实现按年龄来排序&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列
// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他
// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了
public  class Person implements Comparable&amp;lt;Person&amp;gt; {
    private String name;
    private int age;

    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    /**
     * T重写compareTo方法实现按年龄来排序
     */
    @Override
    public int compareTo(Person o) {
        if (this.age &amp;gt; o.getAge()) {
            return 1;
        }
        if (this.age &amp;lt; o.getAge()) {
            return -1;
        }
        return 0;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static void main(String[] args) {
        TreeMap&amp;lt;Person, String&amp;gt; pdata = new TreeMap&amp;lt;Person, String&amp;gt;();
        pdata.put(new Person(&amp;quot;张三&amp;quot;, 30), &amp;quot;zhangsan&amp;quot;);
        pdata.put(new Person(&amp;quot;李四&amp;quot;, 20), &amp;quot;lisi&amp;quot;);
        pdata.put(new Person(&amp;quot;王五&amp;quot;, 10), &amp;quot;wangwu&amp;quot;);
        pdata.put(new Person(&amp;quot;小红&amp;quot;, 5), &amp;quot;xiaohong&amp;quot;);
        // 得到key的值的同时得到key所对应的值
        Set&amp;lt;Person&amp;gt; keys = pdata.keySet();
        for (Person key : keys) {
            System.out.println(key.getAge() + &amp;quot;-&amp;quot; + key.getName());

        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5-小红
10-王五
20-李四
30-张三
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;无序性和不可重复性的含义是什么&#34;&gt;无序性和不可重复性的含义是什么&lt;/h3&gt;
&lt;p&gt;1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。&lt;/p&gt;
&lt;p&gt;2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。&lt;/p&gt;
&lt;h3 id=&#34;比较-hashset-linkedhashset-和-treeset-三者的异同&#34;&gt;比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HashSet&lt;/code&gt;、&lt;code&gt;LinkedHashSet&lt;/code&gt; 和 &lt;code&gt;TreeSet&lt;/code&gt; 都是 &lt;code&gt;Set&lt;/code&gt; 接口的实现类，都能保证元素唯一，并且都不是线程安全的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HashSet&lt;/code&gt;、&lt;code&gt;LinkedHashSet&lt;/code&gt; 和 &lt;code&gt;TreeSet&lt;/code&gt; 的主要区别在于底层数据结构不同。&lt;code&gt;HashSet&lt;/code&gt; 的底层数据结构是哈希表（基于 &lt;code&gt;HashMap&lt;/code&gt; 实现）。&lt;code&gt;LinkedHashSet&lt;/code&gt; 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。&lt;code&gt;TreeSet&lt;/code&gt; 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。&lt;/li&gt;
&lt;li&gt;底层数据结构不同又导致这三者的应用场景不同。&lt;code&gt;HashSet&lt;/code&gt; 用于不需要保证元素插入和取出顺序的场景，&lt;code&gt;LinkedHashSet&lt;/code&gt; 用于保证元素的插入和取出顺序满足 FIFO 的场景，&lt;code&gt;TreeSet&lt;/code&gt; 用于支持对元素自定义排序规则的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;collection-子接口之-queue&#34;&gt;Collection 子接口之 Queue&lt;/h2&gt;
&lt;h3 id=&#34;queue-与-deque-的区别&#34;&gt;Queue 与 Deque 的区别&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Queue&lt;/code&gt; 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 &lt;strong&gt;先进先出（FIFO）&lt;/strong&gt; 规则。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Queue&lt;/code&gt; 扩展了 &lt;code&gt;Collection&lt;/code&gt; 的接口，根据 &lt;strong&gt;因为容量问题而导致操作失败后处理方式的不同&lt;/strong&gt; 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;Queue&lt;/code&gt; 接口&lt;/th&gt;
&lt;th&gt;抛出异常&lt;/th&gt;
&lt;th&gt;返回特殊值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;插入队尾&lt;/td&gt;
&lt;td&gt;add(E e)&lt;/td&gt;
&lt;td&gt;offer(E e)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除队首&lt;/td&gt;
&lt;td&gt;remove()&lt;/td&gt;
&lt;td&gt;poll()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;查询队首元素&lt;/td&gt;
&lt;td&gt;element()&lt;/td&gt;
&lt;td&gt;peek()&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;Deque&lt;/code&gt; 是双端队列，在队列的两端均可以插入或删除元素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Deque&lt;/code&gt; 扩展了 &lt;code&gt;Queue&lt;/code&gt; 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;Deque&lt;/code&gt; 接口&lt;/th&gt;
&lt;th&gt;抛出异常&lt;/th&gt;
&lt;th&gt;返回特殊值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;插入队首&lt;/td&gt;
&lt;td&gt;addFirst(E e)&lt;/td&gt;
&lt;td&gt;offerFirst(E e)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;插入队尾&lt;/td&gt;
&lt;td&gt;addLast(E e)&lt;/td&gt;
&lt;td&gt;offerLast(E e)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除队首&lt;/td&gt;
&lt;td&gt;removeFirst()&lt;/td&gt;
&lt;td&gt;pollFirst()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除队尾&lt;/td&gt;
&lt;td&gt;removeLast()&lt;/td&gt;
&lt;td&gt;pollLast()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;查询队首元素&lt;/td&gt;
&lt;td&gt;getFirst()&lt;/td&gt;
&lt;td&gt;peekFirst()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;查询队尾元素&lt;/td&gt;
&lt;td&gt;getLast()&lt;/td&gt;
&lt;td&gt;peekLast()&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;事实上，&lt;code&gt;Deque&lt;/code&gt; 还提供有 &lt;code&gt;push()&lt;/code&gt; 和 &lt;code&gt;pop()&lt;/code&gt; 等其他方法，可用于模拟栈。&lt;/p&gt;
&lt;h3 id=&#34;arraydeque-与-linkedlist-的区别&#34;&gt;ArrayDeque 与 LinkedList 的区别&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ArrayDeque&lt;/code&gt; 和 &lt;code&gt;LinkedList&lt;/code&gt; 都实现了 &lt;code&gt;Deque&lt;/code&gt; 接口，两者都具有队列的功能，但两者有什么区别呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ArrayDeque&lt;/code&gt; 是基于可变长的数组和双指针来实现，而 &lt;code&gt;LinkedList&lt;/code&gt; 则通过链表来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ArrayDeque&lt;/code&gt; 不支持存储 &lt;code&gt;NULL&lt;/code&gt; 数据，但 &lt;code&gt;LinkedList&lt;/code&gt; 支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ArrayDeque&lt;/code&gt; 是在 JDK1.6 才被引入的，而&lt;code&gt;LinkedList&lt;/code&gt; 早在 JDK1.2 时就已经存在。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ArrayDeque&lt;/code&gt; 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 &lt;code&gt;LinkedList&lt;/code&gt; 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从性能的角度上，选用 &lt;code&gt;ArrayDeque&lt;/code&gt; 来实现队列要比 &lt;code&gt;LinkedList&lt;/code&gt; 更好。此外，&lt;code&gt;ArrayDeque&lt;/code&gt; 也可以用于实现栈。&lt;/p&gt;
&lt;h3 id=&#34;priorityqueue&#34;&gt;PriorityQueue&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;PriorityQueue&lt;/code&gt; 是在 JDK1.5 中被引入的, 其与 &lt;code&gt;Queue&lt;/code&gt; 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。&lt;/p&gt;
&lt;p&gt;这里列举其相关的一些要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PriorityQueue&lt;/code&gt; 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PriorityQueue&lt;/code&gt; 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PriorityQueue&lt;/code&gt; 是非线程安全的，且不支持存储 &lt;code&gt;NULL&lt;/code&gt; 和 &lt;code&gt;non-comparable&lt;/code&gt; 的对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PriorityQueue&lt;/code&gt; 默认是小顶堆，但可以接收一个 &lt;code&gt;Comparator&lt;/code&gt; 作为构造参数，从而来自定义元素优先级的先后。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;map-接口&#34;&gt;Map 接口&lt;/h2&gt;
&lt;h3 id=&#34;hashmap-和-hashtable-的区别&#34;&gt;HashMap 和 Hashtable 的区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;线程是否安全：&lt;/strong&gt; &lt;code&gt;HashMap&lt;/code&gt; 是非线程安全的，&lt;code&gt;Hashtable&lt;/code&gt; 是线程安全的,因为 &lt;code&gt;Hashtable&lt;/code&gt; 内部的方法基本都经过&lt;code&gt;synchronized&lt;/code&gt; 修饰。（保证线程安全的话就使用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; ）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效率：&lt;/strong&gt; 因为线程安全的问题，&lt;code&gt;HashMap&lt;/code&gt; 要比 &lt;code&gt;Hashtable&lt;/code&gt; 效率高一点。另外，&lt;code&gt;Hashtable&lt;/code&gt; 基本被淘汰，不要在代码中使用它；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对 Null key 和 Null value 的支持：&lt;/strong&gt; &lt;code&gt;HashMap&lt;/code&gt; 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 &lt;code&gt;NullPointerException&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始容量大小和每次扩充容量大小的不同 ：&lt;/strong&gt; ① 创建时如果不指定容量初始值，&lt;code&gt;Hashtable&lt;/code&gt; 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。&lt;code&gt;HashMap&lt;/code&gt; 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 &lt;code&gt;HashMap&lt;/code&gt; 会将其扩充为 2 的幂次方大小（&lt;code&gt;HashMap&lt;/code&gt; 中的&lt;code&gt;tableSizeFor()&lt;/code&gt;方法保证，下面给出了源代码）。也就是说 &lt;code&gt;HashMap&lt;/code&gt; 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;底层数据结构：&lt;/strong&gt; JDK1.8 以后的 &lt;code&gt;HashMap&lt;/code&gt; 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;hashmap-和-hashset-区别&#34;&gt;HashMap 和 HashSet 区别&lt;/h3&gt;
&lt;p&gt;如果你看过 &lt;code&gt;HashSet&lt;/code&gt; 源码的话就应该知道：&lt;code&gt;HashSet&lt;/code&gt; 底层就是基于 &lt;code&gt;HashMap&lt;/code&gt; 实现的。（&lt;code&gt;HashSet&lt;/code&gt; 的源码非常非常少，因为除了 &lt;code&gt;clone()&lt;/code&gt;、&lt;code&gt;writeObject()&lt;/code&gt;、&lt;code&gt;readObject()&lt;/code&gt;是 &lt;code&gt;HashSet&lt;/code&gt; 自己不得不实现之外，其他方法都是直接调用 &lt;code&gt;HashMap&lt;/code&gt; 中的方法。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;实现了 &lt;code&gt;Map&lt;/code&gt; 接口&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;实现 &lt;code&gt;Set&lt;/code&gt; 接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;存储键值对&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;仅存储对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;调用 &lt;code&gt;put()&lt;/code&gt;向 map 中添加元素&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;调用 &lt;code&gt;add()&lt;/code&gt;方法向 &lt;code&gt;Set&lt;/code&gt; 中添加元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;HashMap&lt;/code&gt; 使用键（Key）计算 &lt;code&gt;hashcode&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;code&gt;HashSet&lt;/code&gt; 使用成员对象来计算 &lt;code&gt;hashcode&lt;/code&gt; 值，对于两个对象来说 &lt;code&gt;hashcode&lt;/code&gt; 可能相同，所以&lt;code&gt;equals()&lt;/code&gt;方法用来判断对象的相等性&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;hashmap-和-treemap-区别&#34;&gt;HashMap 和 TreeMap 区别&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TreeMap&lt;/code&gt; 和&lt;code&gt;HashMap&lt;/code&gt; 都继承自&lt;code&gt;AbstractMap&lt;/code&gt; ，但是需要注意的是&lt;code&gt;TreeMap&lt;/code&gt;它还实现了&lt;code&gt;NavigableMap&lt;/code&gt;接口和&lt;code&gt;SortedMap&lt;/code&gt; 接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相比于&lt;code&gt;HashMap&lt;/code&gt;来说 &lt;code&gt;TreeMap&lt;/code&gt; 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;hashset-如何检查重复&#34;&gt;HashSet 如何检查重复&lt;/h3&gt;
&lt;p&gt;当你把对象加入&lt;code&gt;HashSet&lt;/code&gt;时，&lt;code&gt;HashSet&lt;/code&gt; 会先计算对象的&lt;code&gt;hashcode&lt;/code&gt;值来判断对象加入的位置，同时也会与其他加入的对象的 &lt;code&gt;hashcode&lt;/code&gt; 值作比较，如果没有相符的 &lt;code&gt;hashcode&lt;/code&gt;，&lt;code&gt;HashSet&lt;/code&gt; 会假设对象没有重复出现。但是如果发现有相同 &lt;code&gt;hashcode&lt;/code&gt; 值的对象，这时会调用&lt;code&gt;equals()&lt;/code&gt;方法来检查 &lt;code&gt;hashcode&lt;/code&gt; 相等的对象是否真的相同。如果两者相同，&lt;code&gt;HashSet&lt;/code&gt; 就不会让加入操作成功。&lt;/p&gt;
&lt;p&gt;在openjdk8中，&lt;code&gt;HashSet&lt;/code&gt;的&lt;code&gt;add()&lt;/code&gt;方法只是简单的调用了&lt;code&gt;HashMap&lt;/code&gt;的&lt;code&gt;put()&lt;/code&gt;方法，并且判断了一下返回值以确保是否有重复元素。直接看一下&lt;code&gt;HashSet&lt;/code&gt;中的源码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Returns: true if this set did not already contain the specified element
// 返回值：当set中没有包含add的元素时返回真
public boolean add(E e) {
        return map.put(e, PRESENT)==null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在&lt;code&gt;HashMap&lt;/code&gt;的&lt;code&gt;putVal()&lt;/code&gt;方法中也能看到如下说明：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Returns : previous value, or null if none
// 返回值：如果插入位置没有元素返回null，否则返回上一个元素
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是说，在openjdk8中，实际上无论&lt;code&gt;HashSet&lt;/code&gt;中是否已经存在了某元素，&lt;code&gt;HashSet&lt;/code&gt;都会直接插入，只是会在&lt;code&gt;add()&lt;/code&gt;方法的返回值处告诉我们插入前是否存在相同元素。&lt;/p&gt;
&lt;h3 id=&#34;hashmap-的底层实现&#34;&gt;HashMap 的底层实现&lt;/h3&gt;
&lt;h4 id=&#34;jdk18-之前&#34;&gt;JDK1.8 之前&lt;/h4&gt;
&lt;p&gt;JDK1.8 之前 &lt;code&gt;HashMap&lt;/code&gt; 底层是 &lt;strong&gt;数组和链表&lt;/strong&gt; 结合在一起使用也就是 &lt;strong&gt;链表散列&lt;/strong&gt;。&lt;strong&gt;HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp;amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK 1.8 HashMap 的 hash 方法源码:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    static final int hash(Object key) {
      int h;
      // key.hashCode()：返回散列值也就是hashcode
      // ^ ：按位异或
      // &amp;gt;&amp;gt;&amp;gt;:无符号右移，忽略符号位，空位都以0补齐
      return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对比一下 JDK1.7 的 HashMap 的 hash 方法源码.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static int hash(int h) {
    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).

    h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12);
    return h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。&lt;/p&gt;
&lt;p&gt;所谓 &lt;strong&gt;“拉链法”&lt;/strong&gt; 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。&lt;/p&gt;
&lt;h4 id=&#34;jdk18-之后&#34;&gt;JDK1.8 之后&lt;/h4&gt;
&lt;p&gt;相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;concurrenthashmap-和-hashtable-的区别&#34;&gt;ConcurrentHashMap 和 Hashtable 的区别&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 和 &lt;code&gt;Hashtable&lt;/code&gt; 的区别主要体现在实现线程安全的方式上不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;底层数据结构：&lt;/strong&gt; JDK1.7 的 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 底层采用 &lt;strong&gt;分段的数组+链表&lt;/strong&gt; 实现，JDK1.8 采用的数据结构跟 &lt;code&gt;HashMap1.8&lt;/code&gt; 的结构一样，数组+链表/红黑二叉树。&lt;code&gt;Hashtable&lt;/code&gt; 和 JDK1.8 之前的 &lt;code&gt;HashMap&lt;/code&gt; 的底层数据结构类似都是采用 &lt;strong&gt;数组+链表&lt;/strong&gt; 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现线程安全的方式（重要）：&lt;/strong&gt; ① &lt;strong&gt;在 JDK1.7 的时候，&lt;code&gt;ConcurrentHashMap&lt;/code&gt;（分段锁）&lt;/strong&gt; 对整个桶数组进行了分割分段(&lt;code&gt;Segment&lt;/code&gt;)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 &lt;strong&gt;到了 JDK1.8 的时候已经摒弃了 &lt;code&gt;Segment&lt;/code&gt; 的概念，而是直接用 &lt;code&gt;Node&lt;/code&gt; 数组+链表+红黑树的数据结构来实现，并发控制使用 &lt;code&gt;synchronized&lt;/code&gt; 和 CAS 来操作。（JDK1.6 以后 对 &lt;code&gt;synchronized&lt;/code&gt; 锁做了很多优化）&lt;/strong&gt; 整个看起来就像是优化过且线程安全的 &lt;code&gt;HashMap&lt;/code&gt;，虽然在 JDK1.8 中还能看到 &lt;code&gt;Segment&lt;/code&gt; 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② &lt;strong&gt;&lt;code&gt;Hashtable&lt;/code&gt;(同一把锁)&lt;/strong&gt; :使用 &lt;code&gt;synchronized&lt;/code&gt; 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;collections-工具类&#34;&gt;Collections 工具类&lt;/h2&gt;
&lt;p&gt;Collections 工具类常用方法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;排序&lt;/li&gt;
&lt;li&gt;查找,替换操作&lt;/li&gt;
&lt;li&gt;同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;排序操作&#34;&gt;排序操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;查找替换操作&#34;&gt;查找,替换操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的
int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)
void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素
int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)
boolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素
&lt;/code&gt;&lt;/pre&gt;
">Java集合</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/java-ji-chu/"" data-c="
          &lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&#34;&gt;一、数据类型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B&#34;&gt;包装类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BC%93%E5%AD%98%E6%B1%A0&#34;&gt;缓存池&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8Cstring&#34;&gt;二、String&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A6%82%E8%A7%88&#34;&gt;概览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#string-%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%A5%BD%E5%A4%84&#34;&gt;String 不可变的好处&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#string,-stringbuffer-and-stringbuilder&#34;&gt;String, StringBuffer and StringBuilder&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stringintern&#34;&gt;String.intern()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E8%BF%90%E7%AE%97&#34;&gt;三、运算&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92&#34;&gt;参数传递&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#float-%E4%B8%8E-double&#34;&gt;float 与 double&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&#34;&gt;隐式类型转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#switch&#34;&gt;switch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E7%BB%A7%E6%89%BF&#34;&gt;四、继承&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90&#34;&gt;访问权限&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3&#34;&gt;抽象类与接口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#super&#34;&gt;super&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD&#34;&gt;重写与重载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%94object-%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95&#34;&gt;五、Object 通用方法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A6%82%E8%A7%88&#34;&gt;概览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#equals&#34;&gt;equals()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hashcode&#34;&gt;hashCode()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tostring&#34;&gt;toString()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#clone&#34;&gt;clone()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AD%E5%85%B3%E9%94%AE%E5%AD%97&#34;&gt;六、关键字&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#final&#34;&gt;final&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#static&#34;&gt;static&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%83%E5%8F%8D%E5%B0%84&#34;&gt;七、反射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AB%E5%BC%82%E5%B8%B8&#34;&gt;八、异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B9%9D%E6%B3%9B%E5%9E%8B&#34;&gt;九、泛型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E6%B3%A8%E8%A7%A3&#34;&gt;十、注解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%81%E4%B8%80%E7%89%B9%E6%80%A7&#34;&gt;十一、特性&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#java-%E5%90%84%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7&#34;&gt;Java 各版本的新特性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#java-%E4%B8%8E-c-%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;Java 与 C++ 的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#jre-or-jdk&#34;&gt;JRE or JDK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&#34;&gt;参考资料&lt;/a&gt;&lt;!-- GFM-TOC --&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;一-数据类型&#34;&gt;一、数据类型&lt;/h1&gt;
&lt;h2 id=&#34;包装类型&#34;&gt;包装类型&lt;/h2&gt;
&lt;p&gt;八个基本类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boolean/1&lt;/li&gt;
&lt;li&gt;byte/8&lt;/li&gt;
&lt;li&gt;char/16&lt;/li&gt;
&lt;li&gt;short/16&lt;/li&gt;
&lt;li&gt;int/32&lt;/li&gt;
&lt;li&gt;float/32&lt;/li&gt;
&lt;li&gt;long/64&lt;/li&gt;
&lt;li&gt;double/64&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer x = 2;     // 装箱
int y = x;         // 拆箱
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;缓存池&#34;&gt;缓存池&lt;/h2&gt;
&lt;p&gt;new Integer(123) 与 Integer.valueOf(123) 的区别在于，new Integer(123) 每次都会新建一个对象，而 Integer.valueOf(123) 可能会使用缓存对象，因此多次使用 Integer.valueOf(123) 会取得同一个对象的引用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer m = 123;
Integer n = 123;
System.out.println(m == n); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Integer valueOf(int i) {
    if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Java 8 中，Integer 缓存池的大小默认为 -128~127。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static final int low = -128;
static final int high;
static final Integer cache[];

static {
    // high value may be configured by property
    int h = 127;
    String integerCacheHighPropValue =
        sun.misc.VM.getSavedProperty(&amp;quot;java.lang.Integer.IntegerCache.high&amp;quot;);
    if (integerCacheHighPropValue != null) {
        try {
            int i = parseInt(integerCacheHighPropValue);
            i = Math.max(i, 127);
            // Maximum array size is Integer.MAX_VALUE
            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
        } catch( NumberFormatException nfe) {
            // If the property cannot be parsed into an int, ignore it.
        }
    }
    high = h;

    cache = new Integer[(high - low) + 1];
    int j = low;
    for(int k = 0; k &amp;lt; cache.length; k++)
        cache[k] = new Integer(j++);

    // range [-128, 127] must be interned (JLS7 5.1.7)
    assert IntegerCache.high &amp;gt;= 127;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Java 还将一些其它基本类型的值放在缓冲池中，包含以下这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boolean values true and false&lt;/li&gt;
&lt;li&gt;all byte values&lt;/li&gt;
&lt;li&gt;short values between -128 and 127&lt;/li&gt;
&lt;li&gt;int values between -128 and 127&lt;/li&gt;
&lt;li&gt;char in the range \u0000 to \u007F&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。&lt;/p&gt;
&lt;p&gt;[StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123&lt;/p&gt;
&lt;p&gt;](https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123)&lt;/p&gt;
&lt;h1 id=&#34;二-string&#34;&gt;二、String&lt;/h1&gt;
&lt;h2 id=&#34;概览&#34;&gt;概览&lt;/h2&gt;
&lt;p&gt;String 被声明为 final，因此它不可被继承。&lt;/p&gt;
&lt;p&gt;内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class String
    implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;string-不可变的好处&#34;&gt;String 不可变的好处&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 可以缓存 hash 值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. String Pool 的需要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 安全性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 线程安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String 不可变性天生具备线程安全，可以在多个线程中安全地使用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/&#34;&gt;Program Creek : Why String is immutable in Java?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;string-stringbuffer-and-stringbuilder&#34;&gt;String, StringBuffer and StringBuilder&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 可变性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String 不可变&lt;/li&gt;
&lt;li&gt;StringBuffer 和 StringBuilder 可变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 线程安全&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String 不可变，因此是线程安全的&lt;/li&gt;
&lt;li&gt;StringBuilder 不是线程安全的&lt;/li&gt;
&lt;li&gt;StringBuffer 是线程安全的，内部使用 synchronized 来同步&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/2971315/string-stringbuffer-and-stringbuilder&#34;&gt;StackOverflow : String, StringBuffer, and StringBuilder&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;stringintern&#34;&gt;String.intern()&lt;/h2&gt;
&lt;p&gt;使用 String.intern() 可以保证相同内容的字符串变量引用相同的内存对象。&lt;/p&gt;
&lt;p&gt;下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用，这个方法首先把 s1 引用的对象放到 String Pool（字符串常量池）中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String s1 = new String(&amp;quot;aaa&amp;quot;);
String s2 = new String(&amp;quot;aaa&amp;quot;);
System.out.println(s1 == s2);           // false
String s3 = s1.intern();
System.out.println(s1.intern() == s3);  // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是采用 &amp;quot;bbb&amp;quot; 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String s4 = &amp;quot;bbb&amp;quot;;
String s5 = &amp;quot;bbb&amp;quot;;
System.out.println(s4 == s5);  // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Java 7 之前，字符串常量池被放在运行时常量池中，它属于永久代。而在 Java 7，字符串常量池被放在堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/10578984/what-is-string-interning&#34;&gt;StackOverflow : What is String interning?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tech.meituan.com/in_depth_understanding_string_intern.html&#34;&gt;深入解析 String#intern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;三-运算&#34;&gt;三、运算&lt;/h1&gt;
&lt;h2 id=&#34;参数传递&#34;&gt;参数传递&lt;/h2&gt;
&lt;p&gt;Java 的参数是以值传递的形式传入方法中，而不是引用传递。&lt;/p&gt;
&lt;p&gt;Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Dog {
    String name;

    Dog(String name) {
        this.name = name;
    }

    String getName() {
        return name;
    }

    String getObjectAddress() {
        return super.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog(&amp;quot;A&amp;quot;);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        func(dog);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        System.out.println(dog.getName());          // A
    }

    private static void func(Dog dog) {
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        dog = new Dog(&amp;quot;B&amp;quot;);
        System.out.println(dog.getObjectAddress()); // Dog@74a14482
        System.out.println(dog.getName());          // B
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value&#34;&gt;StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;float-与-double&#34;&gt;float 与 double&lt;/h2&gt;
&lt;p&gt;1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。Java 不能隐式执行向下转型，因为这会使得精度降低。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// float f = 1.1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.1f 字面量才是 float 类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;float f = 1.1f;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;隐式类型转换&#34;&gt;隐式类型转换&lt;/h2&gt;
&lt;p&gt;因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;short s1 = 1;
// s1 = s1 + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是使用 += 运算符可以执行隐式类型转换。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;s1 += 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;s1 = (short) (s1 + 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting&#34;&gt;StackOverflow : Why don&#39;t Java&#39;s +=, -=, *=, /= compound assignment operators require casting?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;switch&#34;&gt;switch&lt;/h2&gt;
&lt;p&gt;从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String s = &amp;quot;a&amp;quot;;
switch (s) {
    case &amp;quot;a&amp;quot;:
        System.out.println(&amp;quot;aaa&amp;quot;);
        break;
    case &amp;quot;b&amp;quot;:
        System.out.println(&amp;quot;bbb&amp;quot;);
        break;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;switch 不支持 long，是因为 switch 的设计初衷是为那些只需要对少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// long x = 111;
// switch (x) { // Incompatible types. Found: &#39;long&#39;, required: &#39;char, byte, short, int, Character, Byte, Short, Integer, String, or an enum&#39;
//     case 111:
//         System.out.println(111);
//         break;
//     case 222:
//         System.out.println(222);
//         break;
// }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/2676210/why-cant-your-switch-statement-data-type-be-long-java&#34;&gt;StackOverflow : Why can&#39;t your switch statement data type be long, Java?&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;四-继承&#34;&gt;四、继承&lt;/h1&gt;
&lt;h2 id=&#34;访问权限&#34;&gt;访问权限&lt;/h2&gt;
&lt;p&gt;Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。&lt;/p&gt;
&lt;p&gt;可以对类或类中的成员（字段以及方法）加上访问修饰符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;成员可见表示其它类可以用这个类的实例对象访问到该成员；&lt;/li&gt;
&lt;li&gt;类可见表示其它类可以用这个类创建实例对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。&lt;/p&gt;
&lt;p&gt;设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。&lt;/p&gt;
&lt;p&gt;如果子类的方法覆盖了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。&lt;/p&gt;
&lt;p&gt;字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。可以使用公有的 getter 和 setter 方法来替换公有字段。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AccessExample {
    public int x;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AccessExample {
    private int x;

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AccessWithInnerClassExample {
    private class InnerClass {
        int x;
    }

    private InnerClass innerClass;

    public AccessWithInnerClassExample() {
        innerClass = new InnerClass();
    }

    public int getValue() {
        return innerClass.x; // 直接访问
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;抽象类与接口&#34;&gt;抽象类与接口&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 抽象类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;抽象类和抽象方法都使用 abstract 进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。&lt;/p&gt;
&lt;p&gt;抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class AbstractClassExample {

    protected int x;
    private int y;

    public abstract void func1();

    public void func2() {
        System.out.println(&amp;quot;func2&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AbstractExtendClassExample extends AbstractClassExample{
    @Override
    public void func1() {
        System.out.println(&amp;quot;func1&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// AbstractClassExample ac1 = new AbstractClassExample(); // &#39;AbstractClassExample&#39; is abstract; cannot be instantiated
AbstractClassExample ac2 = new AbstractExtendClassExample();
ac2.func1();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。&lt;/p&gt;
&lt;p&gt;从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。&lt;/p&gt;
&lt;p&gt;接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。&lt;/p&gt;
&lt;p&gt;接口的字段默认都是 static 和 final 的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface InterfaceExample {
    void func1();

    default void func2(){
        System.out.println(&amp;quot;func2&amp;quot;);
    }

    int x = 123;
    // int y;                // Variable &#39;y&#39; might not have been initialized
    public int z = 0;       // Modifier &#39;public&#39; is redundant for interface fields
    // private int k = 0;   // Modifier &#39;private&#39; not allowed here
    // protected int l = 0; // Modifier &#39;protected&#39; not allowed here
    // private void fun3(); // Modifier &#39;private&#39; not allowed here
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class InterfaceImplementExample implements InterfaceExample {
    @Override
    public void func1() {
        System.out.println(&amp;quot;func1&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// InterfaceExample ie1 = new InterfaceExample(); // &#39;InterfaceExample&#39; is abstract; cannot be instantiated
InterfaceExample ie2 = new InterfaceImplementExample();
ie2.func1();
System.out.println(InterfaceExample.x);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. 比较&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。&lt;/li&gt;
&lt;li&gt;从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。&lt;/li&gt;
&lt;li&gt;接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。&lt;/li&gt;
&lt;li&gt;接口的方法只能是 public 的，而抽象类的方法可以有多种访问权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. 使用选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用抽象类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要在几个相关的类中共享代码。&lt;/li&gt;
&lt;li&gt;需要能控制继承来的成员的访问权限，而不是都为 public。&lt;/li&gt;
&lt;li&gt;需要继承非静态（non-static）和非常量（non-final）字段。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；&lt;/li&gt;
&lt;li&gt;需要使用多重继承。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/&#34;&gt;深入理解 abstract class 和 interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dzone.com/articles/when-to-use-abstract-class-and-intreface&#34;&gt;When to Use Abstract Class and Interface&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;super&#34;&gt;super&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而完成一些初始化的工作。&lt;/li&gt;
&lt;li&gt;访问父类的成员：如果子类覆盖了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SuperExample {
    protected int x;
    protected int y;

    public SuperExample(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void func() {
        System.out.println(&amp;quot;SuperExample.func()&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SuperExtendExample extends SuperExample {
    private int z;

    public SuperExtendExample(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    public void func() {
        super.func();
        System.out.println(&amp;quot;SuperExtendExample.func()&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SuperExample e = new SuperExtendExample(1, 2, 3);
e.func();
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;SuperExample.func()
SuperExtendExample.func()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/java/IandI/super.html&#34;&gt;Using the Keyword super&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;重写与重载&#34;&gt;重写与重载&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;重写（Override）存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重载（Overload）存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。应该注意的是，返回值不同，其它都相同不算是重载。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;五-object-通用方法&#34;&gt;五、Object 通用方法&lt;/h1&gt;
&lt;h2 id=&#34;概览-2&#34;&gt;概览&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final native Class&amp;lt;?&amp;gt; getClass()

public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException

protected void finalize() throws Throwable {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;equals&#34;&gt;equals()&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. equals() 与 == 的区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。&lt;/li&gt;
&lt;li&gt;对于引用类型，== 判断两个实例是否引用同一个对象，而 equals() 判断引用的对象是否等价。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x.equals(y)); // true
System.out.println(x == y);      // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 等价关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（一）自反性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;x.equals(x); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（二）对称性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;x.equals(y) == y.equals(x); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（三）传递性&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (x.equals(y) &amp;amp;&amp;amp; y.equals(z))
    x.equals(z); // true;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（四）一致性&lt;/p&gt;
&lt;p&gt;多次调用 equals() 方法结果不变&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;x.equals(y) == x.equals(y); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（五）与 null 的比较&lt;/p&gt;
&lt;p&gt;对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;x.equals(null); // false;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. 实现&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查是否为同一个对象的引用，如果是直接返回 true；&lt;/li&gt;
&lt;li&gt;检查是否是同一个类型，如果不是，直接返回 false；&lt;/li&gt;
&lt;li&gt;将 Object 实例进行转型；&lt;/li&gt;
&lt;li&gt;判断每个关键域是否相等。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class EqualExample {
    private int x;
    private int y;
    private int z;

    public EqualExample(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        EqualExample that = (EqualExample) o;

        if (x != that.x) return false;
        if (y != that.y) return false;
        return z == that.z;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;hashcode&#34;&gt;hashCode()&lt;/h2&gt;
&lt;p&gt;hasCode() 返回散列值，而 equals() 是用来判断两个实例是否等价。等价的两个实例散列值一定要相同，但是散列值相同的两个实例不一定等价。&lt;/p&gt;
&lt;p&gt;在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个实例散列值也相等。&lt;/p&gt;
&lt;p&gt;下面的代码中，新建了两个等价的实例，并将它们添加到 HashSet 中。我们希望将这两个实例当成一样的，只在集合中添加一个实例，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个实例的散列值是不同的，最终导致集合添加了两个等价的实例。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;EqualExample e1 = new EqualExample(1, 1, 1);
EqualExample e2 = new EqualExample(1, 1, 1);
System.out.println(e1.equals(e2)); // true
HashSet&amp;lt;EqualExample&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
set.add(e1);
set.add(e2);
System.out.println(set.size());   // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;理想的散列函数应当具有均匀性，即不相等的实例应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。&lt;/p&gt;
&lt;p&gt;一个数与 31 相乘可以转换成移位和减法：&lt;code&gt;31*x == (x&amp;lt;&amp;lt;5)-x&lt;/code&gt;，编译器会自动进行这个优化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + x;
    result = 31 * result + y;
    result = 31 * result + z;
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tostring&#34;&gt;toString()&lt;/h2&gt;
&lt;p&gt;默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ToStringExample {
    private int number;

    public ToStringExample(int number) {
        this.number = number;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ToStringExample example = new ToStringExample(123);
System.out.println(example.toString());
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;ToStringExample@4554617c
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;clone&#34;&gt;clone()&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. cloneable&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;clone() 是 Object 的 protect 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CloneExample {
    private int a;
    private int b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;CloneExample e1 = new CloneExample();
// CloneExample e2 = e1.clone(); // &#39;clone()&#39; has protected access in &#39;java.lang.Object&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重写 clone() 得到以下实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CloneExample {
    private int a;
    private int b;

    @Override
    protected CloneExample clone() throws CloneNotSupportedException {
        return (CloneExample)super.clone();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;CloneExample e1 = new CloneExample();
try {
    CloneExample e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;java.lang.CloneNotSupportedException: CloneExample
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CloneExample implements Cloneable {
    private int a;
    private int b;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 深拷贝与浅拷贝&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浅拷贝：拷贝实例和原始实例的引用类型引用同一个对象；&lt;/li&gt;
&lt;li&gt;深拷贝：拷贝实例和原始实例的引用类型引用不同对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ShallowCloneExample implements Cloneable {
    private int[] arr;

    public ShallowCloneExample() {
        arr = new int[10];
        for (int i = 0; i &amp;lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected ShallowCloneExample clone() throws CloneNotSupportedException {
        return (ShallowCloneExample) super.clone();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ShallowCloneExample e1 = new ShallowCloneExample();
ShallowCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 222
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DeepCloneExample implements Cloneable {
    private int[] arr;

    public DeepCloneExample() {
        arr = new int[10];
        for (int i = 0; i &amp;lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected DeepCloneExample clone() throws CloneNotSupportedException {
        DeepCloneExample result = (DeepCloneExample) super.clone();
        result.arr = new int[arr.length];
        for (int i = 0; i &amp;lt; arr.length; i++) {
            result.arr[i] = arr[i];
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;DeepCloneExample e1 = new DeepCloneExample();
DeepCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CloneConstructorExample {
    private int[] arr;

    public CloneConstructorExample() {
        arr = new int[10];
        for (int i = 0; i &amp;lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public CloneConstructorExample(CloneConstructorExample original) {
        arr = new int[original.arr.length];
        for (int i = 0; i &amp;lt; original.arr.length; i++) {
            arr[i] = original.arr[i];
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;CloneConstructorExample e1 = new CloneConstructorExample();
CloneConstructorExample e2 = new CloneConstructorExample(e1);
e1.set(2, 222);
System.out.println(e2.get(2)); // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;六-关键字&#34;&gt;六、关键字&lt;/h1&gt;
&lt;h2 id=&#34;final&#34;&gt;final&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于基本类型，final 使数值不变；&lt;/li&gt;
&lt;li&gt;对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final int x = 1;
// x = 2;  // cannot assign value to final variable &#39;x&#39;
final A y = new A();
y.a = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;声明方法不能被子类重写。&lt;/p&gt;
&lt;p&gt;private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;声明类不允许被继承。&lt;/p&gt;
&lt;h2 id=&#34;static&#34;&gt;static&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 静态变量&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态变量：类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。&lt;/li&gt;
&lt;li&gt;实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class A {
    private int x;         // 实例变量
    private static int y;  // 静态变量

    public static void main(String[] args) {
        // int x = A.x;  // Non-static field &#39;x&#39; cannot be referenced from a static context
        A a = new A();
        int x = a.x;
        int y = A.y;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 静态方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态方法在类加载的时候就存在了，它不依赖于任何实例，所以静态方法必须有实现，也就是说它不能是抽象方法（abstract）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class A {
    public static void func1(){
    }
    // public abstract static void func2();  // Illegal combination of modifiers: &#39;abstract&#39; and &#39;static&#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class A {
    private static int x;
    private int y;

    public static void func1(){
        int a = x;
        // int b = y;  // Non-static field &#39;y&#39; cannot be referenced from a static context
        // int b = this.y;     // &#39;A.this&#39; cannot be referenced from a static context
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. 静态语句块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态语句块在类初始化时运行一次。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class A {
    static {
        System.out.println(&amp;quot;123&amp;quot;);
    }

    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new A();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4. 静态内部类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非静态内部类依赖于需要外部类的实例，而静态内部类不需要。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class OuterClass {
    class InnerClass {
    }

    static class StaticInnerClass {
    }

    public static void main(String[] args) {
        // InnerClass innerClass = new InnerClass(); // &#39;OuterClass.this&#39; cannot be referenced from a static context
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        StaticInnerClass staticInnerClass = new StaticInnerClass();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态内部类不能访问外部类的非静态的变量和方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 静态导包&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import static com.xxx.ClassName.*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 初始化顺序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static String staticField = &amp;quot;静态变量&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static {
    System.out.println(&amp;quot;静态语句块&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public String field = &amp;quot;实例变量&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;{
    System.out.println(&amp;quot;普通语句块&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后才是构造函数的初始化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public InitialOrderTest() {
    System.out.println(&amp;quot;构造函数&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;存在继承的情况下，初始化顺序为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父类（静态变量、静态语句块）&lt;/li&gt;
&lt;li&gt;子类（静态变量、静态语句块）&lt;/li&gt;
&lt;li&gt;父类（实例变量、普通语句块）&lt;/li&gt;
&lt;li&gt;父类（构造函数）&lt;/li&gt;
&lt;li&gt;子类（实例变量、普通语句块）&lt;/li&gt;
&lt;li&gt;子类（构造函数）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;七-反射&#34;&gt;七、反射&lt;/h1&gt;
&lt;p&gt;每个类都有一个  &lt;strong&gt;Class&lt;/strong&gt;  对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。&lt;/p&gt;
&lt;p&gt;类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;) 这种方式来控制类的加载，该方法会返回一个 Class 对象。&lt;/p&gt;
&lt;p&gt;反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。&lt;/p&gt;
&lt;p&gt;Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Field&lt;/strong&gt; ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Method&lt;/strong&gt; ：可以使用 invoke() 方法调用与 Method 对象关联的方法；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Constructor&lt;/strong&gt; ：可以用 Constructor 创建新的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Advantages of Using Reflection:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Extensibility Features&lt;/strong&gt;  : An application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Class Browsers and Visual Development Environments&lt;/strong&gt;  :  A class browser needs to be able to enumerate the members of classes. Visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Debuggers and Test Tools&lt;/strong&gt;  : Debuggers need to be able to examine private members on classes. Test harnesses can make use of reflection to systematically call a discoverable set APIs defined on a class, to insure a high level of code coverage in a test suite.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Drawbacks of Reflection:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Reflection is powerful, but should not be used indiscriminately. If it is possible to perform an operation without using reflection, then it is preferable to avoid using it. The following concerns should be kept in mind when accessing code via reflection.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Performance Overhead&lt;/strong&gt;  : Because reflection involves types that are dynamically resolved, certain Java virtual machine optimizations can not be performed. Consequently, reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Security Restrictions&lt;/strong&gt;  : Reflection requires a runtime permission which may not be present when running under a security manager. This is in an important consideration for code which has to run in a restricted security context, such as in an Applet.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Exposure of Internals&lt;/strong&gt;  :Since reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing private fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. Reflective code breaks abstractions and therefore may change behavior with upgrades of the platform.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/reflect/index.html&#34;&gt;Trail: The Reflection API&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.sczyh30.com/posts/Java/java-reflection-1/&#34;&gt;深入解析 Java 反射（1）- 基础&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;八-异常&#34;&gt;八、异常&lt;/h1&gt;
&lt;p&gt;Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： &lt;strong&gt;Error&lt;/strong&gt;  和 &lt;strong&gt;Exception&lt;/strong&gt;。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;受检异常&lt;/strong&gt; ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;非受检异常&lt;/strong&gt; ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.tianmaying.com/tutorial/Java-Exception&#34;&gt;Java 入门之异常处理&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.importnew.com/7383.html&#34;&gt;Java 异常的面试问题及答案 -Part 1&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;九-泛型&#34;&gt;九、泛型&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Box&amp;lt;T&amp;gt; {
    // T stands for &amp;quot;Type&amp;quot;
    private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.importnew.com/24029.html&#34;&gt;Java 泛型详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1033693&#34;&gt;10 道 Java 泛型面试题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;十-注解&#34;&gt;十、注解&lt;/h1&gt;
&lt;p&gt;Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html&#34;&gt;注解 Annotation 实现原理与自定义注解例子&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;十一-特性&#34;&gt;十一、特性&lt;/h1&gt;
&lt;h2 id=&#34;java-各版本的新特性&#34;&gt;Java 各版本的新特性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;New highlights in Java SE 8&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Lambda Expressions&lt;/li&gt;
&lt;li&gt;Pipelines and Streams&lt;/li&gt;
&lt;li&gt;Date and Time API&lt;/li&gt;
&lt;li&gt;Default Methods&lt;/li&gt;
&lt;li&gt;Type Annotations&lt;/li&gt;
&lt;li&gt;Nashhorn JavaScript Engine&lt;/li&gt;
&lt;li&gt;Concurrent Accumulators&lt;/li&gt;
&lt;li&gt;Parallel operations&lt;/li&gt;
&lt;li&gt;PermGen Error Removed&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;New highlights in Java SE 7&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Strings in Switch Statement&lt;/li&gt;
&lt;li&gt;Type Inference for Generic Instance Creation&lt;/li&gt;
&lt;li&gt;Multiple Exception Handling&lt;/li&gt;
&lt;li&gt;Support for Dynamic Languages&lt;/li&gt;
&lt;li&gt;Try with Resources&lt;/li&gt;
&lt;li&gt;Java nio Package&lt;/li&gt;
&lt;li&gt;Binary Literals, Underscore in literals&lt;/li&gt;
&lt;li&gt;Diamond Syntax&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.selfgrowth.com/articles/difference-between-java-18-and-java-17&#34;&gt;Difference between Java 1.8 and Java 1.7?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.importnew.com/19345.html&#34;&gt;Java 8 特性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;java-与-c-的区别&#34;&gt;Java 与 C++ 的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。&lt;/li&gt;
&lt;li&gt;Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。&lt;/li&gt;
&lt;li&gt;Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。&lt;/li&gt;
&lt;li&gt;Java 支持自动垃圾回收，而 C++ 需要手动回收。&lt;/li&gt;
&lt;li&gt;Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。&lt;/li&gt;
&lt;li&gt;Java 不支持操作符重载，虽然可以对两个 String 对象支持加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。&lt;/li&gt;
&lt;li&gt;Java 内置了线程的支持，而 C++ 需要依靠第三方库。&lt;/li&gt;
&lt;li&gt;Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。&lt;/li&gt;
&lt;li&gt;Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;http://cs-fundamentals.com/tech-interview/java/differences-between-java-and-cpp.php&#34;&gt;What are the main differences between Java and C++?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;jre-or-jdk&#34;&gt;JRE or JDK&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;JRE is the JVM program, Java application need to run on JRE.&lt;/li&gt;
&lt;li&gt;JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler &amp;quot;javac&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Eckel B. Java 编程思想[M]. 机械工业出版社, 2002.&lt;/li&gt;
&lt;li&gt;Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.&lt;/li&gt;
&lt;/ul&gt;
">Java基础</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/shi-yong-mybatis-gou-jian-example-jin-xing-tiao-jian-hua-cha-xun/"" data-c="
          &lt;h3 id=&#34;介绍&#34;&gt;介绍&lt;/h3&gt;
&lt;p&gt;使用MyBatis逆向工程，可以根据数据库中的表自动生成mapper.java、mapper.xml、pojo等文件。&lt;/p&gt;
&lt;p&gt;在构建完Example类时就可以使用tk.mybatis进行条件化查询。&lt;/p&gt;
&lt;h3 id=&#34;用法&#34;&gt;用法&lt;/h3&gt;
&lt;p&gt;1.条件化查询的的关键是&lt;code&gt;tk.mybatis&lt;/code&gt;中的&lt;code&gt;Example&lt;/code&gt;的构建&lt;/p&gt;
&lt;p&gt;2.构建完&lt;code&gt;Example&lt;/code&gt;类后就可以通过&lt;code&gt;Mapper&lt;/code&gt;中自带的&lt;code&gt;selectByExample&lt;/code&gt;方法进行搜索&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public AdminUser queryAdminByUsername(String username) {
        Example adminExample = new Example(AdminUser.class);
        Example.Criteria criteria = adminExample.createCriteria();
        criteria.andEqualTo(&amp;quot;username&amp;quot;,username);
        AdminUser admin = adminUserMapper.selectOneByExample(adminExample);
        return admin;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;模糊搜索&#34;&gt;模糊搜索&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String name = &amp;quot;云&amp;quot;;
Example adminExample = new Example(AdminUser.class);
adminExample.createCriteria().andNameLike(&#39;%&#39;+name+&#39;%&#39;);
List&amp;lt;AdminUser&amp;gt; userList = adminUserMapper.selectByExample(adminExample);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;可扩展条件搜索&#34;&gt;可扩展条件搜索&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Example adminExample = new Example(AdminUser.class);
Example.Criteria criteria = adminExample.createCriteria();
if(StringUtils.isNotBlank(user.getAddress())){
	criteria.andAddressEqualTo(user.getAddress());
}
if(StringUtils.isNotBlank(user.getName())){
	criteria.andNameEqualTo(user.getName());
}
//可继续扩展条件
List&amp;lt;AdminUser&amp;gt; userList = adminUserMapper.selectByExample(adminExample);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;通过字段排序&#34;&gt;通过字段排序&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String order = &amp;quot;age DESC&amp;quot;;
Example adminExample = new Example(AdminUser.class);
adminExample.setOrderByClause(order);
List&amp;lt;AdminUser&amp;gt; userList = adminUserMapper.selectByExample(adminExample);
&lt;/code&gt;&lt;/pre&gt;
">使用Mybatis构建Example进行条件化查询</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/java-lambda-biao-da-shi/"" data-c="
          &lt;h3 id=&#34;语法&#34;&gt;语法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;即使lambda表达式没有参数，仍然要提供空括号，类似于无参方法&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;() -&amp;gt; {....}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;如果可以推导出一个lambda表的参数类型，则可以忽略其类型&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;(s1 , s2) -&amp;gt; {....}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;如果方法只有一个参数，而且这个参数类型可以推导出，那么可以省略小括号&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;a -&amp;gt; {....}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;函数式接口&#34;&gt;函数式接口&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;只有一个抽象方法的接口，可以提供一个lambda表达式&lt;/li&gt;
&lt;li&gt;在Java中，对lambda表达式所能做的也就是转换为函数式接口&lt;/li&gt;
&lt;li&gt;ArrayList类有一个 removeIf 方法，它的参数就是一个 &lt;strong&gt;Predicate&lt;/strong&gt;，这个接口用来传递 &lt;strong&gt;lambda&lt;/strong&gt; 表达式 如，下面的语句将从一个数组列表删除所有null值&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;list.removeIf(e -&amp;gt; e == null)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;方法引用&#34;&gt;方法引用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out::println;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;指示编译器生成一个函数式接口的实例&lt;/li&gt;
&lt;li&gt;类似于lambda表达式，方法引用也不是一个对象&lt;/li&gt;
&lt;li&gt;要用 :: 运算符分隔方法名 与 对象 或 类名
&lt;ul&gt;
&lt;li&gt;对象::实例方法 lambda参数作为方法的显示参数传入&lt;/li&gt;
&lt;li&gt;类::实例方法 String::trim ，lambda表达式会成为隐式对象&lt;/li&gt;
&lt;li&gt;类::静态方法 Integer::valueOf，lambda表达式会传递到这个静态方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方法引用不能独立存在，总是会转换为函数式接口的实例&lt;/li&gt;
&lt;li&gt;包含对象的方法引用 与 等价的lambda表达式还有一个细微差别 如果对象为空，方法引用会直接抛出异常，而lambda表达式只有在调用时才会抛出异常&lt;/li&gt;
&lt;li&gt;可以在方法引用中使用 this 、super参数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;构造器引用&#34;&gt;构造器引用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;与方法引用类似，不过方法名为 new&lt;/li&gt;
&lt;li&gt;数组的构造器引用 Integer[]::new&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;变量作用域&#34;&gt;变量作用域&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;lambda表达式可以“捕获”外围作用域中变􏰁的值，只要确保所捕获的值时明确定义的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lambda&lt;/strong&gt;表达式的与 嵌套块 有相同的作用域，在lambda表达式中声明一个与局部变􏰁同名的参数或局部变􏰁是不合法的&lt;/li&gt;
&lt;li&gt;lambda表达式中的 this 含义与外面一致&lt;/li&gt;
&lt;/ul&gt;
">Java Lambda表达式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/707-she-ji-lian-biao/"" data-c="
          &lt;p&gt;设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。&lt;/p&gt;
&lt;p&gt;在链表类中实现这些功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。&lt;/li&gt;
&lt;li&gt;addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。&lt;/li&gt;
&lt;li&gt;addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素*&lt;/li&gt;
&lt;li&gt;addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。&lt;/li&gt;
&lt;li&gt;deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //链表变为1-&amp;gt; 2-&amp;gt; 3
linkedList.get(1);            //返回2
linkedList.deleteAtIndex(1);  //现在链表是1-&amp;gt; 3
linkedList.get(1);            //返回3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//单链表
class ListNode {
    int val;
    ListNode next;
    ListNode(){}
    ListNode(int val) {
        this.val=val;
    }
}
class MyLinkedList {
    //size存储链表元素的个数
    int size;
    //虚拟头结点
    ListNode head;

    //初始化链表
    public MyLinkedList() {
        size = 0;
        head = new ListNode(0);
    }

    //获取第index个节点的数值
    public int get(int index) {
        //如果index非法，返回-1
        if (index &amp;lt; 0 || index &amp;gt;= size) {
            return -1;
        }
        ListNode currentNode = head;
        //包含一个虚拟头节点，所以查找第 index+1 个节点
        for (int i = 0; i &amp;lt;= index; i++) {
            currentNode = currentNode.next;
        }
        return currentNode.val;
    }

    //在链表最前面插入一个节点
    public void addAtHead(int val) {
        addAtIndex(0, val);
    }

    //在链表的最后插入一个节点
    public void addAtTail(int val) {
        addAtIndex(size, val);
    }

    // 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
    // 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点
    // 如果 index 大于链表的长度，则返回空
    public void addAtIndex(int index, int val) {
        if (index &amp;gt; size) {
            return;
        }
        if (index &amp;lt; 0) {
            index = 0;
        }
        size++;
        //找到要插入节点的前驱
        ListNode pred = head;
        for (int i = 0; i &amp;lt; index; i++) {
            pred = pred.next;
        }
        ListNode toAdd = new ListNode(val);
        toAdd.next = pred.next;
        pred.next = toAdd;
    }

    //删除第index个节点
    public void deleteAtIndex(int index) {
        if (index &amp;lt; 0 || index &amp;gt;= size) {
            return;
        }
        size--;
        ListNode pred = head;
        for (int i = 0; i &amp;lt; index; i++) {
            pred = pred.next;
        }
        pred.next = pred.next.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">707. 设计链表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/19-shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian/"" data-c="
          &lt;p&gt;给你一个链表，删除链表的倒数第 &lt;code&gt;n&lt;/code&gt; 个结点，并且返回链表的头结点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;双指针&#34;&gt;双指针&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;

        ListNode slow = dummy;
        ListNode fast = dummy;
        while (n-- &amp;gt; 0) {
            fast = fast.next;
        }
        // 记住 待删除节点slow 的上一节点
        ListNode prev = null;
        while (fast != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next;
        }
        // 上一节点的next指针绕过 待删除节点slow 直接指向slow的下一节点
        prev.next = slow.next;
        // 释放 待删除节点slow 的next指针, 这句删掉也能AC
        slow.next = null;

        return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(L),其中 L 是链表的长度。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。&lt;/li&gt;
&lt;/ul&gt;
">19. 删除链表的倒数第N个节点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/mian-shi-ti-0207-lian-biao-xiang-jiao/"" data-c="
          &lt;p&gt;给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/160_example_1.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at &#39;8&#39;
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int lA = 0;
        int lB = 0;
        ListNode curA = headA;
        ListNode curB = headB;
        while(curA != null) {
            lA++;
            curA = curA.next;
        }
        while(curB != null) {
            lB++;
            curB = curB.next;
        }
        curA = headA;
        curB = headB;
        if(lA &amp;gt; lB){
            int gap = lA - lB;
            while(gap &amp;gt; 0){
                curA = curA.next;
                gap--;
            }
        }else{
            int gap = lB - lA;
            while(gap &amp;gt; 0){
                curB = curB.next;
                gap--;
            }
        }
        while(curA != null){
            if(curA == curB){
                return curA;
            }
            curA = curA.next;
            curB = curB.next;
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n + m)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
">面试题 02.07. 链表相交</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/1002-cha-zhao-gong-yong-zi-fu/"" data-c="
          &lt;p&gt;给你一个字符串数组 words ，请你找出所有在 words 的每个字符串中都出现的共用字符（ 包括重复字符），并以数组形式返回。你可以按 任意顺序 返回答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：words = [&amp;quot;bella&amp;quot;,&amp;quot;label&amp;quot;,&amp;quot;roller&amp;quot;]
输出：[&amp;quot;e&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public List&amp;lt;String&amp;gt; commonChars(String[] A) {
        List&amp;lt;String&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();
        if (A.length == 0) return result;
        int[] hash= new int[26]; // 用来统计所有字符串里字符出现的最小频率
        for (int i = 0; i &amp;lt; A[0].length(); i++) { // 用第一个字符串给hash初始化
            hash[A[0].charAt(i)- &#39;a&#39;]++;
        }
        // 统计除第一个字符串外字符的出现频率
        for (int i = 1; i &amp;lt; A.length; i++) {
            int[] hashOtherStr= new int[26];
            for (int j = 0; j &amp;lt; A[i].length(); j++) {
                hashOtherStr[A[i].charAt(j)- &#39;a&#39;]++;
            }
            // 更新hash，保证hash里统计26个字符在所有字符串里出现的最小次数
            for (int k = 0; k &amp;lt; 26; k++) {
                hash[k] = Math.min(hash[k], hashOtherStr[k]);
            }
        }
        // 将hash统计的字符次数，转成输出形式
        for (int i = 0; i &amp;lt; 26; i++) {
            while (hash[i] != 0) { // 注意这里是while，多个重复的字符
                char c= (char) (i+&#39;a&#39;);
                result.add(String.valueOf(c));
                hash[i]--;
            }
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">1002. 查找共用字符</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/704-er-fen-cha-zhao/"" data-c="
          &lt;p&gt;给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。&lt;/p&gt;
&lt;p&gt;实例1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你可以假设 &lt;code&gt;nums&lt;/code&gt; 中的所有元素是不重复的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt; 将在 &lt;code&gt;[1, 10000]&lt;/code&gt;之间。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums&lt;/code&gt; 的每个元素都将在 &lt;code&gt;[-9999, 9999]&lt;/code&gt;之间&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length-1;
        while(left &amp;lt;= right){
            int mid = left + (right - left)/2;
            if(nums[mid] &amp;lt; target){
                left = mid +1;
            }else if(nums[mid] &amp;gt; target){
                right = mid -1;
            }else{
                return mid;
            }
        }
        return -1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有序数组和数组中无重复元素，这些都是使用二分法的前提。&lt;/li&gt;
&lt;li&gt;二分法区间[left,right], 循环区间left &amp;lt;= right&lt;/li&gt;
&lt;/ul&gt;
">704. 二分查找</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/209-chang-du-zui-xiao-de-zi-shu-zu/"" data-c="
          &lt;p&gt;给定一个含有 n 个正整数的数组和一个正整数 target 。&lt;/p&gt;
&lt;p&gt;找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= target &amp;lt;= 109&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 105&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums[i] &amp;lt;= 105&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int slow = 0;
        int fast = 0;
        int sum = 0;
        int res = Integer.MAX_VALUE;
        for(;fast &amp;lt; nums.length;fast++){
            sum += nums[fast];
            while(sum &amp;gt;= target){
                res = Math.min(res,fast-slow+1);
                sum -= nums[slow++];
            }
        }
        return res == Integer.MAX_VALUE?0:res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">209. 长度最小的子数组</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/977-you-xu-shu-zu-de-ping-fang/"" data-c="
          &lt;p&gt;给你一个按 &lt;strong&gt;非递减顺序&lt;/strong&gt; 排序的整数数组 &lt;code&gt;nums&lt;/code&gt;，返回 &lt;strong&gt;每个数字的平方&lt;/strong&gt; 组成的新数组，要求也按 &lt;strong&gt;非递减顺序&lt;/strong&gt; 排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 104&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-104 &amp;lt;= nums[i] &amp;lt;= 104&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums&lt;/code&gt; 已按 &lt;strong&gt;非递减顺序&lt;/strong&gt; 排序&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int[] sortedSquares(int[] nums) {
        int right = nums.length - 1;
        int left = 0;
        int[] result = new int[nums.length];
        int index = result.length - 1;
        while (left &amp;lt;= right) {
            if (nums[left] * nums[left] &amp;gt; nums[right] * nums[right]) {
                result[index--] = nums[left] * nums[left];
                ++left;
            } else {
                result[index--] = nums[right] * nums[right];
                --right;
            }
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">977. 有序数组的平方</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/142-huan-xing-lian-biao-ii/"" data-c="
          &lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 &lt;code&gt;null&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/circularlinkedlist.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(fast != null &amp;amp;&amp;amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            //链表有环
            if(slow == fast) {
                ListNode t1 = head;
                ListNode t2 = fast;
                while(t1 != t2){
                    t1 = t1.next;
                    t2 = t2.next;
                }
                return t1;
            }
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环&lt;/li&gt;
&lt;li&gt;从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。&lt;/li&gt;
&lt;/ul&gt;
">142. 环形链表 II</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/59-luo-xuan-ju-zhen-ii/"" data-c="
          &lt;p&gt;给你一个正整数 &lt;code&gt;n&lt;/code&gt; ，生成一个包含 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n2&lt;/code&gt; 所有元素，且元素按顺时针顺序螺旋排列的 &lt;code&gt;n x n&lt;/code&gt; 正方形矩阵 &lt;code&gt;matrix&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/spiraln.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int[][] generateMatrix(int n) {
        int[][] res = new int[n][n];

        // 循环次数
        int loop = n / 2;

        // 定义每次循环起始位置
        int startX = 0;
        int startY = 0;

        // 定义偏移量
        int offset = 1;

        // 定义填充数字
        int count = 1;

        // 定义中间位置
        int mid = n / 2;
        while (loop &amp;gt; 0) {
            int i = startX;
            int j = startY;

            // 模拟上侧从左到右
            for (; j&amp;lt;startY + n -offset; ++j) {
                res[startX][j] = count++;
            }

            // 模拟右侧从上到下
            for (; i&amp;lt;startX + n -offset; ++i) {
                res[i][j] = count++;
            }

            // 模拟下侧从右到左
            for (; j &amp;gt; startY; j--) {
                res[i][j] = count++;
            }

            // 模拟左侧从下到上
            for (; i &amp;gt; startX; i--) {
                res[i][j] = count++;
            }

            loop--;

            startX += 1;
            startY += 1;

            offset += 2;
        }

        if (n % 2 == 1) {
            res[mid][mid] = count;
        }

        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">59. 螺旋矩阵 II</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/203-yi-chu-lian-biao-yuan-su/"" data-c="
          &lt;p&gt;给你一个链表的头节点 &lt;code&gt;head&lt;/code&gt; 和一个整数 &lt;code&gt;val&lt;/code&gt; ，请你删除链表中所有满足 &lt;code&gt;Node.val == val&lt;/code&gt; 的节点，并返回 &lt;strong&gt;新的头节点&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0,head);
        ListNode pre = dummy;
        ListNode cur = dummy.next;
        while(cur != null){
            if(cur.val == val){
                pre.next = cur.next;
            }else{
                pre = cur;
            }
            cur = cur.next;
        }
        return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">203. 移除链表元素</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/202-kuai-le-shu/"" data-c="
          &lt;p&gt;编写一个算法来判断一个数 &lt;code&gt;n&lt;/code&gt; 是不是快乐数&lt;/p&gt;
&lt;p&gt;「快乐数」 定义为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。&lt;/li&gt;
&lt;li&gt;然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。&lt;br&gt;
如果这个过程 结果为 1，那么这个数就是快乐数。&lt;/li&gt;
&lt;li&gt;如果 n 是 快乐数 就返回 true ；不是，则返回 false 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;题目中说了会 &lt;strong&gt;无限循环&lt;/strong&gt;，那么也就是说&lt;strong&gt;求和的过程中，sum会重复出现，这对解题很重要&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public boolean isHappy(int n) {
        Set&amp;lt;Integer&amp;gt; record = new HashSet&amp;lt;&amp;gt;();
        while(n != 1 &amp;amp;&amp;amp; !record.contains(n)) {
            record.add(n);
            n = getNext(n);
        }
        return n == 1;
    }
    private int getNext(int n) {
        int res = 0;
        while(n &amp;gt; 0) {
            int temp = n % 10;
            res += temp * temp;
            n = n / 10;
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">202. 快乐数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/206-fan-zhuan-lian-biao/"" data-c="
          &lt;p&gt;给你单链表的头节点 &lt;code&gt;head&lt;/code&gt; ，请你反转链表，并返回反转后的链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/rev1ex1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;双指针&#34;&gt;双指针：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode dummy = new ListNode(0,head);
        ListNode pre = null;
        ListNode cur = dummy.next;
        while(cur != null){
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;递归&#34;&gt;递归：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public ListNode reverseList(ListNode head) {
        return reverse(null,head);
    }
    private ListNode reverse(ListNode pre,ListNode cur){
        if(cur == null){
            return pre;
        }
        ListNode temp = cur.next;
        cur.next = pre;
        return reverse(cur,temp);
    }
}
&lt;/code&gt;&lt;/pre&gt;
">206. 反转链表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/27-yi-chu-yuan-su/"" data-c="
          &lt;p&gt;给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;
&lt;p&gt;实例1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;code&gt;0 &amp;lt;= nums.length &amp;lt;= 100&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;code&gt;0 &amp;lt;= nums[i] &amp;lt;= 50&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;code&gt;0 &amp;lt;= val &amp;lt;= 100&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int removeElement(int[] nums, int val) {
        int slow = 0;
        int fast = 0;
        for(;fast &amp;lt; nums.length;fast++){
            if(nums[fast] != val){
                nums[slow++] = nums[fast];
            }
        }
        return slow;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">27. 移除元素</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/349-liang-ge-shu-zu-de-jiao-ji/"" data-c="
          &lt;p&gt;给定两个数组 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt; ，返回 &lt;em&gt;它们的交集&lt;/em&gt; 。输出结果中的每个元素一定是 &lt;strong&gt;唯一&lt;/strong&gt; 的。我们可以 &lt;strong&gt;不考虑输出结果的顺序&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        if (nums1 == null||nums2 == null) {
            return new int[0];
        }
        Set&amp;lt;Integer&amp;gt; s1 = new HashSet&amp;lt;&amp;gt;();
        Set&amp;lt;Integer&amp;gt; res = new HashSet&amp;lt;&amp;gt;();
        for(int i=0;i &amp;lt; nums1.length;i++) {
            s1.add(nums1[i]);
        }
        for (int n: nums2) {
            if (s1.contains(n)) {
                res.add(n);
            }
        }
        int[] result = new int[res.size()];
        int index = 0;
        for (int i : res) {
            result[index++] = i;
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">349. 两个数组的交集</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/1-liang-shu-zhi-he/"" data-c="
          &lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出 &lt;strong&gt;和为目标值&lt;/strong&gt; &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; 的那 &lt;strong&gt;两个&lt;/strong&gt; 整数，并返回它们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] res = new int[2];
        Map&amp;lt;Integer,Integer&amp;gt; record = new HashMap&amp;lt;&amp;gt;();
        for (int i = 0;i &amp;lt; nums.length;i++) {
            if(record.containsKey(target-nums[i])) {
                res[0] = record.get(target-nums[i]);
                res[1] = i;
                break;
            }
            record.put(nums[i],i);
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">1. 两数之和</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/383-shu-jin-xin/"" data-c="
          &lt;p&gt;给你两个字符串：&lt;code&gt;ransomNote&lt;/code&gt; 和 &lt;code&gt;magazine&lt;/code&gt; ，判断 &lt;code&gt;ransomNote&lt;/code&gt; 能不能由 &lt;code&gt;magazine&lt;/code&gt; 里面的字符构成。如果可以，返回 &lt;code&gt;true&lt;/code&gt; ；否则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;code&gt;magazine&lt;/code&gt; 中的每个字符只能在 &lt;code&gt;ransomNote&lt;/code&gt; 中使用一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：ransomNote = &amp;quot;a&amp;quot;, magazine = &amp;quot;b&amp;quot;
输出：false
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。&lt;/li&gt;
&lt;li&gt;然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        //记录杂志字符串出现的次数
        int[] arr = new int[26];
        int temp;
        for (int i = 0; i &amp;lt; magazine.length(); i++) {
            temp = magazine.charAt(i) - &#39;a&#39;;
            arr[temp]++;
        }
        for (int i = 0; i &amp;lt; ransomNote.length(); i++) {
            temp = ransomNote.charAt(i) - &#39;a&#39;;
            //对于金信中的每一个字符都在数组中查找
            //找到相应位减一，否则找不到返回false
            if (arr[temp] &amp;gt; 0) {
                arr[temp]--;
            } else {
                return false;
            }
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">383. 赎金信</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/454-si-shu-xiang-jia-ii/"" data-c="
          &lt;p&gt;给你四个整数数组 &lt;code&gt;nums1&lt;/code&gt;、&lt;code&gt;nums2&lt;/code&gt;、&lt;code&gt;nums3&lt;/code&gt; 和 &lt;code&gt;nums4&lt;/code&gt; ，数组长度都是 &lt;code&gt;n&lt;/code&gt; ，请你计算有多少个元组 &lt;code&gt;(i, j, k, l)&lt;/code&gt; 能满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= i, j, k, l &amp;lt; n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -&amp;gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -&amp;gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        int temp = 0;
        int res = 0;
        Map&amp;lt;Integer,Integer&amp;gt; record = new HashMap&amp;lt;&amp;gt;();
        //统计两个数组中的元素之和，同时统计出现的次数，放入map
        for(int n1 : nums1) {
            for (int n2 : nums2) {
                temp = n1 + n2;
                if (record.containsKey(temp)) {
                    record.put(temp,record.get(temp)+1);
                } else {
                    record.put(temp,1);
                }
            }
        }
        //统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数
        for (int n3 : nums3) {
            for (int n4 : nums4) {
                temp = 0 - (n3 + n4);
                if (record.containsKey(temp)) {
                    res += record.get(temp);
                }
            }
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">454. 四数相加 II</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/242-you-xiao-de-zi-mu-yi-wei-ci/"" data-c="
          &lt;p&gt;给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。&lt;/p&gt;
&lt;p&gt;注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot;
输出: true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数组其实就是一个简单哈希表&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义一个数组叫做record用来上记录字符串s里字符出现的次数&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution:&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public boolean isAnagram(String s, String t) {
        int[] record = new int[26];
        for(int i = 0;i &amp;lt; s.length();i++) {
            record[s.charAt(i)-&#39;a&#39;] += 1;
        }
        for(int i = 0;i&amp;lt;t.length();i++) {
            record[t.charAt(i)-&#39;a&#39;] -= 1;
        }
        for(int i = 0;i &amp;lt; 26;i++) {
            if(record[i] != 0) {
                return false;
            }
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
">242. 有效的字母异位词</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/24-liang-liang-jiao-huan-lian-biao-zhong-de-jie-dian/"" data-c="
          &lt;p&gt;给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lijiexi/Picbed_PicGo/main/blogImg/swap_ex1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [1,2,3,4]
输出：[2,1,4,3]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;迭代&#34;&gt;迭代：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0,head);
        ListNode cur = dummy;
        while(cur.next != null&amp;amp;&amp;amp;cur.next.next != null){
            ListNode temp1 = cur.next;
            ListNode temp2 = cur.next.next.next;
            cur.next = cur.next.next;
            cur.next.next = temp1;
            cur.next.next.next = temp2;
            cur = cur.next.next;
        }
        return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)，其中 n是链表的节点数量。需要对每个节点进行更新指针的操作。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)。&lt;/li&gt;
&lt;/ul&gt;
">24. 两两交换链表中的节点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
">简介</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://lijiexi.github.io/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>



<script src="/media/js/mouse/love.js"></script>




</html>